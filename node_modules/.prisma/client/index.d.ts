
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SubscriptionPackage
 * 
 */
export type SubscriptionPackage = $Result.DefaultSelection<Prisma.$SubscriptionPackagePayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model SaaSPayment
 * 
 */
export type SaaSPayment = $Result.DefaultSelection<Prisma.$SaaSPaymentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model CashRegister
 * 
 */
export type CashRegister = $Result.DefaultSelection<Prisma.$CashRegisterPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model PosSession
 * 
 */
export type PosSession = $Result.DefaultSelection<Prisma.$PosSessionPayload>
/**
 * Model ServiceTicket
 * 
 */
export type ServiceTicket = $Result.DefaultSelection<Prisma.$ServiceTicketPayload>
/**
 * Model ServicePart
 * 
 */
export type ServicePart = $Result.DefaultSelection<Prisma.$ServicePartPayload>
/**
 * Model ServiceHistory
 * 
 */
export type ServiceHistory = $Result.DefaultSelection<Prisma.$ServiceHistoryPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model PackageModule
 * 
 */
export type PackageModule = $Result.DefaultSelection<Prisma.$PackageModulePayload>
/**
 * Model SuperAdminRole
 * 
 */
export type SuperAdminRole = $Result.DefaultSelection<Prisma.$SuperAdminRolePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model LandingContent
 * 
 */
export type LandingContent = $Result.DefaultSelection<Prisma.$LandingContentPayload>
/**
 * Model PaymentProvider
 * 
 */
export type PaymentProvider = $Result.DefaultSelection<Prisma.$PaymentProviderPayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model TicketReply
 * 
 */
export type TicketReply = $Result.DefaultSelection<Prisma.$TicketReplyPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TenantType: {
  corporate: 'corporate',
  individual: 'individual'
};

export type TenantType = (typeof TenantType)[keyof typeof TenantType]


export const TenantStatus: {
  active: 'active',
  suspended: 'suspended',
  trial: 'trial'
};

export type TenantStatus = (typeof TenantStatus)[keyof typeof TenantStatus]


export const UserRole: {
  superuser: 'superuser',
  admin: 'admin',
  manager: 'manager',
  accountant: 'accountant',
  cashier: 'cashier',
  technician: 'technician'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AccountType: {
  customer: 'customer',
  supplier: 'supplier'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const StockMovementType: {
  purchase: 'purchase',
  sale: 'sale',
  return: 'return',
  adjustment: 'adjustment'
};

export type StockMovementType = (typeof StockMovementType)[keyof typeof StockMovementType]


export const TransactionType: {
  income: 'income',
  expense: 'expense'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const InvoiceType: {
  sales: 'sales',
  purchase: 'purchase'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const InvoiceStatus: {
  draft: 'draft',
  sent: 'sent',
  paid: 'paid',
  overdue: 'overdue'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const OfferStatus: {
  draft: 'draft',
  sent: 'sent',
  accepted: 'accepted',
  rejected: 'rejected',
  invoiced: 'invoiced'
};

export type OfferStatus = (typeof OfferStatus)[keyof typeof OfferStatus]


export const ServiceStatus: {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  delivered: 'delivered'
};

export type ServiceStatus = (typeof ServiceStatus)[keyof typeof ServiceStatus]


export const LeaveStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const TicketPriority: {
  low: 'low',
  medium: 'medium',
  high: 'high',
  critical: 'critical'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TicketStatus: {
  open: 'open',
  in_progress: 'in_progress',
  resolved: 'resolved',
  closed: 'closed'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]

}

export type TenantType = $Enums.TenantType

export const TenantType: typeof $Enums.TenantType

export type TenantStatus = $Enums.TenantStatus

export const TenantStatus: typeof $Enums.TenantStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type StockMovementType = $Enums.StockMovementType

export const StockMovementType: typeof $Enums.StockMovementType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type OfferStatus = $Enums.OfferStatus

export const OfferStatus: typeof $Enums.OfferStatus

export type ServiceStatus = $Enums.ServiceStatus

export const ServiceStatus: typeof $Enums.ServiceStatus

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SubscriptionPackages
 * const subscriptionPackages = await prisma.subscriptionPackage.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SubscriptionPackages
   * const subscriptionPackages = await prisma.subscriptionPackage.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.subscriptionPackage`: Exposes CRUD operations for the **SubscriptionPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPackages
    * const subscriptionPackages = await prisma.subscriptionPackage.findMany()
    * ```
    */
  get subscriptionPackage(): Prisma.SubscriptionPackageDelegate<ExtArgs>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.saaSPayment`: Exposes CRUD operations for the **SaaSPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaaSPayments
    * const saaSPayments = await prisma.saaSPayment.findMany()
    * ```
    */
  get saaSPayment(): Prisma.SaaSPaymentDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs>;

  /**
   * `prisma.cashRegister`: Exposes CRUD operations for the **CashRegister** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashRegisters
    * const cashRegisters = await prisma.cashRegister.findMany()
    * ```
    */
  get cashRegister(): Prisma.CashRegisterDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.posSession`: Exposes CRUD operations for the **PosSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosSessions
    * const posSessions = await prisma.posSession.findMany()
    * ```
    */
  get posSession(): Prisma.PosSessionDelegate<ExtArgs>;

  /**
   * `prisma.serviceTicket`: Exposes CRUD operations for the **ServiceTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTickets
    * const serviceTickets = await prisma.serviceTicket.findMany()
    * ```
    */
  get serviceTicket(): Prisma.ServiceTicketDelegate<ExtArgs>;

  /**
   * `prisma.servicePart`: Exposes CRUD operations for the **ServicePart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceParts
    * const serviceParts = await prisma.servicePart.findMany()
    * ```
    */
  get servicePart(): Prisma.ServicePartDelegate<ExtArgs>;

  /**
   * `prisma.serviceHistory`: Exposes CRUD operations for the **ServiceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceHistories
    * const serviceHistories = await prisma.serviceHistory.findMany()
    * ```
    */
  get serviceHistory(): Prisma.ServiceHistoryDelegate<ExtArgs>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs>;

  /**
   * `prisma.packageModule`: Exposes CRUD operations for the **PackageModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageModules
    * const packageModules = await prisma.packageModule.findMany()
    * ```
    */
  get packageModule(): Prisma.PackageModuleDelegate<ExtArgs>;

  /**
   * `prisma.superAdminRole`: Exposes CRUD operations for the **SuperAdminRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdminRoles
    * const superAdminRoles = await prisma.superAdminRole.findMany()
    * ```
    */
  get superAdminRole(): Prisma.SuperAdminRoleDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.landingContent`: Exposes CRUD operations for the **LandingContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LandingContents
    * const landingContents = await prisma.landingContent.findMany()
    * ```
    */
  get landingContent(): Prisma.LandingContentDelegate<ExtArgs>;

  /**
   * `prisma.paymentProvider`: Exposes CRUD operations for the **PaymentProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentProviders
    * const paymentProviders = await prisma.paymentProvider.findMany()
    * ```
    */
  get paymentProvider(): Prisma.PaymentProviderDelegate<ExtArgs>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs>;

  /**
   * `prisma.ticketReply`: Exposes CRUD operations for the **TicketReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketReplies
    * const ticketReplies = await prisma.ticketReply.findMany()
    * ```
    */
  get ticketReply(): Prisma.TicketReplyDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SubscriptionPackage: 'SubscriptionPackage',
    Tenant: 'Tenant',
    SaaSPayment: 'SaaSPayment',
    User: 'User',
    Account: 'Account',
    Product: 'Product',
    StockMovement: 'StockMovement',
    CashRegister: 'CashRegister',
    Transaction: 'Transaction',
    Invoice: 'Invoice',
    Offer: 'Offer',
    InvoiceItem: 'InvoiceItem',
    PosSession: 'PosSession',
    ServiceTicket: 'ServiceTicket',
    ServicePart: 'ServicePart',
    ServiceHistory: 'ServiceHistory',
    Employee: 'Employee',
    Payroll: 'Payroll',
    LeaveRequest: 'LeaveRequest',
    SystemConfig: 'SystemConfig',
    Module: 'Module',
    PackageModule: 'PackageModule',
    SuperAdminRole: 'SuperAdminRole',
    AuditLog: 'AuditLog',
    LandingContent: 'LandingContent',
    PaymentProvider: 'PaymentProvider',
    BankAccount: 'BankAccount',
    Integration: 'Integration',
    Template: 'Template',
    SupportTicket: 'SupportTicket',
    TicketReply: 'TicketReply'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "subscriptionPackage" | "tenant" | "saaSPayment" | "user" | "account" | "product" | "stockMovement" | "cashRegister" | "transaction" | "invoice" | "offer" | "invoiceItem" | "posSession" | "serviceTicket" | "servicePart" | "serviceHistory" | "employee" | "payroll" | "leaveRequest" | "systemConfig" | "module" | "packageModule" | "superAdminRole" | "auditLog" | "landingContent" | "paymentProvider" | "bankAccount" | "integration" | "template" | "supportTicket" | "ticketReply"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SubscriptionPackage: {
        payload: Prisma.$SubscriptionPackagePayload<ExtArgs>
        fields: Prisma.SubscriptionPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>
          }
          findMany: {
            args: Prisma.SubscriptionPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>[]
          }
          create: {
            args: Prisma.SubscriptionPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>
          }
          createMany: {
            args: Prisma.SubscriptionPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>
          }
          update: {
            args: Prisma.SubscriptionPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPackagePayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPackage>
          }
          groupBy: {
            args: Prisma.SubscriptionPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPackageCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPackageCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      SaaSPayment: {
        payload: Prisma.$SaaSPaymentPayload<ExtArgs>
        fields: Prisma.SaaSPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaaSPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaaSPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>
          }
          findFirst: {
            args: Prisma.SaaSPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaaSPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>
          }
          findMany: {
            args: Prisma.SaaSPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>[]
          }
          create: {
            args: Prisma.SaaSPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>
          }
          createMany: {
            args: Prisma.SaaSPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaaSPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>[]
          }
          delete: {
            args: Prisma.SaaSPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>
          }
          update: {
            args: Prisma.SaaSPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SaaSPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaaSPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaaSPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaaSPaymentPayload>
          }
          aggregate: {
            args: Prisma.SaaSPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaaSPayment>
          }
          groupBy: {
            args: Prisma.SaaSPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaaSPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaaSPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SaaSPaymentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      CashRegister: {
        payload: Prisma.$CashRegisterPayload<ExtArgs>
        fields: Prisma.CashRegisterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashRegisterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashRegisterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          findFirst: {
            args: Prisma.CashRegisterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashRegisterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          findMany: {
            args: Prisma.CashRegisterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          create: {
            args: Prisma.CashRegisterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          createMany: {
            args: Prisma.CashRegisterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashRegisterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          delete: {
            args: Prisma.CashRegisterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          update: {
            args: Prisma.CashRegisterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          deleteMany: {
            args: Prisma.CashRegisterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashRegisterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashRegisterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          aggregate: {
            args: Prisma.CashRegisterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashRegister>
          }
          groupBy: {
            args: Prisma.CashRegisterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashRegisterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashRegisterCountArgs<ExtArgs>
            result: $Utils.Optional<CashRegisterCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      PosSession: {
        payload: Prisma.$PosSessionPayload<ExtArgs>
        fields: Prisma.PosSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>
          }
          findFirst: {
            args: Prisma.PosSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>
          }
          findMany: {
            args: Prisma.PosSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>[]
          }
          create: {
            args: Prisma.PosSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>
          }
          createMany: {
            args: Prisma.PosSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>[]
          }
          delete: {
            args: Prisma.PosSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>
          }
          update: {
            args: Prisma.PosSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>
          }
          deleteMany: {
            args: Prisma.PosSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PosSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosSessionPayload>
          }
          aggregate: {
            args: Prisma.PosSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosSession>
          }
          groupBy: {
            args: Prisma.PosSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosSessionCountArgs<ExtArgs>
            result: $Utils.Optional<PosSessionCountAggregateOutputType> | number
          }
        }
      }
      ServiceTicket: {
        payload: Prisma.$ServiceTicketPayload<ExtArgs>
        fields: Prisma.ServiceTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>
          }
          findFirst: {
            args: Prisma.ServiceTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>
          }
          findMany: {
            args: Prisma.ServiceTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>[]
          }
          create: {
            args: Prisma.ServiceTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>
          }
          createMany: {
            args: Prisma.ServiceTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>[]
          }
          delete: {
            args: Prisma.ServiceTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>
          }
          update: {
            args: Prisma.ServiceTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>
          }
          deleteMany: {
            args: Prisma.ServiceTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTicketPayload>
          }
          aggregate: {
            args: Prisma.ServiceTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceTicket>
          }
          groupBy: {
            args: Prisma.ServiceTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTicketCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceTicketCountAggregateOutputType> | number
          }
        }
      }
      ServicePart: {
        payload: Prisma.$ServicePartPayload<ExtArgs>
        fields: Prisma.ServicePartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>
          }
          findFirst: {
            args: Prisma.ServicePartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>
          }
          findMany: {
            args: Prisma.ServicePartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>[]
          }
          create: {
            args: Prisma.ServicePartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>
          }
          createMany: {
            args: Prisma.ServicePartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>[]
          }
          delete: {
            args: Prisma.ServicePartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>
          }
          update: {
            args: Prisma.ServicePartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>
          }
          deleteMany: {
            args: Prisma.ServicePartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicePartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePartPayload>
          }
          aggregate: {
            args: Prisma.ServicePartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePart>
          }
          groupBy: {
            args: Prisma.ServicePartGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePartGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePartCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePartCountAggregateOutputType> | number
          }
        }
      }
      ServiceHistory: {
        payload: Prisma.$ServiceHistoryPayload<ExtArgs>
        fields: Prisma.ServiceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>
          }
          findFirst: {
            args: Prisma.ServiceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>
          }
          findMany: {
            args: Prisma.ServiceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>[]
          }
          create: {
            args: Prisma.ServiceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>
          }
          createMany: {
            args: Prisma.ServiceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>[]
          }
          delete: {
            args: Prisma.ServiceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>
          }
          update: {
            args: Prisma.ServiceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ServiceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceHistoryPayload>
          }
          aggregate: {
            args: Prisma.ServiceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceHistory>
          }
          groupBy: {
            args: Prisma.ServiceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceHistoryCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      PackageModule: {
        payload: Prisma.$PackageModulePayload<ExtArgs>
        fields: Prisma.PackageModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>
          }
          findFirst: {
            args: Prisma.PackageModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>
          }
          findMany: {
            args: Prisma.PackageModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>[]
          }
          create: {
            args: Prisma.PackageModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>
          }
          createMany: {
            args: Prisma.PackageModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>[]
          }
          delete: {
            args: Prisma.PackageModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>
          }
          update: {
            args: Prisma.PackageModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>
          }
          deleteMany: {
            args: Prisma.PackageModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackageModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageModulePayload>
          }
          aggregate: {
            args: Prisma.PackageModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageModule>
          }
          groupBy: {
            args: Prisma.PackageModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageModuleCountArgs<ExtArgs>
            result: $Utils.Optional<PackageModuleCountAggregateOutputType> | number
          }
        }
      }
      SuperAdminRole: {
        payload: Prisma.$SuperAdminRolePayload<ExtArgs>
        fields: Prisma.SuperAdminRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>
          }
          findFirst: {
            args: Prisma.SuperAdminRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>
          }
          findMany: {
            args: Prisma.SuperAdminRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>[]
          }
          create: {
            args: Prisma.SuperAdminRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>
          }
          createMany: {
            args: Prisma.SuperAdminRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>[]
          }
          delete: {
            args: Prisma.SuperAdminRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>
          }
          update: {
            args: Prisma.SuperAdminRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SuperAdminRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminRolePayload>
          }
          aggregate: {
            args: Prisma.SuperAdminRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdminRole>
          }
          groupBy: {
            args: Prisma.SuperAdminRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminRoleCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminRoleCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      LandingContent: {
        payload: Prisma.$LandingContentPayload<ExtArgs>
        fields: Prisma.LandingContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandingContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandingContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>
          }
          findFirst: {
            args: Prisma.LandingContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandingContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>
          }
          findMany: {
            args: Prisma.LandingContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>[]
          }
          create: {
            args: Prisma.LandingContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>
          }
          createMany: {
            args: Prisma.LandingContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LandingContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>[]
          }
          delete: {
            args: Prisma.LandingContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>
          }
          update: {
            args: Prisma.LandingContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>
          }
          deleteMany: {
            args: Prisma.LandingContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandingContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LandingContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingContentPayload>
          }
          aggregate: {
            args: Prisma.LandingContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandingContent>
          }
          groupBy: {
            args: Prisma.LandingContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandingContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandingContentCountArgs<ExtArgs>
            result: $Utils.Optional<LandingContentCountAggregateOutputType> | number
          }
        }
      }
      PaymentProvider: {
        payload: Prisma.$PaymentProviderPayload<ExtArgs>
        fields: Prisma.PaymentProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>
          }
          findFirst: {
            args: Prisma.PaymentProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>
          }
          findMany: {
            args: Prisma.PaymentProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>[]
          }
          create: {
            args: Prisma.PaymentProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>
          }
          createMany: {
            args: Prisma.PaymentProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>[]
          }
          delete: {
            args: Prisma.PaymentProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>
          }
          update: {
            args: Prisma.PaymentProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>
          }
          deleteMany: {
            args: Prisma.PaymentProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderPayload>
          }
          aggregate: {
            args: Prisma.PaymentProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentProvider>
          }
          groupBy: {
            args: Prisma.PaymentProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentProviderCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentProviderCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      TicketReply: {
        payload: Prisma.$TicketReplyPayload<ExtArgs>
        fields: Prisma.TicketReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>
          }
          findFirst: {
            args: Prisma.TicketReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>
          }
          findMany: {
            args: Prisma.TicketReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>[]
          }
          create: {
            args: Prisma.TicketReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>
          }
          createMany: {
            args: Prisma.TicketReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>[]
          }
          delete: {
            args: Prisma.TicketReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>
          }
          update: {
            args: Prisma.TicketReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>
          }
          deleteMany: {
            args: Prisma.TicketReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketReplyPayload>
          }
          aggregate: {
            args: Prisma.TicketReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketReply>
          }
          groupBy: {
            args: Prisma.TicketReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketReplyCountArgs<ExtArgs>
            result: $Utils.Optional<TicketReplyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SubscriptionPackageCountOutputType
   */

  export type SubscriptionPackageCountOutputType = {
    tenants: number
    modules: number
  }

  export type SubscriptionPackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenants?: boolean | SubscriptionPackageCountOutputTypeCountTenantsArgs
    modules?: boolean | SubscriptionPackageCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionPackageCountOutputType without action
   */
  export type SubscriptionPackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackageCountOutputType
     */
    select?: SubscriptionPackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionPackageCountOutputType without action
   */
  export type SubscriptionPackageCountOutputTypeCountTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }

  /**
   * SubscriptionPackageCountOutputType without action
   */
  export type SubscriptionPackageCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageModuleWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    accounts: number
    products: number
    invoices: number
    offers: number
    stockMovements: number
    transactions: number
    serviceTickets: number
    cashRegisters: number
    employees: number
    payments: number
    integrations: number
    templates: number
    supportTickets: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    accounts?: boolean | TenantCountOutputTypeCountAccountsArgs
    products?: boolean | TenantCountOutputTypeCountProductsArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    offers?: boolean | TenantCountOutputTypeCountOffersArgs
    stockMovements?: boolean | TenantCountOutputTypeCountStockMovementsArgs
    transactions?: boolean | TenantCountOutputTypeCountTransactionsArgs
    serviceTickets?: boolean | TenantCountOutputTypeCountServiceTicketsArgs
    cashRegisters?: boolean | TenantCountOutputTypeCountCashRegistersArgs
    employees?: boolean | TenantCountOutputTypeCountEmployeesArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
    integrations?: boolean | TenantCountOutputTypeCountIntegrationsArgs
    templates?: boolean | TenantCountOutputTypeCountTemplatesArgs
    supportTickets?: boolean | TenantCountOutputTypeCountSupportTicketsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountServiceTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTicketWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaaSPaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    invoices: number
    offers: number
    transactions: number
    serviceTickets: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | AccountCountOutputTypeCountInvoicesArgs
    offers?: boolean | AccountCountOutputTypeCountOffersArgs
    transactions?: boolean | AccountCountOutputTypeCountTransactionsArgs
    serviceTickets?: boolean | AccountCountOutputTypeCountServiceTicketsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountServiceTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTicketWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    stockMovements: number
    invoiceItems: number
    serviceParts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockMovements?: boolean | ProductCountOutputTypeCountStockMovementsArgs
    invoiceItems?: boolean | ProductCountOutputTypeCountInvoiceItemsArgs
    serviceParts?: boolean | ProductCountOutputTypeCountServicePartsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountServicePartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePartWhereInput
  }


  /**
   * Count Type CashRegisterCountOutputType
   */

  export type CashRegisterCountOutputType = {
    transactions: number
    posSessions: number
  }

  export type CashRegisterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CashRegisterCountOutputTypeCountTransactionsArgs
    posSessions?: boolean | CashRegisterCountOutputTypeCountPosSessionsArgs
  }

  // Custom InputTypes
  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegisterCountOutputType
     */
    select?: CashRegisterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeCountPosSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosSessionWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    transactions: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    transactions?: boolean | InvoiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    items: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OfferCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type ServiceTicketCountOutputType
   */

  export type ServiceTicketCountOutputType = {
    parts: number
    history: number
  }

  export type ServiceTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parts?: boolean | ServiceTicketCountOutputTypeCountPartsArgs
    history?: boolean | ServiceTicketCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * ServiceTicketCountOutputType without action
   */
  export type ServiceTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicketCountOutputType
     */
    select?: ServiceTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceTicketCountOutputType without action
   */
  export type ServiceTicketCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePartWhereInput
  }

  /**
   * ServiceTicketCountOutputType without action
   */
  export type ServiceTicketCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceHistoryWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    tickets: number
    posSessions: number
    payrolls: number
    leaves: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | EmployeeCountOutputTypeCountTicketsArgs
    posSessions?: boolean | EmployeeCountOutputTypeCountPosSessionsArgs
    payrolls?: boolean | EmployeeCountOutputTypeCountPayrollsArgs
    leaves?: boolean | EmployeeCountOutputTypeCountLeavesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTicketWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPosSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosSessionWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    packages: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    packages?: boolean | ModuleCountOutputTypeCountPackagesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageModuleWhereInput
  }


  /**
   * Count Type SuperAdminRoleCountOutputType
   */

  export type SuperAdminRoleCountOutputType = {
    users: number
  }

  export type SuperAdminRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SuperAdminRoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminRoleCountOutputType without action
   */
  export type SuperAdminRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRoleCountOutputType
     */
    select?: SuperAdminRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminRoleCountOutputType without action
   */
  export type SuperAdminRoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    replies: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | SupportTicketCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketReplyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SubscriptionPackage
   */

  export type AggregateSubscriptionPackage = {
    _count: SubscriptionPackageCountAggregateOutputType | null
    _avg: SubscriptionPackageAvgAggregateOutputType | null
    _sum: SubscriptionPackageSumAggregateOutputType | null
    _min: SubscriptionPackageMinAggregateOutputType | null
    _max: SubscriptionPackageMaxAggregateOutputType | null
  }

  export type SubscriptionPackageAvgAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    maxUsers: number | null
    maxProducts: number | null
    sortOrder: number | null
    demoDuration: number | null
    discountPercentage: Decimal | null
  }

  export type SubscriptionPackageSumAggregateOutputType = {
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    maxUsers: number | null
    maxProducts: number | null
    sortOrder: number | null
    demoDuration: number | null
    discountPercentage: Decimal | null
  }

  export type SubscriptionPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    maxUsers: number | null
    maxProducts: number | null
    storageLimit: string | null
    isPopular: boolean | null
    isActive: boolean | null
    sortOrder: number | null
    isDemo: boolean | null
    demoDuration: number | null
    discountPercentage: Decimal | null
    discountEndDate: Date | null
    highlightColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonthly: Decimal | null
    priceYearly: Decimal | null
    maxUsers: number | null
    maxProducts: number | null
    storageLimit: string | null
    isPopular: boolean | null
    isActive: boolean | null
    sortOrder: number | null
    isDemo: boolean | null
    demoDuration: number | null
    discountPercentage: Decimal | null
    discountEndDate: Date | null
    highlightColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPackageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    priceMonthly: number
    priceYearly: number
    maxUsers: number
    maxProducts: number
    storageLimit: number
    features: number
    isPopular: number
    isActive: number
    sortOrder: number
    isDemo: number
    demoDuration: number
    discountPercentage: number
    discountEndDate: number
    highlightColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPackageAvgAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    maxUsers?: true
    maxProducts?: true
    sortOrder?: true
    demoDuration?: true
    discountPercentage?: true
  }

  export type SubscriptionPackageSumAggregateInputType = {
    priceMonthly?: true
    priceYearly?: true
    maxUsers?: true
    maxProducts?: true
    sortOrder?: true
    demoDuration?: true
    discountPercentage?: true
  }

  export type SubscriptionPackageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    maxUsers?: true
    maxProducts?: true
    storageLimit?: true
    isPopular?: true
    isActive?: true
    sortOrder?: true
    isDemo?: true
    demoDuration?: true
    discountPercentage?: true
    discountEndDate?: true
    highlightColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPackageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    maxUsers?: true
    maxProducts?: true
    storageLimit?: true
    isPopular?: true
    isActive?: true
    sortOrder?: true
    isDemo?: true
    demoDuration?: true
    discountPercentage?: true
    discountEndDate?: true
    highlightColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPackageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonthly?: true
    priceYearly?: true
    maxUsers?: true
    maxProducts?: true
    storageLimit?: true
    features?: true
    isPopular?: true
    isActive?: true
    sortOrder?: true
    isDemo?: true
    demoDuration?: true
    discountPercentage?: true
    discountEndDate?: true
    highlightColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPackage to aggregate.
     */
    where?: SubscriptionPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPackages to fetch.
     */
    orderBy?: SubscriptionPackageOrderByWithRelationInput | SubscriptionPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPackages
    **/
    _count?: true | SubscriptionPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPackageMaxAggregateInputType
  }

  export type GetSubscriptionPackageAggregateType<T extends SubscriptionPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPackage[P]>
      : GetScalarType<T[P], AggregateSubscriptionPackage[P]>
  }




  export type SubscriptionPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPackageWhereInput
    orderBy?: SubscriptionPackageOrderByWithAggregationInput | SubscriptionPackageOrderByWithAggregationInput[]
    by: SubscriptionPackageScalarFieldEnum[] | SubscriptionPackageScalarFieldEnum
    having?: SubscriptionPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPackageCountAggregateInputType | true
    _avg?: SubscriptionPackageAvgAggregateInputType
    _sum?: SubscriptionPackageSumAggregateInputType
    _min?: SubscriptionPackageMinAggregateInputType
    _max?: SubscriptionPackageMaxAggregateInputType
  }

  export type SubscriptionPackageGroupByOutputType = {
    id: string
    name: string
    description: string | null
    priceMonthly: Decimal
    priceYearly: Decimal
    maxUsers: number
    maxProducts: number
    storageLimit: string
    features: JsonValue | null
    isPopular: boolean
    isActive: boolean
    sortOrder: number
    isDemo: boolean
    demoDuration: number
    discountPercentage: Decimal
    discountEndDate: Date | null
    highlightColor: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPackageCountAggregateOutputType | null
    _avg: SubscriptionPackageAvgAggregateOutputType | null
    _sum: SubscriptionPackageSumAggregateOutputType | null
    _min: SubscriptionPackageMinAggregateOutputType | null
    _max: SubscriptionPackageMaxAggregateOutputType | null
  }

  type GetSubscriptionPackageGroupByPayload<T extends SubscriptionPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPackageGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPackageGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    maxUsers?: boolean
    maxProducts?: boolean
    storageLimit?: boolean
    features?: boolean
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: boolean
    isDemo?: boolean
    demoDuration?: boolean
    discountPercentage?: boolean
    discountEndDate?: boolean
    highlightColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenants?: boolean | SubscriptionPackage$tenantsArgs<ExtArgs>
    modules?: boolean | SubscriptionPackage$modulesArgs<ExtArgs>
    _count?: boolean | SubscriptionPackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPackage"]>

  export type SubscriptionPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    maxUsers?: boolean
    maxProducts?: boolean
    storageLimit?: boolean
    features?: boolean
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: boolean
    isDemo?: boolean
    demoDuration?: boolean
    discountPercentage?: boolean
    discountEndDate?: boolean
    highlightColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscriptionPackage"]>

  export type SubscriptionPackageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonthly?: boolean
    priceYearly?: boolean
    maxUsers?: boolean
    maxProducts?: boolean
    storageLimit?: boolean
    features?: boolean
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: boolean
    isDemo?: boolean
    demoDuration?: boolean
    discountPercentage?: boolean
    discountEndDate?: boolean
    highlightColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenants?: boolean | SubscriptionPackage$tenantsArgs<ExtArgs>
    modules?: boolean | SubscriptionPackage$modulesArgs<ExtArgs>
    _count?: boolean | SubscriptionPackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionPackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPackage"
    objects: {
      tenants: Prisma.$TenantPayload<ExtArgs>[]
      modules: Prisma.$PackageModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      priceMonthly: Prisma.Decimal
      priceYearly: Prisma.Decimal
      maxUsers: number
      maxProducts: number
      storageLimit: string
      features: Prisma.JsonValue | null
      isPopular: boolean
      isActive: boolean
      sortOrder: number
      isDemo: boolean
      demoDuration: number
      discountPercentage: Prisma.Decimal
      discountEndDate: Date | null
      highlightColor: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPackage"]>
    composites: {}
  }

  type SubscriptionPackageGetPayload<S extends boolean | null | undefined | SubscriptionPackageDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPackagePayload, S>

  type SubscriptionPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionPackageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionPackageCountAggregateInputType | true
    }

  export interface SubscriptionPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPackage'], meta: { name: 'SubscriptionPackage' } }
    /**
     * Find zero or one SubscriptionPackage that matches the filter.
     * @param {SubscriptionPackageFindUniqueArgs} args - Arguments to find a SubscriptionPackage
     * @example
     * // Get one SubscriptionPackage
     * const subscriptionPackage = await prisma.subscriptionPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPackageFindUniqueArgs>(args: SelectSubset<T, SubscriptionPackageFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionPackage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionPackageFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPackage
     * @example
     * // Get one SubscriptionPackage
     * const subscriptionPackage = await prisma.subscriptionPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPackageFindFirstArgs} args - Arguments to find a SubscriptionPackage
     * @example
     * // Get one SubscriptionPackage
     * const subscriptionPackage = await prisma.subscriptionPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPackageFindFirstArgs>(args?: SelectSubset<T, SubscriptionPackageFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPackageFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPackage
     * @example
     * // Get one SubscriptionPackage
     * const subscriptionPackage = await prisma.subscriptionPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPackages
     * const subscriptionPackages = await prisma.subscriptionPackage.findMany()
     * 
     * // Get first 10 SubscriptionPackages
     * const subscriptionPackages = await prisma.subscriptionPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPackageWithIdOnly = await prisma.subscriptionPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPackageFindManyArgs>(args?: SelectSubset<T, SubscriptionPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionPackage.
     * @param {SubscriptionPackageCreateArgs} args - Arguments to create a SubscriptionPackage.
     * @example
     * // Create one SubscriptionPackage
     * const SubscriptionPackage = await prisma.subscriptionPackage.create({
     *   data: {
     *     // ... data to create a SubscriptionPackage
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPackageCreateArgs>(args: SelectSubset<T, SubscriptionPackageCreateArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionPackages.
     * @param {SubscriptionPackageCreateManyArgs} args - Arguments to create many SubscriptionPackages.
     * @example
     * // Create many SubscriptionPackages
     * const subscriptionPackage = await prisma.subscriptionPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPackageCreateManyArgs>(args?: SelectSubset<T, SubscriptionPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPackages and returns the data saved in the database.
     * @param {SubscriptionPackageCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPackages.
     * @example
     * // Create many SubscriptionPackages
     * const subscriptionPackage = await prisma.subscriptionPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPackages and only return the `id`
     * const subscriptionPackageWithIdOnly = await prisma.subscriptionPackage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionPackage.
     * @param {SubscriptionPackageDeleteArgs} args - Arguments to delete one SubscriptionPackage.
     * @example
     * // Delete one SubscriptionPackage
     * const SubscriptionPackage = await prisma.subscriptionPackage.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPackage
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPackageDeleteArgs>(args: SelectSubset<T, SubscriptionPackageDeleteArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionPackage.
     * @param {SubscriptionPackageUpdateArgs} args - Arguments to update one SubscriptionPackage.
     * @example
     * // Update one SubscriptionPackage
     * const subscriptionPackage = await prisma.subscriptionPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPackageUpdateArgs>(args: SelectSubset<T, SubscriptionPackageUpdateArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionPackages.
     * @param {SubscriptionPackageDeleteManyArgs} args - Arguments to filter SubscriptionPackages to delete.
     * @example
     * // Delete a few SubscriptionPackages
     * const { count } = await prisma.subscriptionPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPackageDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPackages
     * const subscriptionPackage = await prisma.subscriptionPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPackageUpdateManyArgs>(args: SelectSubset<T, SubscriptionPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionPackage.
     * @param {SubscriptionPackageUpsertArgs} args - Arguments to update or create a SubscriptionPackage.
     * @example
     * // Update or create a SubscriptionPackage
     * const subscriptionPackage = await prisma.subscriptionPackage.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPackage we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPackageUpsertArgs>(args: SelectSubset<T, SubscriptionPackageUpsertArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPackageCountArgs} args - Arguments to filter SubscriptionPackages to count.
     * @example
     * // Count the number of SubscriptionPackages
     * const count = await prisma.subscriptionPackage.count({
     *   where: {
     *     // ... the filter for the SubscriptionPackages we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPackageCountArgs>(
      args?: Subset<T, SubscriptionPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPackageAggregateArgs>(args: Subset<T, SubscriptionPackageAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPackageAggregateType<T>>

    /**
     * Group by SubscriptionPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPackageGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPackage model
   */
  readonly fields: SubscriptionPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenants<T extends SubscriptionPackage$tenantsArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPackage$tenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany"> | Null>
    modules<T extends SubscriptionPackage$modulesArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPackage$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPackage model
   */ 
  interface SubscriptionPackageFieldRefs {
    readonly id: FieldRef<"SubscriptionPackage", 'String'>
    readonly name: FieldRef<"SubscriptionPackage", 'String'>
    readonly description: FieldRef<"SubscriptionPackage", 'String'>
    readonly priceMonthly: FieldRef<"SubscriptionPackage", 'Decimal'>
    readonly priceYearly: FieldRef<"SubscriptionPackage", 'Decimal'>
    readonly maxUsers: FieldRef<"SubscriptionPackage", 'Int'>
    readonly maxProducts: FieldRef<"SubscriptionPackage", 'Int'>
    readonly storageLimit: FieldRef<"SubscriptionPackage", 'String'>
    readonly features: FieldRef<"SubscriptionPackage", 'Json'>
    readonly isPopular: FieldRef<"SubscriptionPackage", 'Boolean'>
    readonly isActive: FieldRef<"SubscriptionPackage", 'Boolean'>
    readonly sortOrder: FieldRef<"SubscriptionPackage", 'Int'>
    readonly isDemo: FieldRef<"SubscriptionPackage", 'Boolean'>
    readonly demoDuration: FieldRef<"SubscriptionPackage", 'Int'>
    readonly discountPercentage: FieldRef<"SubscriptionPackage", 'Decimal'>
    readonly discountEndDate: FieldRef<"SubscriptionPackage", 'DateTime'>
    readonly highlightColor: FieldRef<"SubscriptionPackage", 'String'>
    readonly createdAt: FieldRef<"SubscriptionPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPackage findUnique
   */
  export type SubscriptionPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPackage to fetch.
     */
    where: SubscriptionPackageWhereUniqueInput
  }

  /**
   * SubscriptionPackage findUniqueOrThrow
   */
  export type SubscriptionPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPackage to fetch.
     */
    where: SubscriptionPackageWhereUniqueInput
  }

  /**
   * SubscriptionPackage findFirst
   */
  export type SubscriptionPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPackage to fetch.
     */
    where?: SubscriptionPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPackages to fetch.
     */
    orderBy?: SubscriptionPackageOrderByWithRelationInput | SubscriptionPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPackages.
     */
    cursor?: SubscriptionPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPackages.
     */
    distinct?: SubscriptionPackageScalarFieldEnum | SubscriptionPackageScalarFieldEnum[]
  }

  /**
   * SubscriptionPackage findFirstOrThrow
   */
  export type SubscriptionPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPackage to fetch.
     */
    where?: SubscriptionPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPackages to fetch.
     */
    orderBy?: SubscriptionPackageOrderByWithRelationInput | SubscriptionPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPackages.
     */
    cursor?: SubscriptionPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPackages.
     */
    distinct?: SubscriptionPackageScalarFieldEnum | SubscriptionPackageScalarFieldEnum[]
  }

  /**
   * SubscriptionPackage findMany
   */
  export type SubscriptionPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPackages to fetch.
     */
    where?: SubscriptionPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPackages to fetch.
     */
    orderBy?: SubscriptionPackageOrderByWithRelationInput | SubscriptionPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPackages.
     */
    cursor?: SubscriptionPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPackages.
     */
    skip?: number
    distinct?: SubscriptionPackageScalarFieldEnum | SubscriptionPackageScalarFieldEnum[]
  }

  /**
   * SubscriptionPackage create
   */
  export type SubscriptionPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPackage.
     */
    data: XOR<SubscriptionPackageCreateInput, SubscriptionPackageUncheckedCreateInput>
  }

  /**
   * SubscriptionPackage createMany
   */
  export type SubscriptionPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPackages.
     */
    data: SubscriptionPackageCreateManyInput | SubscriptionPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPackage createManyAndReturn
   */
  export type SubscriptionPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPackages.
     */
    data: SubscriptionPackageCreateManyInput | SubscriptionPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPackage update
   */
  export type SubscriptionPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPackage.
     */
    data: XOR<SubscriptionPackageUpdateInput, SubscriptionPackageUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPackage to update.
     */
    where: SubscriptionPackageWhereUniqueInput
  }

  /**
   * SubscriptionPackage updateMany
   */
  export type SubscriptionPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPackages.
     */
    data: XOR<SubscriptionPackageUpdateManyMutationInput, SubscriptionPackageUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPackages to update
     */
    where?: SubscriptionPackageWhereInput
  }

  /**
   * SubscriptionPackage upsert
   */
  export type SubscriptionPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPackage to update in case it exists.
     */
    where: SubscriptionPackageWhereUniqueInput
    /**
     * In case the SubscriptionPackage found by the `where` argument doesn't exist, create a new SubscriptionPackage with this data.
     */
    create: XOR<SubscriptionPackageCreateInput, SubscriptionPackageUncheckedCreateInput>
    /**
     * In case the SubscriptionPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPackageUpdateInput, SubscriptionPackageUncheckedUpdateInput>
  }

  /**
   * SubscriptionPackage delete
   */
  export type SubscriptionPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPackage to delete.
     */
    where: SubscriptionPackageWhereUniqueInput
  }

  /**
   * SubscriptionPackage deleteMany
   */
  export type SubscriptionPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPackages to delete
     */
    where?: SubscriptionPackageWhereInput
  }

  /**
   * SubscriptionPackage.tenants
   */
  export type SubscriptionPackage$tenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * SubscriptionPackage.modules
   */
  export type SubscriptionPackage$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    where?: PackageModuleWhereInput
    orderBy?: PackageModuleOrderByWithRelationInput | PackageModuleOrderByWithRelationInput[]
    cursor?: PackageModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageModuleScalarFieldEnum | PackageModuleScalarFieldEnum[]
  }

  /**
   * SubscriptionPackage without action
   */
  export type SubscriptionPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    tag: string | null
    name: string | null
    type: $Enums.TenantType | null
    taxNumber: string | null
    taxOffice: string | null
    contactEmail: string | null
    contactPhone: string | null
    subscriptionPlanId: string | null
    status: $Enums.TenantStatus | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    name: string | null
    type: $Enums.TenantType | null
    taxNumber: string | null
    taxOffice: string | null
    contactEmail: string | null
    contactPhone: string | null
    subscriptionPlanId: string | null
    status: $Enums.TenantStatus | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    tag: number
    name: number
    type: number
    taxNumber: number
    taxOffice: number
    contactEmail: number
    contactPhone: number
    address: number
    subscriptionPlanId: number
    status: number
    subscriptionStart: number
    subscriptionEnd: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    tag?: true
    name?: true
    type?: true
    taxNumber?: true
    taxOffice?: true
    contactEmail?: true
    contactPhone?: true
    subscriptionPlanId?: true
    status?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    tag?: true
    name?: true
    type?: true
    taxNumber?: true
    taxOffice?: true
    contactEmail?: true
    contactPhone?: true
    subscriptionPlanId?: true
    status?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    tag?: true
    name?: true
    type?: true
    taxNumber?: true
    taxOffice?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    subscriptionPlanId?: true
    status?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    tag: string
    name: string
    type: $Enums.TenantType
    taxNumber: string | null
    taxOffice: string | null
    contactEmail: string | null
    contactPhone: string | null
    address: JsonValue | null
    subscriptionPlanId: string | null
    status: $Enums.TenantStatus
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    config: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    name?: boolean
    type?: boolean
    taxNumber?: boolean
    taxOffice?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    subscriptionPlanId?: boolean
    status?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionPackage?: boolean | Tenant$subscriptionPackageArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    accounts?: boolean | Tenant$accountsArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    offers?: boolean | Tenant$offersArgs<ExtArgs>
    stockMovements?: boolean | Tenant$stockMovementsArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    serviceTickets?: boolean | Tenant$serviceTicketsArgs<ExtArgs>
    cashRegisters?: boolean | Tenant$cashRegistersArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    integrations?: boolean | Tenant$integrationsArgs<ExtArgs>
    templates?: boolean | Tenant$templatesArgs<ExtArgs>
    supportTickets?: boolean | Tenant$supportTicketsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    name?: boolean
    type?: boolean
    taxNumber?: boolean
    taxOffice?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    subscriptionPlanId?: boolean
    status?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptionPackage?: boolean | Tenant$subscriptionPackageArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    tag?: boolean
    name?: boolean
    type?: boolean
    taxNumber?: boolean
    taxOffice?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    subscriptionPlanId?: boolean
    status?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptionPackage?: boolean | Tenant$subscriptionPackageArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    accounts?: boolean | Tenant$accountsArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    offers?: boolean | Tenant$offersArgs<ExtArgs>
    stockMovements?: boolean | Tenant$stockMovementsArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    serviceTickets?: boolean | Tenant$serviceTicketsArgs<ExtArgs>
    cashRegisters?: boolean | Tenant$cashRegistersArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    integrations?: boolean | Tenant$integrationsArgs<ExtArgs>
    templates?: boolean | Tenant$templatesArgs<ExtArgs>
    supportTickets?: boolean | Tenant$supportTicketsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptionPackage?: boolean | Tenant$subscriptionPackageArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      subscriptionPackage: Prisma.$SubscriptionPackagePayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      serviceTickets: Prisma.$ServiceTicketPayload<ExtArgs>[]
      cashRegisters: Prisma.$CashRegisterPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      payments: Prisma.$SaaSPaymentPayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      templates: Prisma.$TemplatePayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      name: string
      type: $Enums.TenantType
      taxNumber: string | null
      taxOffice: string | null
      contactEmail: string | null
      contactPhone: string | null
      address: Prisma.JsonValue | null
      subscriptionPlanId: string | null
      status: $Enums.TenantStatus
      subscriptionStart: Date | null
      subscriptionEnd: Date | null
      config: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptionPackage<T extends Tenant$subscriptionPackageArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$subscriptionPackageArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends Tenant$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Tenant$productsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    offers<T extends Tenant$offersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends Tenant$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Tenant$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    serviceTickets<T extends Tenant$serviceTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$serviceTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findMany"> | Null>
    cashRegisters<T extends Tenant$cashRegistersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cashRegistersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany"> | Null>
    employees<T extends Tenant$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    integrations<T extends Tenant$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    templates<T extends Tenant$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany"> | Null>
    supportTickets<T extends Tenant$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly tag: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly type: FieldRef<"Tenant", 'TenantType'>
    readonly taxNumber: FieldRef<"Tenant", 'String'>
    readonly taxOffice: FieldRef<"Tenant", 'String'>
    readonly contactEmail: FieldRef<"Tenant", 'String'>
    readonly contactPhone: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'Json'>
    readonly subscriptionPlanId: FieldRef<"Tenant", 'String'>
    readonly status: FieldRef<"Tenant", 'TenantStatus'>
    readonly subscriptionStart: FieldRef<"Tenant", 'DateTime'>
    readonly subscriptionEnd: FieldRef<"Tenant", 'DateTime'>
    readonly config: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.subscriptionPackage
   */
  export type Tenant$subscriptionPackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPackage
     */
    select?: SubscriptionPackageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPackageInclude<ExtArgs> | null
    where?: SubscriptionPackageWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.accounts
   */
  export type Tenant$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Tenant.products
   */
  export type Tenant$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.offers
   */
  export type Tenant$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Tenant.stockMovements
   */
  export type Tenant$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Tenant.transactions
   */
  export type Tenant$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Tenant.serviceTickets
   */
  export type Tenant$serviceTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    where?: ServiceTicketWhereInput
    orderBy?: ServiceTicketOrderByWithRelationInput | ServiceTicketOrderByWithRelationInput[]
    cursor?: ServiceTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTicketScalarFieldEnum | ServiceTicketScalarFieldEnum[]
  }

  /**
   * Tenant.cashRegisters
   */
  export type Tenant$cashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    cursor?: CashRegisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * Tenant.employees
   */
  export type Tenant$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    where?: SaaSPaymentWhereInput
    orderBy?: SaaSPaymentOrderByWithRelationInput | SaaSPaymentOrderByWithRelationInput[]
    cursor?: SaaSPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaaSPaymentScalarFieldEnum | SaaSPaymentScalarFieldEnum[]
  }

  /**
   * Tenant.integrations
   */
  export type Tenant$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Tenant.templates
   */
  export type Tenant$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Tenant.supportTickets
   */
  export type Tenant$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model SaaSPayment
   */

  export type AggregateSaaSPayment = {
    _count: SaaSPaymentCountAggregateOutputType | null
    _avg: SaaSPaymentAvgAggregateOutputType | null
    _sum: SaaSPaymentSumAggregateOutputType | null
    _min: SaaSPaymentMinAggregateOutputType | null
    _max: SaaSPaymentMaxAggregateOutputType | null
  }

  export type SaaSPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SaaSPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SaaSPaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    amount: Decimal | null
    date: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaaSPaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    amount: Decimal | null
    date: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaaSPaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    amount: number
    date: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaaSPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type SaaSPaymentSumAggregateInputType = {
    amount?: true
  }

  export type SaaSPaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    amount?: true
    date?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaaSPaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    amount?: true
    date?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaaSPaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    amount?: true
    date?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaaSPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaaSPayment to aggregate.
     */
    where?: SaaSPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaaSPayments to fetch.
     */
    orderBy?: SaaSPaymentOrderByWithRelationInput | SaaSPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaaSPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaaSPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaaSPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaaSPayments
    **/
    _count?: true | SaaSPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaaSPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaaSPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaaSPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaaSPaymentMaxAggregateInputType
  }

  export type GetSaaSPaymentAggregateType<T extends SaaSPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSaaSPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaaSPayment[P]>
      : GetScalarType<T[P], AggregateSaaSPayment[P]>
  }




  export type SaaSPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaaSPaymentWhereInput
    orderBy?: SaaSPaymentOrderByWithAggregationInput | SaaSPaymentOrderByWithAggregationInput[]
    by: SaaSPaymentScalarFieldEnum[] | SaaSPaymentScalarFieldEnum
    having?: SaaSPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaaSPaymentCountAggregateInputType | true
    _avg?: SaaSPaymentAvgAggregateInputType
    _sum?: SaaSPaymentSumAggregateInputType
    _min?: SaaSPaymentMinAggregateInputType
    _max?: SaaSPaymentMaxAggregateInputType
  }

  export type SaaSPaymentGroupByOutputType = {
    id: string
    tenantId: string
    amount: Decimal
    date: Date
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SaaSPaymentCountAggregateOutputType | null
    _avg: SaaSPaymentAvgAggregateOutputType | null
    _sum: SaaSPaymentSumAggregateOutputType | null
    _min: SaaSPaymentMinAggregateOutputType | null
    _max: SaaSPaymentMaxAggregateOutputType | null
  }

  type GetSaaSPaymentGroupByPayload<T extends SaaSPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaaSPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaaSPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaaSPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SaaSPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SaaSPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saaSPayment"]>

  export type SaaSPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saaSPayment"]>

  export type SaaSPaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaaSPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SaaSPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SaaSPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaaSPayment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      amount: Prisma.Decimal
      date: Date
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saaSPayment"]>
    composites: {}
  }

  type SaaSPaymentGetPayload<S extends boolean | null | undefined | SaaSPaymentDefaultArgs> = $Result.GetResult<Prisma.$SaaSPaymentPayload, S>

  type SaaSPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaaSPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaaSPaymentCountAggregateInputType | true
    }

  export interface SaaSPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaaSPayment'], meta: { name: 'SaaSPayment' } }
    /**
     * Find zero or one SaaSPayment that matches the filter.
     * @param {SaaSPaymentFindUniqueArgs} args - Arguments to find a SaaSPayment
     * @example
     * // Get one SaaSPayment
     * const saaSPayment = await prisma.saaSPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaaSPaymentFindUniqueArgs>(args: SelectSubset<T, SaaSPaymentFindUniqueArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaaSPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaaSPaymentFindUniqueOrThrowArgs} args - Arguments to find a SaaSPayment
     * @example
     * // Get one SaaSPayment
     * const saaSPayment = await prisma.saaSPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaaSPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SaaSPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaaSPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaaSPaymentFindFirstArgs} args - Arguments to find a SaaSPayment
     * @example
     * // Get one SaaSPayment
     * const saaSPayment = await prisma.saaSPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaaSPaymentFindFirstArgs>(args?: SelectSubset<T, SaaSPaymentFindFirstArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaaSPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaaSPaymentFindFirstOrThrowArgs} args - Arguments to find a SaaSPayment
     * @example
     * // Get one SaaSPayment
     * const saaSPayment = await prisma.saaSPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaaSPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SaaSPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaaSPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaaSPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaaSPayments
     * const saaSPayments = await prisma.saaSPayment.findMany()
     * 
     * // Get first 10 SaaSPayments
     * const saaSPayments = await prisma.saaSPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saaSPaymentWithIdOnly = await prisma.saaSPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaaSPaymentFindManyArgs>(args?: SelectSubset<T, SaaSPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaaSPayment.
     * @param {SaaSPaymentCreateArgs} args - Arguments to create a SaaSPayment.
     * @example
     * // Create one SaaSPayment
     * const SaaSPayment = await prisma.saaSPayment.create({
     *   data: {
     *     // ... data to create a SaaSPayment
     *   }
     * })
     * 
     */
    create<T extends SaaSPaymentCreateArgs>(args: SelectSubset<T, SaaSPaymentCreateArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaaSPayments.
     * @param {SaaSPaymentCreateManyArgs} args - Arguments to create many SaaSPayments.
     * @example
     * // Create many SaaSPayments
     * const saaSPayment = await prisma.saaSPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaaSPaymentCreateManyArgs>(args?: SelectSubset<T, SaaSPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaaSPayments and returns the data saved in the database.
     * @param {SaaSPaymentCreateManyAndReturnArgs} args - Arguments to create many SaaSPayments.
     * @example
     * // Create many SaaSPayments
     * const saaSPayment = await prisma.saaSPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaaSPayments and only return the `id`
     * const saaSPaymentWithIdOnly = await prisma.saaSPayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaaSPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SaaSPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaaSPayment.
     * @param {SaaSPaymentDeleteArgs} args - Arguments to delete one SaaSPayment.
     * @example
     * // Delete one SaaSPayment
     * const SaaSPayment = await prisma.saaSPayment.delete({
     *   where: {
     *     // ... filter to delete one SaaSPayment
     *   }
     * })
     * 
     */
    delete<T extends SaaSPaymentDeleteArgs>(args: SelectSubset<T, SaaSPaymentDeleteArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaaSPayment.
     * @param {SaaSPaymentUpdateArgs} args - Arguments to update one SaaSPayment.
     * @example
     * // Update one SaaSPayment
     * const saaSPayment = await prisma.saaSPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaaSPaymentUpdateArgs>(args: SelectSubset<T, SaaSPaymentUpdateArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaaSPayments.
     * @param {SaaSPaymentDeleteManyArgs} args - Arguments to filter SaaSPayments to delete.
     * @example
     * // Delete a few SaaSPayments
     * const { count } = await prisma.saaSPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaaSPaymentDeleteManyArgs>(args?: SelectSubset<T, SaaSPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaaSPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaaSPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaaSPayments
     * const saaSPayment = await prisma.saaSPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaaSPaymentUpdateManyArgs>(args: SelectSubset<T, SaaSPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaaSPayment.
     * @param {SaaSPaymentUpsertArgs} args - Arguments to update or create a SaaSPayment.
     * @example
     * // Update or create a SaaSPayment
     * const saaSPayment = await prisma.saaSPayment.upsert({
     *   create: {
     *     // ... data to create a SaaSPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaaSPayment we want to update
     *   }
     * })
     */
    upsert<T extends SaaSPaymentUpsertArgs>(args: SelectSubset<T, SaaSPaymentUpsertArgs<ExtArgs>>): Prisma__SaaSPaymentClient<$Result.GetResult<Prisma.$SaaSPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaaSPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaaSPaymentCountArgs} args - Arguments to filter SaaSPayments to count.
     * @example
     * // Count the number of SaaSPayments
     * const count = await prisma.saaSPayment.count({
     *   where: {
     *     // ... the filter for the SaaSPayments we want to count
     *   }
     * })
    **/
    count<T extends SaaSPaymentCountArgs>(
      args?: Subset<T, SaaSPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaaSPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaaSPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaaSPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaaSPaymentAggregateArgs>(args: Subset<T, SaaSPaymentAggregateArgs>): Prisma.PrismaPromise<GetSaaSPaymentAggregateType<T>>

    /**
     * Group by SaaSPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaaSPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaaSPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaaSPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SaaSPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaaSPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaaSPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaaSPayment model
   */
  readonly fields: SaaSPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaaSPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaaSPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaaSPayment model
   */ 
  interface SaaSPaymentFieldRefs {
    readonly id: FieldRef<"SaaSPayment", 'String'>
    readonly tenantId: FieldRef<"SaaSPayment", 'String'>
    readonly amount: FieldRef<"SaaSPayment", 'Decimal'>
    readonly date: FieldRef<"SaaSPayment", 'DateTime'>
    readonly description: FieldRef<"SaaSPayment", 'String'>
    readonly status: FieldRef<"SaaSPayment", 'String'>
    readonly createdAt: FieldRef<"SaaSPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"SaaSPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaaSPayment findUnique
   */
  export type SaaSPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaaSPayment to fetch.
     */
    where: SaaSPaymentWhereUniqueInput
  }

  /**
   * SaaSPayment findUniqueOrThrow
   */
  export type SaaSPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaaSPayment to fetch.
     */
    where: SaaSPaymentWhereUniqueInput
  }

  /**
   * SaaSPayment findFirst
   */
  export type SaaSPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaaSPayment to fetch.
     */
    where?: SaaSPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaaSPayments to fetch.
     */
    orderBy?: SaaSPaymentOrderByWithRelationInput | SaaSPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaaSPayments.
     */
    cursor?: SaaSPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaaSPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaaSPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaaSPayments.
     */
    distinct?: SaaSPaymentScalarFieldEnum | SaaSPaymentScalarFieldEnum[]
  }

  /**
   * SaaSPayment findFirstOrThrow
   */
  export type SaaSPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaaSPayment to fetch.
     */
    where?: SaaSPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaaSPayments to fetch.
     */
    orderBy?: SaaSPaymentOrderByWithRelationInput | SaaSPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaaSPayments.
     */
    cursor?: SaaSPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaaSPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaaSPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaaSPayments.
     */
    distinct?: SaaSPaymentScalarFieldEnum | SaaSPaymentScalarFieldEnum[]
  }

  /**
   * SaaSPayment findMany
   */
  export type SaaSPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaaSPayments to fetch.
     */
    where?: SaaSPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaaSPayments to fetch.
     */
    orderBy?: SaaSPaymentOrderByWithRelationInput | SaaSPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaaSPayments.
     */
    cursor?: SaaSPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaaSPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaaSPayments.
     */
    skip?: number
    distinct?: SaaSPaymentScalarFieldEnum | SaaSPaymentScalarFieldEnum[]
  }

  /**
   * SaaSPayment create
   */
  export type SaaSPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SaaSPayment.
     */
    data: XOR<SaaSPaymentCreateInput, SaaSPaymentUncheckedCreateInput>
  }

  /**
   * SaaSPayment createMany
   */
  export type SaaSPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaaSPayments.
     */
    data: SaaSPaymentCreateManyInput | SaaSPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaaSPayment createManyAndReturn
   */
  export type SaaSPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaaSPayments.
     */
    data: SaaSPaymentCreateManyInput | SaaSPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaaSPayment update
   */
  export type SaaSPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SaaSPayment.
     */
    data: XOR<SaaSPaymentUpdateInput, SaaSPaymentUncheckedUpdateInput>
    /**
     * Choose, which SaaSPayment to update.
     */
    where: SaaSPaymentWhereUniqueInput
  }

  /**
   * SaaSPayment updateMany
   */
  export type SaaSPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaaSPayments.
     */
    data: XOR<SaaSPaymentUpdateManyMutationInput, SaaSPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SaaSPayments to update
     */
    where?: SaaSPaymentWhereInput
  }

  /**
   * SaaSPayment upsert
   */
  export type SaaSPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SaaSPayment to update in case it exists.
     */
    where: SaaSPaymentWhereUniqueInput
    /**
     * In case the SaaSPayment found by the `where` argument doesn't exist, create a new SaaSPayment with this data.
     */
    create: XOR<SaaSPaymentCreateInput, SaaSPaymentUncheckedCreateInput>
    /**
     * In case the SaaSPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaaSPaymentUpdateInput, SaaSPaymentUncheckedUpdateInput>
  }

  /**
   * SaaSPayment delete
   */
  export type SaaSPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
    /**
     * Filter which SaaSPayment to delete.
     */
    where: SaaSPaymentWhereUniqueInput
  }

  /**
   * SaaSPayment deleteMany
   */
  export type SaaSPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaaSPayments to delete
     */
    where?: SaaSPaymentWhereInput
  }

  /**
   * SaaSPayment without action
   */
  export type SaaSPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaaSPayment
     */
    select?: SaaSPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaaSPaymentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userNo: number | null
  }

  export type UserSumAggregateOutputType = {
    userNo: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userNo: number | null
    tenantId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    bio: string | null
    avatar: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isTwoFactorEnabled: boolean | null
    twoFactorMethod: string | null
    phoneNumber: string | null
    twoFactorSecret: string | null
    twoFactorExpires: Date | null
    isSuperAdmin: boolean | null
    superAdminRoleId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userNo: number | null
    tenantId: string | null
    name: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    bio: string | null
    avatar: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isTwoFactorEnabled: boolean | null
    twoFactorMethod: string | null
    phoneNumber: string | null
    twoFactorSecret: string | null
    twoFactorExpires: Date | null
    isSuperAdmin: boolean | null
    superAdminRoleId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userNo: number
    tenantId: number
    name: number
    email: number
    passwordHash: number
    role: number
    permissions: number
    bio: number
    avatar: number
    status: number
    createdAt: number
    updatedAt: number
    isTwoFactorEnabled: number
    twoFactorMethod: number
    phoneNumber: number
    twoFactorSecret: number
    twoFactorExpires: number
    isSuperAdmin: number
    superAdminRoleId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userNo?: true
  }

  export type UserSumAggregateInputType = {
    userNo?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    userNo?: true
    tenantId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    bio?: true
    avatar?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    isTwoFactorEnabled?: true
    twoFactorMethod?: true
    phoneNumber?: true
    twoFactorSecret?: true
    twoFactorExpires?: true
    isSuperAdmin?: true
    superAdminRoleId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userNo?: true
    tenantId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    bio?: true
    avatar?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    isTwoFactorEnabled?: true
    twoFactorMethod?: true
    phoneNumber?: true
    twoFactorSecret?: true
    twoFactorExpires?: true
    isSuperAdmin?: true
    superAdminRoleId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userNo?: true
    tenantId?: true
    name?: true
    email?: true
    passwordHash?: true
    role?: true
    permissions?: true
    bio?: true
    avatar?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    isTwoFactorEnabled?: true
    twoFactorMethod?: true
    phoneNumber?: true
    twoFactorSecret?: true
    twoFactorExpires?: true
    isSuperAdmin?: true
    superAdminRoleId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    userNo: number
    tenantId: string
    name: string | null
    email: string
    passwordHash: string
    role: $Enums.UserRole
    permissions: JsonValue | null
    bio: string | null
    avatar: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    isTwoFactorEnabled: boolean
    twoFactorMethod: string | null
    phoneNumber: string | null
    twoFactorSecret: string | null
    twoFactorExpires: Date | null
    isSuperAdmin: boolean
    superAdminRoleId: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userNo?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    permissions?: boolean
    bio?: boolean
    avatar?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: boolean
    phoneNumber?: boolean
    twoFactorSecret?: boolean
    twoFactorExpires?: boolean
    isSuperAdmin?: boolean
    superAdminRoleId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    superAdminRole?: boolean | User$superAdminRoleArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userNo?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    permissions?: boolean
    bio?: boolean
    avatar?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: boolean
    phoneNumber?: boolean
    twoFactorSecret?: boolean
    twoFactorExpires?: boolean
    isSuperAdmin?: boolean
    superAdminRoleId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    superAdminRole?: boolean | User$superAdminRoleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    userNo?: boolean
    tenantId?: boolean
    name?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    permissions?: boolean
    bio?: boolean
    avatar?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: boolean
    phoneNumber?: boolean
    twoFactorSecret?: boolean
    twoFactorExpires?: boolean
    isSuperAdmin?: boolean
    superAdminRoleId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    superAdminRole?: boolean | User$superAdminRoleArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    superAdminRole?: boolean | User$superAdminRoleArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      superAdminRole: Prisma.$SuperAdminRolePayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userNo: number
      tenantId: string
      name: string | null
      email: string
      passwordHash: string
      role: $Enums.UserRole
      permissions: Prisma.JsonValue | null
      bio: string | null
      avatar: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      isTwoFactorEnabled: boolean
      twoFactorMethod: string | null
      phoneNumber: string | null
      twoFactorSecret: string | null
      twoFactorExpires: Date | null
      isSuperAdmin: boolean
      superAdminRoleId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    superAdminRole<T extends User$superAdminRoleArgs<ExtArgs> = {}>(args?: Subset<T, User$superAdminRoleArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly userNo: FieldRef<"User", 'Int'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly permissions: FieldRef<"User", 'Json'>
    readonly bio: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly isTwoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorMethod: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorExpires: FieldRef<"User", 'DateTime'>
    readonly isSuperAdmin: FieldRef<"User", 'Boolean'>
    readonly superAdminRoleId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.superAdminRole
   */
  export type User$superAdminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    where?: SuperAdminRoleWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    balance: Decimal | null
    riskLimit: Decimal | null
  }

  export type AccountSumAggregateOutputType = {
    balance: Decimal | null
    riskLimit: Decimal | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.AccountType | null
    accountCode: string | null
    name: string | null
    balance: Decimal | null
    riskLimit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.AccountType | null
    accountCode: string | null
    name: string | null
    balance: Decimal | null
    riskLimit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    accountCode: number
    name: number
    balance: number
    riskLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    balance?: true
    riskLimit?: true
  }

  export type AccountSumAggregateInputType = {
    balance?: true
    riskLimit?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    accountCode?: true
    name?: true
    balance?: true
    riskLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    accountCode?: true
    name?: true
    balance?: true
    riskLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    accountCode?: true
    name?: true
    balance?: true
    riskLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    tenantId: string
    type: $Enums.AccountType
    accountCode: string | null
    name: string
    balance: Decimal
    riskLimit: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    accountCode?: boolean
    name?: boolean
    balance?: boolean
    riskLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoices?: boolean | Account$invoicesArgs<ExtArgs>
    offers?: boolean | Account$offersArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    serviceTickets?: boolean | Account$serviceTicketsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    accountCode?: boolean
    name?: boolean
    balance?: boolean
    riskLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    accountCode?: boolean
    name?: boolean
    balance?: boolean
    riskLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoices?: boolean | Account$invoicesArgs<ExtArgs>
    offers?: boolean | Account$offersArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    serviceTickets?: boolean | Account$serviceTicketsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      serviceTickets: Prisma.$ServiceTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: $Enums.AccountType
      accountCode: string | null
      name: string
      balance: Prisma.Decimal
      riskLimit: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends Account$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Account$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    offers<T extends Account$offersArgs<ExtArgs> = {}>(args?: Subset<T, Account$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Account$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    serviceTickets<T extends Account$serviceTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Account$serviceTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly tenantId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'AccountType'>
    readonly accountCode: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly balance: FieldRef<"Account", 'Decimal'>
    readonly riskLimit: FieldRef<"Account", 'Decimal'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.invoices
   */
  export type Account$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Account.offers
   */
  export type Account$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Account.transactions
   */
  export type Account$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Account.serviceTickets
   */
  export type Account$serviceTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    where?: ServiceTicketWhereInput
    orderBy?: ServiceTicketOrderByWithRelationInput | ServiceTicketOrderByWithRelationInput[]
    cursor?: ServiceTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTicketScalarFieldEnum | ServiceTicketScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    stockQuantity: number | null
    priceSell: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    stockQuantity: number | null
    priceSell: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    code: string | null
    barcode: string | null
    stockQuantity: number | null
    priceSell: Decimal | null
    trackStock: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    code: string | null
    barcode: string | null
    stockQuantity: number | null
    priceSell: Decimal | null
    trackStock: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    code: number
    barcode: number
    stockQuantity: number
    priceSell: number
    trackStock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    stockQuantity?: true
    priceSell?: true
  }

  export type ProductSumAggregateInputType = {
    stockQuantity?: true
    priceSell?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    code?: true
    barcode?: true
    stockQuantity?: true
    priceSell?: true
    trackStock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    code?: true
    barcode?: true
    stockQuantity?: true
    priceSell?: true
    trackStock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    code?: true
    barcode?: true
    stockQuantity?: true
    priceSell?: true
    trackStock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    code: string | null
    barcode: string | null
    stockQuantity: number
    priceSell: Decimal
    trackStock: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    code?: boolean
    barcode?: boolean
    stockQuantity?: boolean
    priceSell?: boolean
    trackStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    stockMovements?: boolean | Product$stockMovementsArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    serviceParts?: boolean | Product$servicePartsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    code?: boolean
    barcode?: boolean
    stockQuantity?: boolean
    priceSell?: boolean
    trackStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    code?: boolean
    barcode?: boolean
    stockQuantity?: boolean
    priceSell?: boolean
    trackStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    stockMovements?: boolean | Product$stockMovementsArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    serviceParts?: boolean | Product$servicePartsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      serviceParts: Prisma.$ServicePartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      code: string | null
      barcode: string | null
      stockQuantity: number
      priceSell: Prisma.Decimal
      trackStock: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stockMovements<T extends Product$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    invoiceItems<T extends Product$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    serviceParts<T extends Product$servicePartsArgs<ExtArgs> = {}>(args?: Subset<T, Product$servicePartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly tenantId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly stockQuantity: FieldRef<"Product", 'Int'>
    readonly priceSell: FieldRef<"Product", 'Decimal'>
    readonly trackStock: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.stockMovements
   */
  export type Product$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Product.invoiceItems
   */
  export type Product$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Product.serviceParts
   */
  export type Product$servicePartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    where?: ServicePartWhereInput
    orderBy?: ServicePartOrderByWithRelationInput | ServicePartOrderByWithRelationInput[]
    cursor?: ServicePartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePartScalarFieldEnum | ServicePartScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    type: $Enums.StockMovementType | null
    quantity: number | null
    documentRef: string | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    type: $Enums.StockMovementType | null
    quantity: number | null
    documentRef: string | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    tenantId: number
    productId: number
    type: number
    quantity: number
    documentRef: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type StockMovementSumAggregateInputType = {
    quantity?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    type?: true
    quantity?: true
    documentRef?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    type?: true
    quantity?: true
    documentRef?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    type?: true
    quantity?: true
    documentRef?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: string
    tenantId: string
    productId: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef: string | null
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    documentRef?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    documentRef?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectScalar = {
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    documentRef?: boolean
    createdAt?: boolean
  }

  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      productId: string
      type: $Enums.StockMovementType
      quantity: number
      documentRef: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockMovements and returns the data saved in the database.
     * @param {StockMovementCreateManyAndReturnArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockMovements and only return the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, StockMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */ 
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'String'>
    readonly tenantId: FieldRef<"StockMovement", 'String'>
    readonly productId: FieldRef<"StockMovement", 'String'>
    readonly type: FieldRef<"StockMovement", 'StockMovementType'>
    readonly quantity: FieldRef<"StockMovement", 'Int'>
    readonly documentRef: FieldRef<"StockMovement", 'String'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockMovement createManyAndReturn
   */
  export type StockMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model CashRegister
   */

  export type AggregateCashRegister = {
    _count: CashRegisterCountAggregateOutputType | null
    _avg: CashRegisterAvgAggregateOutputType | null
    _sum: CashRegisterSumAggregateOutputType | null
    _min: CashRegisterMinAggregateOutputType | null
    _max: CashRegisterMaxAggregateOutputType | null
  }

  export type CashRegisterAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type CashRegisterSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type CashRegisterMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    currency: string | null
    balance: Decimal | null
    createdAt: Date | null
  }

  export type CashRegisterMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    currency: string | null
    balance: Decimal | null
    createdAt: Date | null
  }

  export type CashRegisterCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    currency: number
    balance: number
    createdAt: number
    _all: number
  }


  export type CashRegisterAvgAggregateInputType = {
    balance?: true
  }

  export type CashRegisterSumAggregateInputType = {
    balance?: true
  }

  export type CashRegisterMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    currency?: true
    balance?: true
    createdAt?: true
  }

  export type CashRegisterMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    currency?: true
    balance?: true
    createdAt?: true
  }

  export type CashRegisterCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    currency?: true
    balance?: true
    createdAt?: true
    _all?: true
  }

  export type CashRegisterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRegister to aggregate.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashRegisters
    **/
    _count?: true | CashRegisterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashRegisterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashRegisterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashRegisterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashRegisterMaxAggregateInputType
  }

  export type GetCashRegisterAggregateType<T extends CashRegisterAggregateArgs> = {
        [P in keyof T & keyof AggregateCashRegister]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashRegister[P]>
      : GetScalarType<T[P], AggregateCashRegister[P]>
  }




  export type CashRegisterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithAggregationInput | CashRegisterOrderByWithAggregationInput[]
    by: CashRegisterScalarFieldEnum[] | CashRegisterScalarFieldEnum
    having?: CashRegisterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashRegisterCountAggregateInputType | true
    _avg?: CashRegisterAvgAggregateInputType
    _sum?: CashRegisterSumAggregateInputType
    _min?: CashRegisterMinAggregateInputType
    _max?: CashRegisterMaxAggregateInputType
  }

  export type CashRegisterGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    currency: string
    balance: Decimal
    createdAt: Date
    _count: CashRegisterCountAggregateOutputType | null
    _avg: CashRegisterAvgAggregateOutputType | null
    _sum: CashRegisterSumAggregateOutputType | null
    _min: CashRegisterMinAggregateOutputType | null
    _max: CashRegisterMaxAggregateOutputType | null
  }

  type GetCashRegisterGroupByPayload<T extends CashRegisterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashRegisterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashRegisterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashRegisterGroupByOutputType[P]>
            : GetScalarType<T[P], CashRegisterGroupByOutputType[P]>
        }
      >
    >


  export type CashRegisterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    currency?: boolean
    balance?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | CashRegister$transactionsArgs<ExtArgs>
    posSessions?: boolean | CashRegister$posSessionsArgs<ExtArgs>
    _count?: boolean | CashRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    currency?: boolean
    balance?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    currency?: boolean
    balance?: boolean
    createdAt?: boolean
  }

  export type CashRegisterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | CashRegister$transactionsArgs<ExtArgs>
    posSessions?: boolean | CashRegister$posSessionsArgs<ExtArgs>
    _count?: boolean | CashRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CashRegisterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CashRegisterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashRegister"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      posSessions: Prisma.$PosSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      currency: string
      balance: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["cashRegister"]>
    composites: {}
  }

  type CashRegisterGetPayload<S extends boolean | null | undefined | CashRegisterDefaultArgs> = $Result.GetResult<Prisma.$CashRegisterPayload, S>

  type CashRegisterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashRegisterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashRegisterCountAggregateInputType | true
    }

  export interface CashRegisterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashRegister'], meta: { name: 'CashRegister' } }
    /**
     * Find zero or one CashRegister that matches the filter.
     * @param {CashRegisterFindUniqueArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashRegisterFindUniqueArgs>(args: SelectSubset<T, CashRegisterFindUniqueArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashRegister that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashRegisterFindUniqueOrThrowArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashRegisterFindUniqueOrThrowArgs>(args: SelectSubset<T, CashRegisterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashRegister that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindFirstArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashRegisterFindFirstArgs>(args?: SelectSubset<T, CashRegisterFindFirstArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashRegister that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindFirstOrThrowArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashRegisterFindFirstOrThrowArgs>(args?: SelectSubset<T, CashRegisterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashRegisters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashRegisters
     * const cashRegisters = await prisma.cashRegister.findMany()
     * 
     * // Get first 10 CashRegisters
     * const cashRegisters = await prisma.cashRegister.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashRegisterFindManyArgs>(args?: SelectSubset<T, CashRegisterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashRegister.
     * @param {CashRegisterCreateArgs} args - Arguments to create a CashRegister.
     * @example
     * // Create one CashRegister
     * const CashRegister = await prisma.cashRegister.create({
     *   data: {
     *     // ... data to create a CashRegister
     *   }
     * })
     * 
     */
    create<T extends CashRegisterCreateArgs>(args: SelectSubset<T, CashRegisterCreateArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashRegisters.
     * @param {CashRegisterCreateManyArgs} args - Arguments to create many CashRegisters.
     * @example
     * // Create many CashRegisters
     * const cashRegister = await prisma.cashRegister.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashRegisterCreateManyArgs>(args?: SelectSubset<T, CashRegisterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashRegisters and returns the data saved in the database.
     * @param {CashRegisterCreateManyAndReturnArgs} args - Arguments to create many CashRegisters.
     * @example
     * // Create many CashRegisters
     * const cashRegister = await prisma.cashRegister.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashRegisters and only return the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashRegisterCreateManyAndReturnArgs>(args?: SelectSubset<T, CashRegisterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CashRegister.
     * @param {CashRegisterDeleteArgs} args - Arguments to delete one CashRegister.
     * @example
     * // Delete one CashRegister
     * const CashRegister = await prisma.cashRegister.delete({
     *   where: {
     *     // ... filter to delete one CashRegister
     *   }
     * })
     * 
     */
    delete<T extends CashRegisterDeleteArgs>(args: SelectSubset<T, CashRegisterDeleteArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashRegister.
     * @param {CashRegisterUpdateArgs} args - Arguments to update one CashRegister.
     * @example
     * // Update one CashRegister
     * const cashRegister = await prisma.cashRegister.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashRegisterUpdateArgs>(args: SelectSubset<T, CashRegisterUpdateArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashRegisters.
     * @param {CashRegisterDeleteManyArgs} args - Arguments to filter CashRegisters to delete.
     * @example
     * // Delete a few CashRegisters
     * const { count } = await prisma.cashRegister.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashRegisterDeleteManyArgs>(args?: SelectSubset<T, CashRegisterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashRegisters
     * const cashRegister = await prisma.cashRegister.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashRegisterUpdateManyArgs>(args: SelectSubset<T, CashRegisterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashRegister.
     * @param {CashRegisterUpsertArgs} args - Arguments to update or create a CashRegister.
     * @example
     * // Update or create a CashRegister
     * const cashRegister = await prisma.cashRegister.upsert({
     *   create: {
     *     // ... data to create a CashRegister
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashRegister we want to update
     *   }
     * })
     */
    upsert<T extends CashRegisterUpsertArgs>(args: SelectSubset<T, CashRegisterUpsertArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterCountArgs} args - Arguments to filter CashRegisters to count.
     * @example
     * // Count the number of CashRegisters
     * const count = await prisma.cashRegister.count({
     *   where: {
     *     // ... the filter for the CashRegisters we want to count
     *   }
     * })
    **/
    count<T extends CashRegisterCountArgs>(
      args?: Subset<T, CashRegisterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashRegisterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashRegisterAggregateArgs>(args: Subset<T, CashRegisterAggregateArgs>): Prisma.PrismaPromise<GetCashRegisterAggregateType<T>>

    /**
     * Group by CashRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashRegisterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashRegisterGroupByArgs['orderBy'] }
        : { orderBy?: CashRegisterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashRegisterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashRegisterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashRegister model
   */
  readonly fields: CashRegisterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashRegister.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashRegisterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends CashRegister$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    posSessions<T extends CashRegister$posSessionsArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$posSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashRegister model
   */ 
  interface CashRegisterFieldRefs {
    readonly id: FieldRef<"CashRegister", 'String'>
    readonly tenantId: FieldRef<"CashRegister", 'String'>
    readonly name: FieldRef<"CashRegister", 'String'>
    readonly currency: FieldRef<"CashRegister", 'String'>
    readonly balance: FieldRef<"CashRegister", 'Decimal'>
    readonly createdAt: FieldRef<"CashRegister", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashRegister findUnique
   */
  export type CashRegisterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister findUniqueOrThrow
   */
  export type CashRegisterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister findFirst
   */
  export type CashRegisterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRegisters.
     */
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister findFirstOrThrow
   */
  export type CashRegisterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRegisters.
     */
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister findMany
   */
  export type CashRegisterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegisters to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister create
   */
  export type CashRegisterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The data needed to create a CashRegister.
     */
    data: XOR<CashRegisterCreateInput, CashRegisterUncheckedCreateInput>
  }

  /**
   * CashRegister createMany
   */
  export type CashRegisterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashRegisters.
     */
    data: CashRegisterCreateManyInput | CashRegisterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashRegister createManyAndReturn
   */
  export type CashRegisterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CashRegisters.
     */
    data: CashRegisterCreateManyInput | CashRegisterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashRegister update
   */
  export type CashRegisterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The data needed to update a CashRegister.
     */
    data: XOR<CashRegisterUpdateInput, CashRegisterUncheckedUpdateInput>
    /**
     * Choose, which CashRegister to update.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister updateMany
   */
  export type CashRegisterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashRegisters.
     */
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyInput>
    /**
     * Filter which CashRegisters to update
     */
    where?: CashRegisterWhereInput
  }

  /**
   * CashRegister upsert
   */
  export type CashRegisterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The filter to search for the CashRegister to update in case it exists.
     */
    where: CashRegisterWhereUniqueInput
    /**
     * In case the CashRegister found by the `where` argument doesn't exist, create a new CashRegister with this data.
     */
    create: XOR<CashRegisterCreateInput, CashRegisterUncheckedCreateInput>
    /**
     * In case the CashRegister was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashRegisterUpdateInput, CashRegisterUncheckedUpdateInput>
  }

  /**
   * CashRegister delete
   */
  export type CashRegisterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter which CashRegister to delete.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister deleteMany
   */
  export type CashRegisterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRegisters to delete
     */
    where?: CashRegisterWhereInput
  }

  /**
   * CashRegister.transactions
   */
  export type CashRegister$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * CashRegister.posSessions
   */
  export type CashRegister$posSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    where?: PosSessionWhereInput
    orderBy?: PosSessionOrderByWithRelationInput | PosSessionOrderByWithRelationInput[]
    cursor?: PosSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosSessionScalarFieldEnum | PosSessionScalarFieldEnum[]
  }

  /**
   * CashRegister without action
   */
  export type CashRegisterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    exchangeRate: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    exchangeRate: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registerId: string | null
    accountId: string | null
    type: $Enums.TransactionType | null
    amount: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    description: string | null
    relatedId: string | null
    invoiceId: string | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registerId: string | null
    accountId: string | null
    type: $Enums.TransactionType | null
    amount: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    description: string | null
    relatedId: string | null
    invoiceId: string | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    tenantId: number
    registerId: number
    accountId: number
    type: number
    amount: number
    currency: number
    exchangeRate: number
    description: number
    relatedId: number
    invoiceId: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    exchangeRate?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    exchangeRate?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    tenantId?: true
    registerId?: true
    accountId?: true
    type?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    description?: true
    relatedId?: true
    invoiceId?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    registerId?: true
    accountId?: true
    type?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    description?: true
    relatedId?: true
    invoiceId?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    tenantId?: true
    registerId?: true
    accountId?: true
    type?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    description?: true
    relatedId?: true
    invoiceId?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    tenantId: string
    registerId: string
    accountId: string | null
    type: $Enums.TransactionType
    amount: Decimal
    currency: string
    exchangeRate: Decimal
    description: string | null
    relatedId: string | null
    invoiceId: string | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registerId?: boolean
    accountId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    description?: boolean
    relatedId?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registerId?: boolean
    accountId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    description?: boolean
    relatedId?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    registerId?: boolean
    accountId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    description?: boolean
    relatedId?: boolean
    invoiceId?: boolean
    createdAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    account?: boolean | Transaction$accountArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      register: Prisma.$CashRegisterPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      registerId: string
      accountId: string | null
      type: $Enums.TransactionType
      amount: Prisma.Decimal
      currency: string
      exchangeRate: Prisma.Decimal
      description: string | null
      relatedId: string | null
      invoiceId: string | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    register<T extends CashRegisterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashRegisterDefaultArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends Transaction$accountArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invoice<T extends Transaction$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly tenantId: FieldRef<"Transaction", 'String'>
    readonly registerId: FieldRef<"Transaction", 'String'>
    readonly accountId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly exchangeRate: FieldRef<"Transaction", 'Decimal'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly relatedId: FieldRef<"Transaction", 'String'>
    readonly invoiceId: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.account
   */
  export type Transaction$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Transaction.invoice
   */
  export type Transaction$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountId: string | null
    type: $Enums.InvoiceType | null
    totalAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountId: string | null
    type: $Enums.InvoiceType | null
    totalAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    accountId: number
    type: number
    totalAmount: number
    status: number
    dueDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    accountId?: true
    type?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    accountId?: true
    type?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    accountId?: true
    type?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    tenantId: string
    accountId: string
    type: $Enums.InvoiceType
    totalAmount: Decimal
    status: $Enums.InvoiceStatus
    dueDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountId?: boolean
    type?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountId?: boolean
    type?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    accountId?: boolean
    type?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      accountId: string
      type: $Enums.InvoiceType
      totalAmount: Prisma.Decimal
      status: $Enums.InvoiceStatus
      dueDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Invoice$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly accountId: FieldRef<"Invoice", 'String'>
    readonly type: FieldRef<"Invoice", 'InvoiceType'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.transactions
   */
  export type Invoice$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type OfferSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountId: string | null
    totalAmount: Decimal | null
    status: $Enums.OfferStatus | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accountId: string | null
    totalAmount: Decimal | null
    status: $Enums.OfferStatus | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    tenantId: number
    accountId: number
    totalAmount: number
    status: number
    validUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    totalAmount?: true
  }

  export type OfferSumAggregateInputType = {
    totalAmount?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    tenantId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    tenantId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    tenantId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: string
    tenantId: string
    accountId: string
    totalAmount: Decimal
    status: $Enums.OfferStatus
    validUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    items?: boolean | Offer$itemsArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    tenantId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    items?: boolean | Offer$itemsArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      accountId: string
      totalAmount: Prisma.Decimal
      status: $Enums.OfferStatus
      validUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Offer$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Offer$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */ 
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'String'>
    readonly tenantId: FieldRef<"Offer", 'String'>
    readonly accountId: FieldRef<"Offer", 'String'>
    readonly totalAmount: FieldRef<"Offer", 'Decimal'>
    readonly status: FieldRef<"Offer", 'OfferStatus'>
    readonly validUntil: FieldRef<"Offer", 'DateTime'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly updatedAt: FieldRef<"Offer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
  }

  /**
   * Offer.items
   */
  export type Offer$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    offerId: string | null
    productId: string | null
    name: string | null
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    offerId: string | null
    productId: string | null
    name: string | null
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    offerId: number
    productId: number
    name: number
    quantity: number
    price: number
    total: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    price?: true
    total?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    price?: true
    total?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    offerId?: true
    productId?: true
    name?: true
    quantity?: true
    price?: true
    total?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    offerId?: true
    productId?: true
    name?: true
    quantity?: true
    price?: true
    total?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    offerId?: true
    productId?: true
    name?: true
    quantity?: true
    price?: true
    total?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string | null
    offerId: string | null
    productId: string | null
    name: string
    quantity: number
    price: Decimal
    total: Decimal
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    offerId?: boolean
    productId?: boolean
    name?: boolean
    quantity?: boolean
    price?: boolean
    total?: boolean
    invoice?: boolean | InvoiceItem$invoiceArgs<ExtArgs>
    offer?: boolean | InvoiceItem$offerArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    offerId?: boolean
    productId?: boolean
    name?: boolean
    quantity?: boolean
    price?: boolean
    total?: boolean
    invoice?: boolean | InvoiceItem$invoiceArgs<ExtArgs>
    offer?: boolean | InvoiceItem$offerArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    offerId?: boolean
    productId?: boolean
    name?: boolean
    quantity?: boolean
    price?: boolean
    total?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceItem$invoiceArgs<ExtArgs>
    offer?: boolean | InvoiceItem$offerArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceItem$invoiceArgs<ExtArgs>
    offer?: boolean | InvoiceItem$offerArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      offer: Prisma.$OfferPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string | null
      offerId: string | null
      productId: string | null
      name: string
      quantity: number
      price: Prisma.Decimal
      total: Prisma.Decimal
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceItem$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    offer<T extends InvoiceItem$offerArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$offerArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product<T extends InvoiceItem$productArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly offerId: FieldRef<"InvoiceItem", 'String'>
    readonly productId: FieldRef<"InvoiceItem", 'String'>
    readonly name: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly price: FieldRef<"InvoiceItem", 'Decimal'>
    readonly total: FieldRef<"InvoiceItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem.invoice
   */
  export type InvoiceItem$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * InvoiceItem.offer
   */
  export type InvoiceItem$offerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
  }

  /**
   * InvoiceItem.product
   */
  export type InvoiceItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model PosSession
   */

  export type AggregatePosSession = {
    _count: PosSessionCountAggregateOutputType | null
    _avg: PosSessionAvgAggregateOutputType | null
    _sum: PosSessionSumAggregateOutputType | null
    _min: PosSessionMinAggregateOutputType | null
    _max: PosSessionMaxAggregateOutputType | null
  }

  export type PosSessionAvgAggregateOutputType = {
    openingBalance: Decimal | null
    closingBalance: Decimal | null
  }

  export type PosSessionSumAggregateOutputType = {
    openingBalance: Decimal | null
    closingBalance: Decimal | null
  }

  export type PosSessionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registerId: string | null
    employeeId: string | null
    openedAt: Date | null
    closedAt: Date | null
    openingBalance: Decimal | null
    closingBalance: Decimal | null
  }

  export type PosSessionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registerId: string | null
    employeeId: string | null
    openedAt: Date | null
    closedAt: Date | null
    openingBalance: Decimal | null
    closingBalance: Decimal | null
  }

  export type PosSessionCountAggregateOutputType = {
    id: number
    tenantId: number
    registerId: number
    employeeId: number
    openedAt: number
    closedAt: number
    openingBalance: number
    closingBalance: number
    _all: number
  }


  export type PosSessionAvgAggregateInputType = {
    openingBalance?: true
    closingBalance?: true
  }

  export type PosSessionSumAggregateInputType = {
    openingBalance?: true
    closingBalance?: true
  }

  export type PosSessionMinAggregateInputType = {
    id?: true
    tenantId?: true
    registerId?: true
    employeeId?: true
    openedAt?: true
    closedAt?: true
    openingBalance?: true
    closingBalance?: true
  }

  export type PosSessionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    registerId?: true
    employeeId?: true
    openedAt?: true
    closedAt?: true
    openingBalance?: true
    closingBalance?: true
  }

  export type PosSessionCountAggregateInputType = {
    id?: true
    tenantId?: true
    registerId?: true
    employeeId?: true
    openedAt?: true
    closedAt?: true
    openingBalance?: true
    closingBalance?: true
    _all?: true
  }

  export type PosSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosSession to aggregate.
     */
    where?: PosSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosSessions to fetch.
     */
    orderBy?: PosSessionOrderByWithRelationInput | PosSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosSessions
    **/
    _count?: true | PosSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosSessionMaxAggregateInputType
  }

  export type GetPosSessionAggregateType<T extends PosSessionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosSession[P]>
      : GetScalarType<T[P], AggregatePosSession[P]>
  }




  export type PosSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosSessionWhereInput
    orderBy?: PosSessionOrderByWithAggregationInput | PosSessionOrderByWithAggregationInput[]
    by: PosSessionScalarFieldEnum[] | PosSessionScalarFieldEnum
    having?: PosSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosSessionCountAggregateInputType | true
    _avg?: PosSessionAvgAggregateInputType
    _sum?: PosSessionSumAggregateInputType
    _min?: PosSessionMinAggregateInputType
    _max?: PosSessionMaxAggregateInputType
  }

  export type PosSessionGroupByOutputType = {
    id: string
    tenantId: string
    registerId: string
    employeeId: string | null
    openedAt: Date
    closedAt: Date | null
    openingBalance: Decimal
    closingBalance: Decimal | null
    _count: PosSessionCountAggregateOutputType | null
    _avg: PosSessionAvgAggregateOutputType | null
    _sum: PosSessionSumAggregateOutputType | null
    _min: PosSessionMinAggregateOutputType | null
    _max: PosSessionMaxAggregateOutputType | null
  }

  type GetPosSessionGroupByPayload<T extends PosSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosSessionGroupByOutputType[P]>
            : GetScalarType<T[P], PosSessionGroupByOutputType[P]>
        }
      >
    >


  export type PosSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registerId?: boolean
    employeeId?: boolean
    openedAt?: boolean
    closedAt?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    employee?: boolean | PosSession$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["posSession"]>

  export type PosSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registerId?: boolean
    employeeId?: boolean
    openedAt?: boolean
    closedAt?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    employee?: boolean | PosSession$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["posSession"]>

  export type PosSessionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    registerId?: boolean
    employeeId?: boolean
    openedAt?: boolean
    closedAt?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
  }

  export type PosSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    employee?: boolean | PosSession$employeeArgs<ExtArgs>
  }
  export type PosSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    register?: boolean | CashRegisterDefaultArgs<ExtArgs>
    employee?: boolean | PosSession$employeeArgs<ExtArgs>
  }

  export type $PosSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosSession"
    objects: {
      register: Prisma.$CashRegisterPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      registerId: string
      employeeId: string | null
      openedAt: Date
      closedAt: Date | null
      openingBalance: Prisma.Decimal
      closingBalance: Prisma.Decimal | null
    }, ExtArgs["result"]["posSession"]>
    composites: {}
  }

  type PosSessionGetPayload<S extends boolean | null | undefined | PosSessionDefaultArgs> = $Result.GetResult<Prisma.$PosSessionPayload, S>

  type PosSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PosSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PosSessionCountAggregateInputType | true
    }

  export interface PosSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosSession'], meta: { name: 'PosSession' } }
    /**
     * Find zero or one PosSession that matches the filter.
     * @param {PosSessionFindUniqueArgs} args - Arguments to find a PosSession
     * @example
     * // Get one PosSession
     * const posSession = await prisma.posSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosSessionFindUniqueArgs>(args: SelectSubset<T, PosSessionFindUniqueArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PosSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PosSessionFindUniqueOrThrowArgs} args - Arguments to find a PosSession
     * @example
     * // Get one PosSession
     * const posSession = await prisma.posSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, PosSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PosSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosSessionFindFirstArgs} args - Arguments to find a PosSession
     * @example
     * // Get one PosSession
     * const posSession = await prisma.posSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosSessionFindFirstArgs>(args?: SelectSubset<T, PosSessionFindFirstArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PosSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosSessionFindFirstOrThrowArgs} args - Arguments to find a PosSession
     * @example
     * // Get one PosSession
     * const posSession = await prisma.posSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, PosSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PosSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosSessions
     * const posSessions = await prisma.posSession.findMany()
     * 
     * // Get first 10 PosSessions
     * const posSessions = await prisma.posSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posSessionWithIdOnly = await prisma.posSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosSessionFindManyArgs>(args?: SelectSubset<T, PosSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PosSession.
     * @param {PosSessionCreateArgs} args - Arguments to create a PosSession.
     * @example
     * // Create one PosSession
     * const PosSession = await prisma.posSession.create({
     *   data: {
     *     // ... data to create a PosSession
     *   }
     * })
     * 
     */
    create<T extends PosSessionCreateArgs>(args: SelectSubset<T, PosSessionCreateArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PosSessions.
     * @param {PosSessionCreateManyArgs} args - Arguments to create many PosSessions.
     * @example
     * // Create many PosSessions
     * const posSession = await prisma.posSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosSessionCreateManyArgs>(args?: SelectSubset<T, PosSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosSessions and returns the data saved in the database.
     * @param {PosSessionCreateManyAndReturnArgs} args - Arguments to create many PosSessions.
     * @example
     * // Create many PosSessions
     * const posSession = await prisma.posSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosSessions and only return the `id`
     * const posSessionWithIdOnly = await prisma.posSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, PosSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PosSession.
     * @param {PosSessionDeleteArgs} args - Arguments to delete one PosSession.
     * @example
     * // Delete one PosSession
     * const PosSession = await prisma.posSession.delete({
     *   where: {
     *     // ... filter to delete one PosSession
     *   }
     * })
     * 
     */
    delete<T extends PosSessionDeleteArgs>(args: SelectSubset<T, PosSessionDeleteArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PosSession.
     * @param {PosSessionUpdateArgs} args - Arguments to update one PosSession.
     * @example
     * // Update one PosSession
     * const posSession = await prisma.posSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosSessionUpdateArgs>(args: SelectSubset<T, PosSessionUpdateArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PosSessions.
     * @param {PosSessionDeleteManyArgs} args - Arguments to filter PosSessions to delete.
     * @example
     * // Delete a few PosSessions
     * const { count } = await prisma.posSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosSessionDeleteManyArgs>(args?: SelectSubset<T, PosSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosSessions
     * const posSession = await prisma.posSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosSessionUpdateManyArgs>(args: SelectSubset<T, PosSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PosSession.
     * @param {PosSessionUpsertArgs} args - Arguments to update or create a PosSession.
     * @example
     * // Update or create a PosSession
     * const posSession = await prisma.posSession.upsert({
     *   create: {
     *     // ... data to create a PosSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosSession we want to update
     *   }
     * })
     */
    upsert<T extends PosSessionUpsertArgs>(args: SelectSubset<T, PosSessionUpsertArgs<ExtArgs>>): Prisma__PosSessionClient<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PosSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosSessionCountArgs} args - Arguments to filter PosSessions to count.
     * @example
     * // Count the number of PosSessions
     * const count = await prisma.posSession.count({
     *   where: {
     *     // ... the filter for the PosSessions we want to count
     *   }
     * })
    **/
    count<T extends PosSessionCountArgs>(
      args?: Subset<T, PosSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosSessionAggregateArgs>(args: Subset<T, PosSessionAggregateArgs>): Prisma.PrismaPromise<GetPosSessionAggregateType<T>>

    /**
     * Group by PosSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosSessionGroupByArgs['orderBy'] }
        : { orderBy?: PosSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosSession model
   */
  readonly fields: PosSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    register<T extends CashRegisterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashRegisterDefaultArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    employee<T extends PosSession$employeeArgs<ExtArgs> = {}>(args?: Subset<T, PosSession$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosSession model
   */ 
  interface PosSessionFieldRefs {
    readonly id: FieldRef<"PosSession", 'String'>
    readonly tenantId: FieldRef<"PosSession", 'String'>
    readonly registerId: FieldRef<"PosSession", 'String'>
    readonly employeeId: FieldRef<"PosSession", 'String'>
    readonly openedAt: FieldRef<"PosSession", 'DateTime'>
    readonly closedAt: FieldRef<"PosSession", 'DateTime'>
    readonly openingBalance: FieldRef<"PosSession", 'Decimal'>
    readonly closingBalance: FieldRef<"PosSession", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PosSession findUnique
   */
  export type PosSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * Filter, which PosSession to fetch.
     */
    where: PosSessionWhereUniqueInput
  }

  /**
   * PosSession findUniqueOrThrow
   */
  export type PosSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * Filter, which PosSession to fetch.
     */
    where: PosSessionWhereUniqueInput
  }

  /**
   * PosSession findFirst
   */
  export type PosSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * Filter, which PosSession to fetch.
     */
    where?: PosSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosSessions to fetch.
     */
    orderBy?: PosSessionOrderByWithRelationInput | PosSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosSessions.
     */
    cursor?: PosSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosSessions.
     */
    distinct?: PosSessionScalarFieldEnum | PosSessionScalarFieldEnum[]
  }

  /**
   * PosSession findFirstOrThrow
   */
  export type PosSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * Filter, which PosSession to fetch.
     */
    where?: PosSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosSessions to fetch.
     */
    orderBy?: PosSessionOrderByWithRelationInput | PosSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosSessions.
     */
    cursor?: PosSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosSessions.
     */
    distinct?: PosSessionScalarFieldEnum | PosSessionScalarFieldEnum[]
  }

  /**
   * PosSession findMany
   */
  export type PosSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * Filter, which PosSessions to fetch.
     */
    where?: PosSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosSessions to fetch.
     */
    orderBy?: PosSessionOrderByWithRelationInput | PosSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosSessions.
     */
    cursor?: PosSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosSessions.
     */
    skip?: number
    distinct?: PosSessionScalarFieldEnum | PosSessionScalarFieldEnum[]
  }

  /**
   * PosSession create
   */
  export type PosSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a PosSession.
     */
    data: XOR<PosSessionCreateInput, PosSessionUncheckedCreateInput>
  }

  /**
   * PosSession createMany
   */
  export type PosSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosSessions.
     */
    data: PosSessionCreateManyInput | PosSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosSession createManyAndReturn
   */
  export type PosSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PosSessions.
     */
    data: PosSessionCreateManyInput | PosSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosSession update
   */
  export type PosSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a PosSession.
     */
    data: XOR<PosSessionUpdateInput, PosSessionUncheckedUpdateInput>
    /**
     * Choose, which PosSession to update.
     */
    where: PosSessionWhereUniqueInput
  }

  /**
   * PosSession updateMany
   */
  export type PosSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosSessions.
     */
    data: XOR<PosSessionUpdateManyMutationInput, PosSessionUncheckedUpdateManyInput>
    /**
     * Filter which PosSessions to update
     */
    where?: PosSessionWhereInput
  }

  /**
   * PosSession upsert
   */
  export type PosSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the PosSession to update in case it exists.
     */
    where: PosSessionWhereUniqueInput
    /**
     * In case the PosSession found by the `where` argument doesn't exist, create a new PosSession with this data.
     */
    create: XOR<PosSessionCreateInput, PosSessionUncheckedCreateInput>
    /**
     * In case the PosSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosSessionUpdateInput, PosSessionUncheckedUpdateInput>
  }

  /**
   * PosSession delete
   */
  export type PosSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    /**
     * Filter which PosSession to delete.
     */
    where: PosSessionWhereUniqueInput
  }

  /**
   * PosSession deleteMany
   */
  export type PosSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosSessions to delete
     */
    where?: PosSessionWhereInput
  }

  /**
   * PosSession.employee
   */
  export type PosSession$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * PosSession without action
   */
  export type PosSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
  }


  /**
   * Model ServiceTicket
   */

  export type AggregateServiceTicket = {
    _count: ServiceTicketCountAggregateOutputType | null
    _avg: ServiceTicketAvgAggregateOutputType | null
    _sum: ServiceTicketSumAggregateOutputType | null
    _min: ServiceTicketMinAggregateOutputType | null
    _max: ServiceTicketMaxAggregateOutputType | null
  }

  export type ServiceTicketAvgAggregateOutputType = {
    estimatedCost: Decimal | null
    finalCost: Decimal | null
  }

  export type ServiceTicketSumAggregateOutputType = {
    estimatedCost: Decimal | null
    finalCost: Decimal | null
  }

  export type ServiceTicketMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    customerId: string | null
    technicianId: string | null
    problemDesc: string | null
    status: $Enums.ServiceStatus | null
    estimatedCost: Decimal | null
    finalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTicketMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    customerId: string | null
    technicianId: string | null
    problemDesc: string | null
    status: $Enums.ServiceStatus | null
    estimatedCost: Decimal | null
    finalCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTicketCountAggregateOutputType = {
    id: number
    tenantId: number
    customerId: number
    technicianId: number
    deviceInfo: number
    problemDesc: number
    status: number
    estimatedCost: number
    finalCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTicketAvgAggregateInputType = {
    estimatedCost?: true
    finalCost?: true
  }

  export type ServiceTicketSumAggregateInputType = {
    estimatedCost?: true
    finalCost?: true
  }

  export type ServiceTicketMinAggregateInputType = {
    id?: true
    tenantId?: true
    customerId?: true
    technicianId?: true
    problemDesc?: true
    status?: true
    estimatedCost?: true
    finalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTicketMaxAggregateInputType = {
    id?: true
    tenantId?: true
    customerId?: true
    technicianId?: true
    problemDesc?: true
    status?: true
    estimatedCost?: true
    finalCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTicketCountAggregateInputType = {
    id?: true
    tenantId?: true
    customerId?: true
    technicianId?: true
    deviceInfo?: true
    problemDesc?: true
    status?: true
    estimatedCost?: true
    finalCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTicket to aggregate.
     */
    where?: ServiceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTickets to fetch.
     */
    orderBy?: ServiceTicketOrderByWithRelationInput | ServiceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTickets
    **/
    _count?: true | ServiceTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTicketMaxAggregateInputType
  }

  export type GetServiceTicketAggregateType<T extends ServiceTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTicket[P]>
      : GetScalarType<T[P], AggregateServiceTicket[P]>
  }




  export type ServiceTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTicketWhereInput
    orderBy?: ServiceTicketOrderByWithAggregationInput | ServiceTicketOrderByWithAggregationInput[]
    by: ServiceTicketScalarFieldEnum[] | ServiceTicketScalarFieldEnum
    having?: ServiceTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTicketCountAggregateInputType | true
    _avg?: ServiceTicketAvgAggregateInputType
    _sum?: ServiceTicketSumAggregateInputType
    _min?: ServiceTicketMinAggregateInputType
    _max?: ServiceTicketMaxAggregateInputType
  }

  export type ServiceTicketGroupByOutputType = {
    id: string
    tenantId: string
    customerId: string
    technicianId: string | null
    deviceInfo: JsonValue | null
    problemDesc: string | null
    status: $Enums.ServiceStatus
    estimatedCost: Decimal | null
    finalCost: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceTicketCountAggregateOutputType | null
    _avg: ServiceTicketAvgAggregateOutputType | null
    _sum: ServiceTicketSumAggregateOutputType | null
    _min: ServiceTicketMinAggregateOutputType | null
    _max: ServiceTicketMaxAggregateOutputType | null
  }

  type GetServiceTicketGroupByPayload<T extends ServiceTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTicketGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTicketGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerId?: boolean
    technicianId?: boolean
    deviceInfo?: boolean
    problemDesc?: boolean
    status?: boolean
    estimatedCost?: boolean
    finalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | AccountDefaultArgs<ExtArgs>
    technician?: boolean | ServiceTicket$technicianArgs<ExtArgs>
    parts?: boolean | ServiceTicket$partsArgs<ExtArgs>
    history?: boolean | ServiceTicket$historyArgs<ExtArgs>
    _count?: boolean | ServiceTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTicket"]>

  export type ServiceTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    customerId?: boolean
    technicianId?: boolean
    deviceInfo?: boolean
    problemDesc?: boolean
    status?: boolean
    estimatedCost?: boolean
    finalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | AccountDefaultArgs<ExtArgs>
    technician?: boolean | ServiceTicket$technicianArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTicket"]>

  export type ServiceTicketSelectScalar = {
    id?: boolean
    tenantId?: boolean
    customerId?: boolean
    technicianId?: boolean
    deviceInfo?: boolean
    problemDesc?: boolean
    status?: boolean
    estimatedCost?: boolean
    finalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | AccountDefaultArgs<ExtArgs>
    technician?: boolean | ServiceTicket$technicianArgs<ExtArgs>
    parts?: boolean | ServiceTicket$partsArgs<ExtArgs>
    history?: boolean | ServiceTicket$historyArgs<ExtArgs>
    _count?: boolean | ServiceTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | AccountDefaultArgs<ExtArgs>
    technician?: boolean | ServiceTicket$technicianArgs<ExtArgs>
  }

  export type $ServiceTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceTicket"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      customer: Prisma.$AccountPayload<ExtArgs>
      technician: Prisma.$EmployeePayload<ExtArgs> | null
      parts: Prisma.$ServicePartPayload<ExtArgs>[]
      history: Prisma.$ServiceHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      customerId: string
      technicianId: string | null
      deviceInfo: Prisma.JsonValue | null
      problemDesc: string | null
      status: $Enums.ServiceStatus
      estimatedCost: Prisma.Decimal | null
      finalCost: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceTicket"]>
    composites: {}
  }

  type ServiceTicketGetPayload<S extends boolean | null | undefined | ServiceTicketDefaultArgs> = $Result.GetResult<Prisma.$ServiceTicketPayload, S>

  type ServiceTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceTicketCountAggregateInputType | true
    }

  export interface ServiceTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTicket'], meta: { name: 'ServiceTicket' } }
    /**
     * Find zero or one ServiceTicket that matches the filter.
     * @param {ServiceTicketFindUniqueArgs} args - Arguments to find a ServiceTicket
     * @example
     * // Get one ServiceTicket
     * const serviceTicket = await prisma.serviceTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceTicketFindUniqueArgs>(args: SelectSubset<T, ServiceTicketFindUniqueArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceTicketFindUniqueOrThrowArgs} args - Arguments to find a ServiceTicket
     * @example
     * // Get one ServiceTicket
     * const serviceTicket = await prisma.serviceTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTicketFindFirstArgs} args - Arguments to find a ServiceTicket
     * @example
     * // Get one ServiceTicket
     * const serviceTicket = await prisma.serviceTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceTicketFindFirstArgs>(args?: SelectSubset<T, ServiceTicketFindFirstArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTicketFindFirstOrThrowArgs} args - Arguments to find a ServiceTicket
     * @example
     * // Get one ServiceTicket
     * const serviceTicket = await prisma.serviceTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTickets
     * const serviceTickets = await prisma.serviceTicket.findMany()
     * 
     * // Get first 10 ServiceTickets
     * const serviceTickets = await prisma.serviceTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTicketWithIdOnly = await prisma.serviceTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceTicketFindManyArgs>(args?: SelectSubset<T, ServiceTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceTicket.
     * @param {ServiceTicketCreateArgs} args - Arguments to create a ServiceTicket.
     * @example
     * // Create one ServiceTicket
     * const ServiceTicket = await prisma.serviceTicket.create({
     *   data: {
     *     // ... data to create a ServiceTicket
     *   }
     * })
     * 
     */
    create<T extends ServiceTicketCreateArgs>(args: SelectSubset<T, ServiceTicketCreateArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceTickets.
     * @param {ServiceTicketCreateManyArgs} args - Arguments to create many ServiceTickets.
     * @example
     * // Create many ServiceTickets
     * const serviceTicket = await prisma.serviceTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceTicketCreateManyArgs>(args?: SelectSubset<T, ServiceTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceTickets and returns the data saved in the database.
     * @param {ServiceTicketCreateManyAndReturnArgs} args - Arguments to create many ServiceTickets.
     * @example
     * // Create many ServiceTickets
     * const serviceTicket = await prisma.serviceTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceTickets and only return the `id`
     * const serviceTicketWithIdOnly = await prisma.serviceTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceTicket.
     * @param {ServiceTicketDeleteArgs} args - Arguments to delete one ServiceTicket.
     * @example
     * // Delete one ServiceTicket
     * const ServiceTicket = await prisma.serviceTicket.delete({
     *   where: {
     *     // ... filter to delete one ServiceTicket
     *   }
     * })
     * 
     */
    delete<T extends ServiceTicketDeleteArgs>(args: SelectSubset<T, ServiceTicketDeleteArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceTicket.
     * @param {ServiceTicketUpdateArgs} args - Arguments to update one ServiceTicket.
     * @example
     * // Update one ServiceTicket
     * const serviceTicket = await prisma.serviceTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceTicketUpdateArgs>(args: SelectSubset<T, ServiceTicketUpdateArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceTickets.
     * @param {ServiceTicketDeleteManyArgs} args - Arguments to filter ServiceTickets to delete.
     * @example
     * // Delete a few ServiceTickets
     * const { count } = await prisma.serviceTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceTicketDeleteManyArgs>(args?: SelectSubset<T, ServiceTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTickets
     * const serviceTicket = await prisma.serviceTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceTicketUpdateManyArgs>(args: SelectSubset<T, ServiceTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceTicket.
     * @param {ServiceTicketUpsertArgs} args - Arguments to update or create a ServiceTicket.
     * @example
     * // Update or create a ServiceTicket
     * const serviceTicket = await prisma.serviceTicket.upsert({
     *   create: {
     *     // ... data to create a ServiceTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTicket we want to update
     *   }
     * })
     */
    upsert<T extends ServiceTicketUpsertArgs>(args: SelectSubset<T, ServiceTicketUpsertArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTicketCountArgs} args - Arguments to filter ServiceTickets to count.
     * @example
     * // Count the number of ServiceTickets
     * const count = await prisma.serviceTicket.count({
     *   where: {
     *     // ... the filter for the ServiceTickets we want to count
     *   }
     * })
    **/
    count<T extends ServiceTicketCountArgs>(
      args?: Subset<T, ServiceTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTicketAggregateArgs>(args: Subset<T, ServiceTicketAggregateArgs>): Prisma.PrismaPromise<GetServiceTicketAggregateType<T>>

    /**
     * Group by ServiceTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTicketGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceTicket model
   */
  readonly fields: ServiceTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    technician<T extends ServiceTicket$technicianArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTicket$technicianArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parts<T extends ServiceTicket$partsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTicket$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "findMany"> | Null>
    history<T extends ServiceTicket$historyArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTicket$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceTicket model
   */ 
  interface ServiceTicketFieldRefs {
    readonly id: FieldRef<"ServiceTicket", 'String'>
    readonly tenantId: FieldRef<"ServiceTicket", 'String'>
    readonly customerId: FieldRef<"ServiceTicket", 'String'>
    readonly technicianId: FieldRef<"ServiceTicket", 'String'>
    readonly deviceInfo: FieldRef<"ServiceTicket", 'Json'>
    readonly problemDesc: FieldRef<"ServiceTicket", 'String'>
    readonly status: FieldRef<"ServiceTicket", 'ServiceStatus'>
    readonly estimatedCost: FieldRef<"ServiceTicket", 'Decimal'>
    readonly finalCost: FieldRef<"ServiceTicket", 'Decimal'>
    readonly createdAt: FieldRef<"ServiceTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceTicket findUnique
   */
  export type ServiceTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTicket to fetch.
     */
    where: ServiceTicketWhereUniqueInput
  }

  /**
   * ServiceTicket findUniqueOrThrow
   */
  export type ServiceTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTicket to fetch.
     */
    where: ServiceTicketWhereUniqueInput
  }

  /**
   * ServiceTicket findFirst
   */
  export type ServiceTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTicket to fetch.
     */
    where?: ServiceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTickets to fetch.
     */
    orderBy?: ServiceTicketOrderByWithRelationInput | ServiceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTickets.
     */
    cursor?: ServiceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTickets.
     */
    distinct?: ServiceTicketScalarFieldEnum | ServiceTicketScalarFieldEnum[]
  }

  /**
   * ServiceTicket findFirstOrThrow
   */
  export type ServiceTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTicket to fetch.
     */
    where?: ServiceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTickets to fetch.
     */
    orderBy?: ServiceTicketOrderByWithRelationInput | ServiceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTickets.
     */
    cursor?: ServiceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTickets.
     */
    distinct?: ServiceTicketScalarFieldEnum | ServiceTicketScalarFieldEnum[]
  }

  /**
   * ServiceTicket findMany
   */
  export type ServiceTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTickets to fetch.
     */
    where?: ServiceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTickets to fetch.
     */
    orderBy?: ServiceTicketOrderByWithRelationInput | ServiceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTickets.
     */
    cursor?: ServiceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTickets.
     */
    skip?: number
    distinct?: ServiceTicketScalarFieldEnum | ServiceTicketScalarFieldEnum[]
  }

  /**
   * ServiceTicket create
   */
  export type ServiceTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceTicket.
     */
    data: XOR<ServiceTicketCreateInput, ServiceTicketUncheckedCreateInput>
  }

  /**
   * ServiceTicket createMany
   */
  export type ServiceTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTickets.
     */
    data: ServiceTicketCreateManyInput | ServiceTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTicket createManyAndReturn
   */
  export type ServiceTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceTickets.
     */
    data: ServiceTicketCreateManyInput | ServiceTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceTicket update
   */
  export type ServiceTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceTicket.
     */
    data: XOR<ServiceTicketUpdateInput, ServiceTicketUncheckedUpdateInput>
    /**
     * Choose, which ServiceTicket to update.
     */
    where: ServiceTicketWhereUniqueInput
  }

  /**
   * ServiceTicket updateMany
   */
  export type ServiceTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTickets.
     */
    data: XOR<ServiceTicketUpdateManyMutationInput, ServiceTicketUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTickets to update
     */
    where?: ServiceTicketWhereInput
  }

  /**
   * ServiceTicket upsert
   */
  export type ServiceTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceTicket to update in case it exists.
     */
    where: ServiceTicketWhereUniqueInput
    /**
     * In case the ServiceTicket found by the `where` argument doesn't exist, create a new ServiceTicket with this data.
     */
    create: XOR<ServiceTicketCreateInput, ServiceTicketUncheckedCreateInput>
    /**
     * In case the ServiceTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTicketUpdateInput, ServiceTicketUncheckedUpdateInput>
  }

  /**
   * ServiceTicket delete
   */
  export type ServiceTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    /**
     * Filter which ServiceTicket to delete.
     */
    where: ServiceTicketWhereUniqueInput
  }

  /**
   * ServiceTicket deleteMany
   */
  export type ServiceTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTickets to delete
     */
    where?: ServiceTicketWhereInput
  }

  /**
   * ServiceTicket.technician
   */
  export type ServiceTicket$technicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * ServiceTicket.parts
   */
  export type ServiceTicket$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    where?: ServicePartWhereInput
    orderBy?: ServicePartOrderByWithRelationInput | ServicePartOrderByWithRelationInput[]
    cursor?: ServicePartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePartScalarFieldEnum | ServicePartScalarFieldEnum[]
  }

  /**
   * ServiceTicket.history
   */
  export type ServiceTicket$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    where?: ServiceHistoryWhereInput
    orderBy?: ServiceHistoryOrderByWithRelationInput | ServiceHistoryOrderByWithRelationInput[]
    cursor?: ServiceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceHistoryScalarFieldEnum | ServiceHistoryScalarFieldEnum[]
  }

  /**
   * ServiceTicket without action
   */
  export type ServiceTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
  }


  /**
   * Model ServicePart
   */

  export type AggregateServicePart = {
    _count: ServicePartCountAggregateOutputType | null
    _avg: ServicePartAvgAggregateOutputType | null
    _sum: ServicePartSumAggregateOutputType | null
    _min: ServicePartMinAggregateOutputType | null
    _max: ServicePartMaxAggregateOutputType | null
  }

  export type ServicePartAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type ServicePartSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type ServicePartMinAggregateOutputType = {
    id: string | null
    serviceTicketId: string | null
    productId: string | null
    quantity: number | null
    price: Decimal | null
  }

  export type ServicePartMaxAggregateOutputType = {
    id: string | null
    serviceTicketId: string | null
    productId: string | null
    quantity: number | null
    price: Decimal | null
  }

  export type ServicePartCountAggregateOutputType = {
    id: number
    serviceTicketId: number
    productId: number
    quantity: number
    price: number
    _all: number
  }


  export type ServicePartAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type ServicePartSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type ServicePartMinAggregateInputType = {
    id?: true
    serviceTicketId?: true
    productId?: true
    quantity?: true
    price?: true
  }

  export type ServicePartMaxAggregateInputType = {
    id?: true
    serviceTicketId?: true
    productId?: true
    quantity?: true
    price?: true
  }

  export type ServicePartCountAggregateInputType = {
    id?: true
    serviceTicketId?: true
    productId?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type ServicePartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePart to aggregate.
     */
    where?: ServicePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParts to fetch.
     */
    orderBy?: ServicePartOrderByWithRelationInput | ServicePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceParts
    **/
    _count?: true | ServicePartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicePartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicePartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePartMaxAggregateInputType
  }

  export type GetServicePartAggregateType<T extends ServicePartAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePart[P]>
      : GetScalarType<T[P], AggregateServicePart[P]>
  }




  export type ServicePartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePartWhereInput
    orderBy?: ServicePartOrderByWithAggregationInput | ServicePartOrderByWithAggregationInput[]
    by: ServicePartScalarFieldEnum[] | ServicePartScalarFieldEnum
    having?: ServicePartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePartCountAggregateInputType | true
    _avg?: ServicePartAvgAggregateInputType
    _sum?: ServicePartSumAggregateInputType
    _min?: ServicePartMinAggregateInputType
    _max?: ServicePartMaxAggregateInputType
  }

  export type ServicePartGroupByOutputType = {
    id: string
    serviceTicketId: string
    productId: string
    quantity: number
    price: Decimal
    _count: ServicePartCountAggregateOutputType | null
    _avg: ServicePartAvgAggregateOutputType | null
    _sum: ServicePartSumAggregateOutputType | null
    _min: ServicePartMinAggregateOutputType | null
    _max: ServicePartMaxAggregateOutputType | null
  }

  type GetServicePartGroupByPayload<T extends ServicePartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePartGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePartGroupByOutputType[P]>
        }
      >
    >


  export type ServicePartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceTicketId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePart"]>

  export type ServicePartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceTicketId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePart"]>

  export type ServicePartSelectScalar = {
    id?: boolean
    serviceTicketId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type ServicePartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ServicePartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ServicePartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePart"
    objects: {
      serviceTicket: Prisma.$ServiceTicketPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceTicketId: string
      productId: string
      quantity: number
      price: Prisma.Decimal
    }, ExtArgs["result"]["servicePart"]>
    composites: {}
  }

  type ServicePartGetPayload<S extends boolean | null | undefined | ServicePartDefaultArgs> = $Result.GetResult<Prisma.$ServicePartPayload, S>

  type ServicePartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicePartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicePartCountAggregateInputType | true
    }

  export interface ServicePartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePart'], meta: { name: 'ServicePart' } }
    /**
     * Find zero or one ServicePart that matches the filter.
     * @param {ServicePartFindUniqueArgs} args - Arguments to find a ServicePart
     * @example
     * // Get one ServicePart
     * const servicePart = await prisma.servicePart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePartFindUniqueArgs>(args: SelectSubset<T, ServicePartFindUniqueArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServicePart that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicePartFindUniqueOrThrowArgs} args - Arguments to find a ServicePart
     * @example
     * // Get one ServicePart
     * const servicePart = await prisma.servicePart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePartFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServicePart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePartFindFirstArgs} args - Arguments to find a ServicePart
     * @example
     * // Get one ServicePart
     * const servicePart = await prisma.servicePart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePartFindFirstArgs>(args?: SelectSubset<T, ServicePartFindFirstArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServicePart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePartFindFirstOrThrowArgs} args - Arguments to find a ServicePart
     * @example
     * // Get one ServicePart
     * const servicePart = await prisma.servicePart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePartFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePartFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceParts
     * const serviceParts = await prisma.servicePart.findMany()
     * 
     * // Get first 10 ServiceParts
     * const serviceParts = await prisma.servicePart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePartWithIdOnly = await prisma.servicePart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePartFindManyArgs>(args?: SelectSubset<T, ServicePartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServicePart.
     * @param {ServicePartCreateArgs} args - Arguments to create a ServicePart.
     * @example
     * // Create one ServicePart
     * const ServicePart = await prisma.servicePart.create({
     *   data: {
     *     // ... data to create a ServicePart
     *   }
     * })
     * 
     */
    create<T extends ServicePartCreateArgs>(args: SelectSubset<T, ServicePartCreateArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceParts.
     * @param {ServicePartCreateManyArgs} args - Arguments to create many ServiceParts.
     * @example
     * // Create many ServiceParts
     * const servicePart = await prisma.servicePart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePartCreateManyArgs>(args?: SelectSubset<T, ServicePartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceParts and returns the data saved in the database.
     * @param {ServicePartCreateManyAndReturnArgs} args - Arguments to create many ServiceParts.
     * @example
     * // Create many ServiceParts
     * const servicePart = await prisma.servicePart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceParts and only return the `id`
     * const servicePartWithIdOnly = await prisma.servicePart.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePartCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServicePart.
     * @param {ServicePartDeleteArgs} args - Arguments to delete one ServicePart.
     * @example
     * // Delete one ServicePart
     * const ServicePart = await prisma.servicePart.delete({
     *   where: {
     *     // ... filter to delete one ServicePart
     *   }
     * })
     * 
     */
    delete<T extends ServicePartDeleteArgs>(args: SelectSubset<T, ServicePartDeleteArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServicePart.
     * @param {ServicePartUpdateArgs} args - Arguments to update one ServicePart.
     * @example
     * // Update one ServicePart
     * const servicePart = await prisma.servicePart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePartUpdateArgs>(args: SelectSubset<T, ServicePartUpdateArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceParts.
     * @param {ServicePartDeleteManyArgs} args - Arguments to filter ServiceParts to delete.
     * @example
     * // Delete a few ServiceParts
     * const { count } = await prisma.servicePart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePartDeleteManyArgs>(args?: SelectSubset<T, ServicePartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceParts
     * const servicePart = await prisma.servicePart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePartUpdateManyArgs>(args: SelectSubset<T, ServicePartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicePart.
     * @param {ServicePartUpsertArgs} args - Arguments to update or create a ServicePart.
     * @example
     * // Update or create a ServicePart
     * const servicePart = await prisma.servicePart.upsert({
     *   create: {
     *     // ... data to create a ServicePart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePart we want to update
     *   }
     * })
     */
    upsert<T extends ServicePartUpsertArgs>(args: SelectSubset<T, ServicePartUpsertArgs<ExtArgs>>): Prisma__ServicePartClient<$Result.GetResult<Prisma.$ServicePartPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePartCountArgs} args - Arguments to filter ServiceParts to count.
     * @example
     * // Count the number of ServiceParts
     * const count = await prisma.servicePart.count({
     *   where: {
     *     // ... the filter for the ServiceParts we want to count
     *   }
     * })
    **/
    count<T extends ServicePartCountArgs>(
      args?: Subset<T, ServicePartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePartAggregateArgs>(args: Subset<T, ServicePartAggregateArgs>): Prisma.PrismaPromise<GetServicePartAggregateType<T>>

    /**
     * Group by ServicePart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePartGroupByArgs['orderBy'] }
        : { orderBy?: ServicePartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePart model
   */
  readonly fields: ServicePartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceTicket<T extends ServiceTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTicketDefaultArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePart model
   */ 
  interface ServicePartFieldRefs {
    readonly id: FieldRef<"ServicePart", 'String'>
    readonly serviceTicketId: FieldRef<"ServicePart", 'String'>
    readonly productId: FieldRef<"ServicePart", 'String'>
    readonly quantity: FieldRef<"ServicePart", 'Int'>
    readonly price: FieldRef<"ServicePart", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ServicePart findUnique
   */
  export type ServicePartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * Filter, which ServicePart to fetch.
     */
    where: ServicePartWhereUniqueInput
  }

  /**
   * ServicePart findUniqueOrThrow
   */
  export type ServicePartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * Filter, which ServicePart to fetch.
     */
    where: ServicePartWhereUniqueInput
  }

  /**
   * ServicePart findFirst
   */
  export type ServicePartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * Filter, which ServicePart to fetch.
     */
    where?: ServicePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParts to fetch.
     */
    orderBy?: ServicePartOrderByWithRelationInput | ServicePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceParts.
     */
    cursor?: ServicePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceParts.
     */
    distinct?: ServicePartScalarFieldEnum | ServicePartScalarFieldEnum[]
  }

  /**
   * ServicePart findFirstOrThrow
   */
  export type ServicePartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * Filter, which ServicePart to fetch.
     */
    where?: ServicePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParts to fetch.
     */
    orderBy?: ServicePartOrderByWithRelationInput | ServicePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceParts.
     */
    cursor?: ServicePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceParts.
     */
    distinct?: ServicePartScalarFieldEnum | ServicePartScalarFieldEnum[]
  }

  /**
   * ServicePart findMany
   */
  export type ServicePartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * Filter, which ServiceParts to fetch.
     */
    where?: ServicePartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParts to fetch.
     */
    orderBy?: ServicePartOrderByWithRelationInput | ServicePartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceParts.
     */
    cursor?: ServicePartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParts.
     */
    skip?: number
    distinct?: ServicePartScalarFieldEnum | ServicePartScalarFieldEnum[]
  }

  /**
   * ServicePart create
   */
  export type ServicePartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePart.
     */
    data: XOR<ServicePartCreateInput, ServicePartUncheckedCreateInput>
  }

  /**
   * ServicePart createMany
   */
  export type ServicePartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceParts.
     */
    data: ServicePartCreateManyInput | ServicePartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePart createManyAndReturn
   */
  export type ServicePartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceParts.
     */
    data: ServicePartCreateManyInput | ServicePartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePart update
   */
  export type ServicePartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePart.
     */
    data: XOR<ServicePartUpdateInput, ServicePartUncheckedUpdateInput>
    /**
     * Choose, which ServicePart to update.
     */
    where: ServicePartWhereUniqueInput
  }

  /**
   * ServicePart updateMany
   */
  export type ServicePartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceParts.
     */
    data: XOR<ServicePartUpdateManyMutationInput, ServicePartUncheckedUpdateManyInput>
    /**
     * Filter which ServiceParts to update
     */
    where?: ServicePartWhereInput
  }

  /**
   * ServicePart upsert
   */
  export type ServicePartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePart to update in case it exists.
     */
    where: ServicePartWhereUniqueInput
    /**
     * In case the ServicePart found by the `where` argument doesn't exist, create a new ServicePart with this data.
     */
    create: XOR<ServicePartCreateInput, ServicePartUncheckedCreateInput>
    /**
     * In case the ServicePart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePartUpdateInput, ServicePartUncheckedUpdateInput>
  }

  /**
   * ServicePart delete
   */
  export type ServicePartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
    /**
     * Filter which ServicePart to delete.
     */
    where: ServicePartWhereUniqueInput
  }

  /**
   * ServicePart deleteMany
   */
  export type ServicePartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceParts to delete
     */
    where?: ServicePartWhereInput
  }

  /**
   * ServicePart without action
   */
  export type ServicePartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePart
     */
    select?: ServicePartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePartInclude<ExtArgs> | null
  }


  /**
   * Model ServiceHistory
   */

  export type AggregateServiceHistory = {
    _count: ServiceHistoryCountAggregateOutputType | null
    _min: ServiceHistoryMinAggregateOutputType | null
    _max: ServiceHistoryMaxAggregateOutputType | null
  }

  export type ServiceHistoryMinAggregateOutputType = {
    id: string | null
    serviceTicketId: string | null
    status: $Enums.ServiceStatus | null
    note: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type ServiceHistoryMaxAggregateOutputType = {
    id: string | null
    serviceTicketId: string | null
    status: $Enums.ServiceStatus | null
    note: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type ServiceHistoryCountAggregateOutputType = {
    id: number
    serviceTicketId: number
    status: number
    note: number
    changedBy: number
    createdAt: number
    _all: number
  }


  export type ServiceHistoryMinAggregateInputType = {
    id?: true
    serviceTicketId?: true
    status?: true
    note?: true
    changedBy?: true
    createdAt?: true
  }

  export type ServiceHistoryMaxAggregateInputType = {
    id?: true
    serviceTicketId?: true
    status?: true
    note?: true
    changedBy?: true
    createdAt?: true
  }

  export type ServiceHistoryCountAggregateInputType = {
    id?: true
    serviceTicketId?: true
    status?: true
    note?: true
    changedBy?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceHistory to aggregate.
     */
    where?: ServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceHistories to fetch.
     */
    orderBy?: ServiceHistoryOrderByWithRelationInput | ServiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceHistories
    **/
    _count?: true | ServiceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceHistoryMaxAggregateInputType
  }

  export type GetServiceHistoryAggregateType<T extends ServiceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceHistory[P]>
      : GetScalarType<T[P], AggregateServiceHistory[P]>
  }




  export type ServiceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceHistoryWhereInput
    orderBy?: ServiceHistoryOrderByWithAggregationInput | ServiceHistoryOrderByWithAggregationInput[]
    by: ServiceHistoryScalarFieldEnum[] | ServiceHistoryScalarFieldEnum
    having?: ServiceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceHistoryCountAggregateInputType | true
    _min?: ServiceHistoryMinAggregateInputType
    _max?: ServiceHistoryMaxAggregateInputType
  }

  export type ServiceHistoryGroupByOutputType = {
    id: string
    serviceTicketId: string
    status: $Enums.ServiceStatus
    note: string | null
    changedBy: string | null
    createdAt: Date
    _count: ServiceHistoryCountAggregateOutputType | null
    _min: ServiceHistoryMinAggregateOutputType | null
    _max: ServiceHistoryMaxAggregateOutputType | null
  }

  type GetServiceHistoryGroupByPayload<T extends ServiceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ServiceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceTicketId?: boolean
    status?: boolean
    note?: boolean
    changedBy?: boolean
    createdAt?: boolean
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceHistory"]>

  export type ServiceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceTicketId?: boolean
    status?: boolean
    note?: boolean
    changedBy?: boolean
    createdAt?: boolean
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceHistory"]>

  export type ServiceHistorySelectScalar = {
    id?: boolean
    serviceTicketId?: boolean
    status?: boolean
    note?: boolean
    changedBy?: boolean
    createdAt?: boolean
  }

  export type ServiceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
  }
  export type ServiceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceTicket?: boolean | ServiceTicketDefaultArgs<ExtArgs>
  }

  export type $ServiceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceHistory"
    objects: {
      serviceTicket: Prisma.$ServiceTicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceTicketId: string
      status: $Enums.ServiceStatus
      note: string | null
      changedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["serviceHistory"]>
    composites: {}
  }

  type ServiceHistoryGetPayload<S extends boolean | null | undefined | ServiceHistoryDefaultArgs> = $Result.GetResult<Prisma.$ServiceHistoryPayload, S>

  type ServiceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceHistoryCountAggregateInputType | true
    }

  export interface ServiceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceHistory'], meta: { name: 'ServiceHistory' } }
    /**
     * Find zero or one ServiceHistory that matches the filter.
     * @param {ServiceHistoryFindUniqueArgs} args - Arguments to find a ServiceHistory
     * @example
     * // Get one ServiceHistory
     * const serviceHistory = await prisma.serviceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceHistoryFindUniqueArgs>(args: SelectSubset<T, ServiceHistoryFindUniqueArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceHistoryFindUniqueOrThrowArgs} args - Arguments to find a ServiceHistory
     * @example
     * // Get one ServiceHistory
     * const serviceHistory = await prisma.serviceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceHistoryFindFirstArgs} args - Arguments to find a ServiceHistory
     * @example
     * // Get one ServiceHistory
     * const serviceHistory = await prisma.serviceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceHistoryFindFirstArgs>(args?: SelectSubset<T, ServiceHistoryFindFirstArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceHistoryFindFirstOrThrowArgs} args - Arguments to find a ServiceHistory
     * @example
     * // Get one ServiceHistory
     * const serviceHistory = await prisma.serviceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceHistories
     * const serviceHistories = await prisma.serviceHistory.findMany()
     * 
     * // Get first 10 ServiceHistories
     * const serviceHistories = await prisma.serviceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceHistoryWithIdOnly = await prisma.serviceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceHistoryFindManyArgs>(args?: SelectSubset<T, ServiceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceHistory.
     * @param {ServiceHistoryCreateArgs} args - Arguments to create a ServiceHistory.
     * @example
     * // Create one ServiceHistory
     * const ServiceHistory = await prisma.serviceHistory.create({
     *   data: {
     *     // ... data to create a ServiceHistory
     *   }
     * })
     * 
     */
    create<T extends ServiceHistoryCreateArgs>(args: SelectSubset<T, ServiceHistoryCreateArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceHistories.
     * @param {ServiceHistoryCreateManyArgs} args - Arguments to create many ServiceHistories.
     * @example
     * // Create many ServiceHistories
     * const serviceHistory = await prisma.serviceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceHistoryCreateManyArgs>(args?: SelectSubset<T, ServiceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceHistories and returns the data saved in the database.
     * @param {ServiceHistoryCreateManyAndReturnArgs} args - Arguments to create many ServiceHistories.
     * @example
     * // Create many ServiceHistories
     * const serviceHistory = await prisma.serviceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceHistories and only return the `id`
     * const serviceHistoryWithIdOnly = await prisma.serviceHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceHistory.
     * @param {ServiceHistoryDeleteArgs} args - Arguments to delete one ServiceHistory.
     * @example
     * // Delete one ServiceHistory
     * const ServiceHistory = await prisma.serviceHistory.delete({
     *   where: {
     *     // ... filter to delete one ServiceHistory
     *   }
     * })
     * 
     */
    delete<T extends ServiceHistoryDeleteArgs>(args: SelectSubset<T, ServiceHistoryDeleteArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceHistory.
     * @param {ServiceHistoryUpdateArgs} args - Arguments to update one ServiceHistory.
     * @example
     * // Update one ServiceHistory
     * const serviceHistory = await prisma.serviceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceHistoryUpdateArgs>(args: SelectSubset<T, ServiceHistoryUpdateArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceHistories.
     * @param {ServiceHistoryDeleteManyArgs} args - Arguments to filter ServiceHistories to delete.
     * @example
     * // Delete a few ServiceHistories
     * const { count } = await prisma.serviceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceHistoryDeleteManyArgs>(args?: SelectSubset<T, ServiceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceHistories
     * const serviceHistory = await prisma.serviceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceHistoryUpdateManyArgs>(args: SelectSubset<T, ServiceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceHistory.
     * @param {ServiceHistoryUpsertArgs} args - Arguments to update or create a ServiceHistory.
     * @example
     * // Update or create a ServiceHistory
     * const serviceHistory = await prisma.serviceHistory.upsert({
     *   create: {
     *     // ... data to create a ServiceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceHistory we want to update
     *   }
     * })
     */
    upsert<T extends ServiceHistoryUpsertArgs>(args: SelectSubset<T, ServiceHistoryUpsertArgs<ExtArgs>>): Prisma__ServiceHistoryClient<$Result.GetResult<Prisma.$ServiceHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceHistoryCountArgs} args - Arguments to filter ServiceHistories to count.
     * @example
     * // Count the number of ServiceHistories
     * const count = await prisma.serviceHistory.count({
     *   where: {
     *     // ... the filter for the ServiceHistories we want to count
     *   }
     * })
    **/
    count<T extends ServiceHistoryCountArgs>(
      args?: Subset<T, ServiceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceHistoryAggregateArgs>(args: Subset<T, ServiceHistoryAggregateArgs>): Prisma.PrismaPromise<GetServiceHistoryAggregateType<T>>

    /**
     * Group by ServiceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ServiceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceHistory model
   */
  readonly fields: ServiceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceTicket<T extends ServiceTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTicketDefaultArgs<ExtArgs>>): Prisma__ServiceTicketClient<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceHistory model
   */ 
  interface ServiceHistoryFieldRefs {
    readonly id: FieldRef<"ServiceHistory", 'String'>
    readonly serviceTicketId: FieldRef<"ServiceHistory", 'String'>
    readonly status: FieldRef<"ServiceHistory", 'ServiceStatus'>
    readonly note: FieldRef<"ServiceHistory", 'String'>
    readonly changedBy: FieldRef<"ServiceHistory", 'String'>
    readonly createdAt: FieldRef<"ServiceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceHistory findUnique
   */
  export type ServiceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceHistory to fetch.
     */
    where: ServiceHistoryWhereUniqueInput
  }

  /**
   * ServiceHistory findUniqueOrThrow
   */
  export type ServiceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceHistory to fetch.
     */
    where: ServiceHistoryWhereUniqueInput
  }

  /**
   * ServiceHistory findFirst
   */
  export type ServiceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceHistory to fetch.
     */
    where?: ServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceHistories to fetch.
     */
    orderBy?: ServiceHistoryOrderByWithRelationInput | ServiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceHistories.
     */
    cursor?: ServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceHistories.
     */
    distinct?: ServiceHistoryScalarFieldEnum | ServiceHistoryScalarFieldEnum[]
  }

  /**
   * ServiceHistory findFirstOrThrow
   */
  export type ServiceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceHistory to fetch.
     */
    where?: ServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceHistories to fetch.
     */
    orderBy?: ServiceHistoryOrderByWithRelationInput | ServiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceHistories.
     */
    cursor?: ServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceHistories.
     */
    distinct?: ServiceHistoryScalarFieldEnum | ServiceHistoryScalarFieldEnum[]
  }

  /**
   * ServiceHistory findMany
   */
  export type ServiceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ServiceHistories to fetch.
     */
    where?: ServiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceHistories to fetch.
     */
    orderBy?: ServiceHistoryOrderByWithRelationInput | ServiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceHistories.
     */
    cursor?: ServiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceHistories.
     */
    skip?: number
    distinct?: ServiceHistoryScalarFieldEnum | ServiceHistoryScalarFieldEnum[]
  }

  /**
   * ServiceHistory create
   */
  export type ServiceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceHistory.
     */
    data: XOR<ServiceHistoryCreateInput, ServiceHistoryUncheckedCreateInput>
  }

  /**
   * ServiceHistory createMany
   */
  export type ServiceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceHistories.
     */
    data: ServiceHistoryCreateManyInput | ServiceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceHistory createManyAndReturn
   */
  export type ServiceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceHistories.
     */
    data: ServiceHistoryCreateManyInput | ServiceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceHistory update
   */
  export type ServiceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceHistory.
     */
    data: XOR<ServiceHistoryUpdateInput, ServiceHistoryUncheckedUpdateInput>
    /**
     * Choose, which ServiceHistory to update.
     */
    where: ServiceHistoryWhereUniqueInput
  }

  /**
   * ServiceHistory updateMany
   */
  export type ServiceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceHistories.
     */
    data: XOR<ServiceHistoryUpdateManyMutationInput, ServiceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ServiceHistories to update
     */
    where?: ServiceHistoryWhereInput
  }

  /**
   * ServiceHistory upsert
   */
  export type ServiceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceHistory to update in case it exists.
     */
    where: ServiceHistoryWhereUniqueInput
    /**
     * In case the ServiceHistory found by the `where` argument doesn't exist, create a new ServiceHistory with this data.
     */
    create: XOR<ServiceHistoryCreateInput, ServiceHistoryUncheckedCreateInput>
    /**
     * In case the ServiceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceHistoryUpdateInput, ServiceHistoryUncheckedUpdateInput>
  }

  /**
   * ServiceHistory delete
   */
  export type ServiceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
    /**
     * Filter which ServiceHistory to delete.
     */
    where: ServiceHistoryWhereUniqueInput
  }

  /**
   * ServiceHistory deleteMany
   */
  export type ServiceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceHistories to delete
     */
    where?: ServiceHistoryWhereInput
  }

  /**
   * ServiceHistory without action
   */
  export type ServiceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceHistory
     */
    select?: ServiceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    salary: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    salary: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    position: string | null
    salary: Decimal | null
    hireDate: Date | null
    createdAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    position: string | null
    salary: Decimal | null
    hireDate: Date | null
    createdAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    position: number
    salary: number
    hireDate: number
    createdAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    salary?: true
  }

  export type EmployeeSumAggregateInputType = {
    salary?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    salary?: true
    hireDate?: true
    createdAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    salary?: true
    hireDate?: true
    createdAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    position?: true
    salary?: true
    hireDate?: true
    createdAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    position: string | null
    salary: Decimal | null
    hireDate: Date | null
    createdAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    salary?: boolean
    hireDate?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tickets?: boolean | Employee$ticketsArgs<ExtArgs>
    posSessions?: boolean | Employee$posSessionsArgs<ExtArgs>
    payrolls?: boolean | Employee$payrollsArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    salary?: boolean
    hireDate?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    position?: boolean
    salary?: boolean
    hireDate?: boolean
    createdAt?: boolean
  }

  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tickets?: boolean | Employee$ticketsArgs<ExtArgs>
    posSessions?: boolean | Employee$posSessionsArgs<ExtArgs>
    payrolls?: boolean | Employee$payrollsArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      tickets: Prisma.$ServiceTicketPayload<ExtArgs>[]
      posSessions: Prisma.$PosSessionPayload<ExtArgs>[]
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
      leaves: Prisma.$LeaveRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      position: string | null
      salary: Prisma.Decimal | null
      hireDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tickets<T extends Employee$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTicketPayload<ExtArgs>, T, "findMany"> | Null>
    posSessions<T extends Employee$posSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$posSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosSessionPayload<ExtArgs>, T, "findMany"> | Null>
    payrolls<T extends Employee$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany"> | Null>
    leaves<T extends Employee$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly tenantId: FieldRef<"Employee", 'String'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly salary: FieldRef<"Employee", 'Decimal'>
    readonly hireDate: FieldRef<"Employee", 'DateTime'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.tickets
   */
  export type Employee$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTicket
     */
    select?: ServiceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTicketInclude<ExtArgs> | null
    where?: ServiceTicketWhereInput
    orderBy?: ServiceTicketOrderByWithRelationInput | ServiceTicketOrderByWithRelationInput[]
    cursor?: ServiceTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTicketScalarFieldEnum | ServiceTicketScalarFieldEnum[]
  }

  /**
   * Employee.posSessions
   */
  export type Employee$posSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosSession
     */
    select?: PosSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosSessionInclude<ExtArgs> | null
    where?: PosSessionWhereInput
    orderBy?: PosSessionOrderByWithRelationInput | PosSessionOrderByWithRelationInput[]
    cursor?: PosSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosSessionScalarFieldEnum | PosSessionScalarFieldEnum[]
  }

  /**
   * Employee.payrolls
   */
  export type Employee$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Employee.leaves
   */
  export type Employee$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PayrollSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    month: string | null
    amount: Decimal | null
    isPaid: boolean | null
    paidAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    month: string | null
    amount: Decimal | null
    isPaid: boolean | null
    paidAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    employeeId: number
    month: number
    amount: number
    isPaid: number
    paidAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    amount?: true
  }

  export type PayrollSumAggregateInputType = {
    amount?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    amount?: true
    isPaid?: true
    paidAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    amount?: true
    isPaid?: true
    paidAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    employeeId?: true
    month?: true
    amount?: true
    isPaid?: true
    paidAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    employeeId: string
    month: string
    amount: Decimal
    isPaid: boolean
    paidAt: Date | null
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    month?: boolean
    amount?: boolean
    isPaid?: boolean
    paidAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    month?: boolean
    amount?: boolean
    isPaid?: boolean
    paidAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectScalar = {
    id?: boolean
    employeeId?: boolean
    month?: boolean
    amount?: boolean
    isPaid?: boolean
    paidAt?: boolean
  }

  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      month: string
      amount: Prisma.Decimal
      isPaid: boolean
      paidAt: Date | null
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payrolls and returns the data saved in the database.
     * @param {PayrollCreateManyAndReturnArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */ 
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly employeeId: FieldRef<"Payroll", 'String'>
    readonly month: FieldRef<"Payroll", 'String'>
    readonly amount: FieldRef<"Payroll", 'Decimal'>
    readonly isPaid: FieldRef<"Payroll", 'Boolean'>
    readonly paidAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll createManyAndReturn
   */
  export type PayrollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.LeaveStatus | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.LeaveStatus | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    employeeId: number
    startDate: number
    endDate: number
    reason: number
    status: number
    _all: number
  }


  export type LeaveRequestMinAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    employeeId: string
    startDate: Date
    endDate: Date
    reason: string | null
    status: $Enums.LeaveStatus
    _count: LeaveRequestCountAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
  }

  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      startDate: Date
      endDate: Date
      reason: string | null
      status: $Enums.LeaveStatus
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */ 
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly employeeId: FieldRef<"LeaveRequest", 'String'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly status: FieldRef<"LeaveRequest", 'LeaveStatus'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */ 
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'Json'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ModuleSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    icon: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    icon: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    icon: number
    isActive: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ModuleSumAggregateInputType = {
    sortOrder?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    icon: string | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    packages?: boolean | Module$packagesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    packages?: boolean | Module$packagesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      packages: Prisma.$PackageModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      icon: string | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    packages<T extends Module$packagesArgs<ExtArgs> = {}>(args?: Subset<T, Module$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly code: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly icon: FieldRef<"Module", 'String'>
    readonly isActive: FieldRef<"Module", 'Boolean'>
    readonly sortOrder: FieldRef<"Module", 'Int'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
  }

  /**
   * Module.packages
   */
  export type Module$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    where?: PackageModuleWhereInput
    orderBy?: PackageModuleOrderByWithRelationInput | PackageModuleOrderByWithRelationInput[]
    cursor?: PackageModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageModuleScalarFieldEnum | PackageModuleScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model PackageModule
   */

  export type AggregatePackageModule = {
    _count: PackageModuleCountAggregateOutputType | null
    _min: PackageModuleMinAggregateOutputType | null
    _max: PackageModuleMaxAggregateOutputType | null
  }

  export type PackageModuleMinAggregateOutputType = {
    id: string | null
    packageId: string | null
    moduleId: string | null
  }

  export type PackageModuleMaxAggregateOutputType = {
    id: string | null
    packageId: string | null
    moduleId: string | null
  }

  export type PackageModuleCountAggregateOutputType = {
    id: number
    packageId: number
    moduleId: number
    _all: number
  }


  export type PackageModuleMinAggregateInputType = {
    id?: true
    packageId?: true
    moduleId?: true
  }

  export type PackageModuleMaxAggregateInputType = {
    id?: true
    packageId?: true
    moduleId?: true
  }

  export type PackageModuleCountAggregateInputType = {
    id?: true
    packageId?: true
    moduleId?: true
    _all?: true
  }

  export type PackageModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageModule to aggregate.
     */
    where?: PackageModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageModules to fetch.
     */
    orderBy?: PackageModuleOrderByWithRelationInput | PackageModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageModules
    **/
    _count?: true | PackageModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageModuleMaxAggregateInputType
  }

  export type GetPackageModuleAggregateType<T extends PackageModuleAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageModule[P]>
      : GetScalarType<T[P], AggregatePackageModule[P]>
  }




  export type PackageModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageModuleWhereInput
    orderBy?: PackageModuleOrderByWithAggregationInput | PackageModuleOrderByWithAggregationInput[]
    by: PackageModuleScalarFieldEnum[] | PackageModuleScalarFieldEnum
    having?: PackageModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageModuleCountAggregateInputType | true
    _min?: PackageModuleMinAggregateInputType
    _max?: PackageModuleMaxAggregateInputType
  }

  export type PackageModuleGroupByOutputType = {
    id: string
    packageId: string
    moduleId: string
    _count: PackageModuleCountAggregateOutputType | null
    _min: PackageModuleMinAggregateOutputType | null
    _max: PackageModuleMaxAggregateOutputType | null
  }

  type GetPackageModuleGroupByPayload<T extends PackageModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageModuleGroupByOutputType[P]>
            : GetScalarType<T[P], PackageModuleGroupByOutputType[P]>
        }
      >
    >


  export type PackageModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    moduleId?: boolean
    package?: boolean | SubscriptionPackageDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageModule"]>

  export type PackageModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    moduleId?: boolean
    package?: boolean | SubscriptionPackageDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packageModule"]>

  export type PackageModuleSelectScalar = {
    id?: boolean
    packageId?: boolean
    moduleId?: boolean
  }

  export type PackageModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | SubscriptionPackageDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type PackageModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | SubscriptionPackageDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $PackageModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageModule"
    objects: {
      package: Prisma.$SubscriptionPackagePayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      packageId: string
      moduleId: string
    }, ExtArgs["result"]["packageModule"]>
    composites: {}
  }

  type PackageModuleGetPayload<S extends boolean | null | undefined | PackageModuleDefaultArgs> = $Result.GetResult<Prisma.$PackageModulePayload, S>

  type PackageModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackageModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackageModuleCountAggregateInputType | true
    }

  export interface PackageModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageModule'], meta: { name: 'PackageModule' } }
    /**
     * Find zero or one PackageModule that matches the filter.
     * @param {PackageModuleFindUniqueArgs} args - Arguments to find a PackageModule
     * @example
     * // Get one PackageModule
     * const packageModule = await prisma.packageModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageModuleFindUniqueArgs>(args: SelectSubset<T, PackageModuleFindUniqueArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PackageModule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackageModuleFindUniqueOrThrowArgs} args - Arguments to find a PackageModule
     * @example
     * // Get one PackageModule
     * const packageModule = await prisma.packageModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PackageModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageModuleFindFirstArgs} args - Arguments to find a PackageModule
     * @example
     * // Get one PackageModule
     * const packageModule = await prisma.packageModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageModuleFindFirstArgs>(args?: SelectSubset<T, PackageModuleFindFirstArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PackageModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageModuleFindFirstOrThrowArgs} args - Arguments to find a PackageModule
     * @example
     * // Get one PackageModule
     * const packageModule = await prisma.packageModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PackageModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageModules
     * const packageModules = await prisma.packageModule.findMany()
     * 
     * // Get first 10 PackageModules
     * const packageModules = await prisma.packageModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageModuleWithIdOnly = await prisma.packageModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageModuleFindManyArgs>(args?: SelectSubset<T, PackageModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PackageModule.
     * @param {PackageModuleCreateArgs} args - Arguments to create a PackageModule.
     * @example
     * // Create one PackageModule
     * const PackageModule = await prisma.packageModule.create({
     *   data: {
     *     // ... data to create a PackageModule
     *   }
     * })
     * 
     */
    create<T extends PackageModuleCreateArgs>(args: SelectSubset<T, PackageModuleCreateArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PackageModules.
     * @param {PackageModuleCreateManyArgs} args - Arguments to create many PackageModules.
     * @example
     * // Create many PackageModules
     * const packageModule = await prisma.packageModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageModuleCreateManyArgs>(args?: SelectSubset<T, PackageModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackageModules and returns the data saved in the database.
     * @param {PackageModuleCreateManyAndReturnArgs} args - Arguments to create many PackageModules.
     * @example
     * // Create many PackageModules
     * const packageModule = await prisma.packageModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackageModules and only return the `id`
     * const packageModuleWithIdOnly = await prisma.packageModule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PackageModule.
     * @param {PackageModuleDeleteArgs} args - Arguments to delete one PackageModule.
     * @example
     * // Delete one PackageModule
     * const PackageModule = await prisma.packageModule.delete({
     *   where: {
     *     // ... filter to delete one PackageModule
     *   }
     * })
     * 
     */
    delete<T extends PackageModuleDeleteArgs>(args: SelectSubset<T, PackageModuleDeleteArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PackageModule.
     * @param {PackageModuleUpdateArgs} args - Arguments to update one PackageModule.
     * @example
     * // Update one PackageModule
     * const packageModule = await prisma.packageModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageModuleUpdateArgs>(args: SelectSubset<T, PackageModuleUpdateArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PackageModules.
     * @param {PackageModuleDeleteManyArgs} args - Arguments to filter PackageModules to delete.
     * @example
     * // Delete a few PackageModules
     * const { count } = await prisma.packageModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageModuleDeleteManyArgs>(args?: SelectSubset<T, PackageModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageModules
     * const packageModule = await prisma.packageModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageModuleUpdateManyArgs>(args: SelectSubset<T, PackageModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PackageModule.
     * @param {PackageModuleUpsertArgs} args - Arguments to update or create a PackageModule.
     * @example
     * // Update or create a PackageModule
     * const packageModule = await prisma.packageModule.upsert({
     *   create: {
     *     // ... data to create a PackageModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageModule we want to update
     *   }
     * })
     */
    upsert<T extends PackageModuleUpsertArgs>(args: SelectSubset<T, PackageModuleUpsertArgs<ExtArgs>>): Prisma__PackageModuleClient<$Result.GetResult<Prisma.$PackageModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PackageModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageModuleCountArgs} args - Arguments to filter PackageModules to count.
     * @example
     * // Count the number of PackageModules
     * const count = await prisma.packageModule.count({
     *   where: {
     *     // ... the filter for the PackageModules we want to count
     *   }
     * })
    **/
    count<T extends PackageModuleCountArgs>(
      args?: Subset<T, PackageModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageModuleAggregateArgs>(args: Subset<T, PackageModuleAggregateArgs>): Prisma.PrismaPromise<GetPackageModuleAggregateType<T>>

    /**
     * Group by PackageModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageModuleGroupByArgs['orderBy'] }
        : { orderBy?: PackageModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageModule model
   */
  readonly fields: PackageModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    package<T extends SubscriptionPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionPackageDefaultArgs<ExtArgs>>): Prisma__SubscriptionPackageClient<$Result.GetResult<Prisma.$SubscriptionPackagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageModule model
   */ 
  interface PackageModuleFieldRefs {
    readonly id: FieldRef<"PackageModule", 'String'>
    readonly packageId: FieldRef<"PackageModule", 'String'>
    readonly moduleId: FieldRef<"PackageModule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PackageModule findUnique
   */
  export type PackageModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * Filter, which PackageModule to fetch.
     */
    where: PackageModuleWhereUniqueInput
  }

  /**
   * PackageModule findUniqueOrThrow
   */
  export type PackageModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * Filter, which PackageModule to fetch.
     */
    where: PackageModuleWhereUniqueInput
  }

  /**
   * PackageModule findFirst
   */
  export type PackageModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * Filter, which PackageModule to fetch.
     */
    where?: PackageModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageModules to fetch.
     */
    orderBy?: PackageModuleOrderByWithRelationInput | PackageModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageModules.
     */
    cursor?: PackageModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageModules.
     */
    distinct?: PackageModuleScalarFieldEnum | PackageModuleScalarFieldEnum[]
  }

  /**
   * PackageModule findFirstOrThrow
   */
  export type PackageModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * Filter, which PackageModule to fetch.
     */
    where?: PackageModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageModules to fetch.
     */
    orderBy?: PackageModuleOrderByWithRelationInput | PackageModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageModules.
     */
    cursor?: PackageModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageModules.
     */
    distinct?: PackageModuleScalarFieldEnum | PackageModuleScalarFieldEnum[]
  }

  /**
   * PackageModule findMany
   */
  export type PackageModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * Filter, which PackageModules to fetch.
     */
    where?: PackageModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageModules to fetch.
     */
    orderBy?: PackageModuleOrderByWithRelationInput | PackageModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageModules.
     */
    cursor?: PackageModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageModules.
     */
    skip?: number
    distinct?: PackageModuleScalarFieldEnum | PackageModuleScalarFieldEnum[]
  }

  /**
   * PackageModule create
   */
  export type PackageModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a PackageModule.
     */
    data: XOR<PackageModuleCreateInput, PackageModuleUncheckedCreateInput>
  }

  /**
   * PackageModule createMany
   */
  export type PackageModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageModules.
     */
    data: PackageModuleCreateManyInput | PackageModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageModule createManyAndReturn
   */
  export type PackageModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PackageModules.
     */
    data: PackageModuleCreateManyInput | PackageModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackageModule update
   */
  export type PackageModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a PackageModule.
     */
    data: XOR<PackageModuleUpdateInput, PackageModuleUncheckedUpdateInput>
    /**
     * Choose, which PackageModule to update.
     */
    where: PackageModuleWhereUniqueInput
  }

  /**
   * PackageModule updateMany
   */
  export type PackageModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageModules.
     */
    data: XOR<PackageModuleUpdateManyMutationInput, PackageModuleUncheckedUpdateManyInput>
    /**
     * Filter which PackageModules to update
     */
    where?: PackageModuleWhereInput
  }

  /**
   * PackageModule upsert
   */
  export type PackageModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the PackageModule to update in case it exists.
     */
    where: PackageModuleWhereUniqueInput
    /**
     * In case the PackageModule found by the `where` argument doesn't exist, create a new PackageModule with this data.
     */
    create: XOR<PackageModuleCreateInput, PackageModuleUncheckedCreateInput>
    /**
     * In case the PackageModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageModuleUpdateInput, PackageModuleUncheckedUpdateInput>
  }

  /**
   * PackageModule delete
   */
  export type PackageModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
    /**
     * Filter which PackageModule to delete.
     */
    where: PackageModuleWhereUniqueInput
  }

  /**
   * PackageModule deleteMany
   */
  export type PackageModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageModules to delete
     */
    where?: PackageModuleWhereInput
  }

  /**
   * PackageModule without action
   */
  export type PackageModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageModule
     */
    select?: PackageModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageModuleInclude<ExtArgs> | null
  }


  /**
   * Model SuperAdminRole
   */

  export type AggregateSuperAdminRole = {
    _count: SuperAdminRoleCountAggregateOutputType | null
    _min: SuperAdminRoleMinAggregateOutputType | null
    _max: SuperAdminRoleMaxAggregateOutputType | null
  }

  export type SuperAdminRoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminRoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminRoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuperAdminRoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminRoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminRoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuperAdminRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminRole to aggregate.
     */
    where?: SuperAdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminRoles to fetch.
     */
    orderBy?: SuperAdminRoleOrderByWithRelationInput | SuperAdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdminRoles
    **/
    _count?: true | SuperAdminRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminRoleMaxAggregateInputType
  }

  export type GetSuperAdminRoleAggregateType<T extends SuperAdminRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdminRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdminRole[P]>
      : GetScalarType<T[P], AggregateSuperAdminRole[P]>
  }




  export type SuperAdminRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminRoleWhereInput
    orderBy?: SuperAdminRoleOrderByWithAggregationInput | SuperAdminRoleOrderByWithAggregationInput[]
    by: SuperAdminRoleScalarFieldEnum[] | SuperAdminRoleScalarFieldEnum
    having?: SuperAdminRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminRoleCountAggregateInputType | true
    _min?: SuperAdminRoleMinAggregateInputType
    _max?: SuperAdminRoleMaxAggregateInputType
  }

  export type SuperAdminRoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    permissions: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SuperAdminRoleCountAggregateOutputType | null
    _min: SuperAdminRoleMinAggregateOutputType | null
    _max: SuperAdminRoleMaxAggregateOutputType | null
  }

  type GetSuperAdminRoleGroupByPayload<T extends SuperAdminRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminRoleGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminRoleGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | SuperAdminRole$usersArgs<ExtArgs>
    _count?: boolean | SuperAdminRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdminRole"]>

  export type SuperAdminRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["superAdminRole"]>

  export type SuperAdminRoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuperAdminRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SuperAdminRole$usersArgs<ExtArgs>
    _count?: boolean | SuperAdminRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuperAdminRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SuperAdminRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdminRole"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      permissions: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["superAdminRole"]>
    composites: {}
  }

  type SuperAdminRoleGetPayload<S extends boolean | null | undefined | SuperAdminRoleDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminRolePayload, S>

  type SuperAdminRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SuperAdminRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SuperAdminRoleCountAggregateInputType | true
    }

  export interface SuperAdminRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdminRole'], meta: { name: 'SuperAdminRole' } }
    /**
     * Find zero or one SuperAdminRole that matches the filter.
     * @param {SuperAdminRoleFindUniqueArgs} args - Arguments to find a SuperAdminRole
     * @example
     * // Get one SuperAdminRole
     * const superAdminRole = await prisma.superAdminRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminRoleFindUniqueArgs>(args: SelectSubset<T, SuperAdminRoleFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SuperAdminRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SuperAdminRoleFindUniqueOrThrowArgs} args - Arguments to find a SuperAdminRole
     * @example
     * // Get one SuperAdminRole
     * const superAdminRole = await prisma.superAdminRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SuperAdminRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminRoleFindFirstArgs} args - Arguments to find a SuperAdminRole
     * @example
     * // Get one SuperAdminRole
     * const superAdminRole = await prisma.superAdminRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminRoleFindFirstArgs>(args?: SelectSubset<T, SuperAdminRoleFindFirstArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SuperAdminRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminRoleFindFirstOrThrowArgs} args - Arguments to find a SuperAdminRole
     * @example
     * // Get one SuperAdminRole
     * const superAdminRole = await prisma.superAdminRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SuperAdminRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdminRoles
     * const superAdminRoles = await prisma.superAdminRole.findMany()
     * 
     * // Get first 10 SuperAdminRoles
     * const superAdminRoles = await prisma.superAdminRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminRoleWithIdOnly = await prisma.superAdminRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminRoleFindManyArgs>(args?: SelectSubset<T, SuperAdminRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SuperAdminRole.
     * @param {SuperAdminRoleCreateArgs} args - Arguments to create a SuperAdminRole.
     * @example
     * // Create one SuperAdminRole
     * const SuperAdminRole = await prisma.superAdminRole.create({
     *   data: {
     *     // ... data to create a SuperAdminRole
     *   }
     * })
     * 
     */
    create<T extends SuperAdminRoleCreateArgs>(args: SelectSubset<T, SuperAdminRoleCreateArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SuperAdminRoles.
     * @param {SuperAdminRoleCreateManyArgs} args - Arguments to create many SuperAdminRoles.
     * @example
     * // Create many SuperAdminRoles
     * const superAdminRole = await prisma.superAdminRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminRoleCreateManyArgs>(args?: SelectSubset<T, SuperAdminRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdminRoles and returns the data saved in the database.
     * @param {SuperAdminRoleCreateManyAndReturnArgs} args - Arguments to create many SuperAdminRoles.
     * @example
     * // Create many SuperAdminRoles
     * const superAdminRole = await prisma.superAdminRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdminRoles and only return the `id`
     * const superAdminRoleWithIdOnly = await prisma.superAdminRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SuperAdminRole.
     * @param {SuperAdminRoleDeleteArgs} args - Arguments to delete one SuperAdminRole.
     * @example
     * // Delete one SuperAdminRole
     * const SuperAdminRole = await prisma.superAdminRole.delete({
     *   where: {
     *     // ... filter to delete one SuperAdminRole
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminRoleDeleteArgs>(args: SelectSubset<T, SuperAdminRoleDeleteArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SuperAdminRole.
     * @param {SuperAdminRoleUpdateArgs} args - Arguments to update one SuperAdminRole.
     * @example
     * // Update one SuperAdminRole
     * const superAdminRole = await prisma.superAdminRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminRoleUpdateArgs>(args: SelectSubset<T, SuperAdminRoleUpdateArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SuperAdminRoles.
     * @param {SuperAdminRoleDeleteManyArgs} args - Arguments to filter SuperAdminRoles to delete.
     * @example
     * // Delete a few SuperAdminRoles
     * const { count } = await prisma.superAdminRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminRoleDeleteManyArgs>(args?: SelectSubset<T, SuperAdminRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdminRoles
     * const superAdminRole = await prisma.superAdminRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminRoleUpdateManyArgs>(args: SelectSubset<T, SuperAdminRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SuperAdminRole.
     * @param {SuperAdminRoleUpsertArgs} args - Arguments to update or create a SuperAdminRole.
     * @example
     * // Update or create a SuperAdminRole
     * const superAdminRole = await prisma.superAdminRole.upsert({
     *   create: {
     *     // ... data to create a SuperAdminRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdminRole we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminRoleUpsertArgs>(args: SelectSubset<T, SuperAdminRoleUpsertArgs<ExtArgs>>): Prisma__SuperAdminRoleClient<$Result.GetResult<Prisma.$SuperAdminRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SuperAdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminRoleCountArgs} args - Arguments to filter SuperAdminRoles to count.
     * @example
     * // Count the number of SuperAdminRoles
     * const count = await prisma.superAdminRole.count({
     *   where: {
     *     // ... the filter for the SuperAdminRoles we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminRoleCountArgs>(
      args?: Subset<T, SuperAdminRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdminRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminRoleAggregateArgs>(args: Subset<T, SuperAdminRoleAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminRoleAggregateType<T>>

    /**
     * Group by SuperAdminRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminRoleGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdminRole model
   */
  readonly fields: SuperAdminRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdminRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends SuperAdminRole$usersArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdminRole$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdminRole model
   */ 
  interface SuperAdminRoleFieldRefs {
    readonly id: FieldRef<"SuperAdminRole", 'String'>
    readonly name: FieldRef<"SuperAdminRole", 'String'>
    readonly description: FieldRef<"SuperAdminRole", 'String'>
    readonly permissions: FieldRef<"SuperAdminRole", 'Json'>
    readonly createdAt: FieldRef<"SuperAdminRole", 'DateTime'>
    readonly updatedAt: FieldRef<"SuperAdminRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdminRole findUnique
   */
  export type SuperAdminRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminRole to fetch.
     */
    where: SuperAdminRoleWhereUniqueInput
  }

  /**
   * SuperAdminRole findUniqueOrThrow
   */
  export type SuperAdminRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminRole to fetch.
     */
    where: SuperAdminRoleWhereUniqueInput
  }

  /**
   * SuperAdminRole findFirst
   */
  export type SuperAdminRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminRole to fetch.
     */
    where?: SuperAdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminRoles to fetch.
     */
    orderBy?: SuperAdminRoleOrderByWithRelationInput | SuperAdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminRoles.
     */
    cursor?: SuperAdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminRoles.
     */
    distinct?: SuperAdminRoleScalarFieldEnum | SuperAdminRoleScalarFieldEnum[]
  }

  /**
   * SuperAdminRole findFirstOrThrow
   */
  export type SuperAdminRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminRole to fetch.
     */
    where?: SuperAdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminRoles to fetch.
     */
    orderBy?: SuperAdminRoleOrderByWithRelationInput | SuperAdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdminRoles.
     */
    cursor?: SuperAdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdminRoles.
     */
    distinct?: SuperAdminRoleScalarFieldEnum | SuperAdminRoleScalarFieldEnum[]
  }

  /**
   * SuperAdminRole findMany
   */
  export type SuperAdminRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdminRoles to fetch.
     */
    where?: SuperAdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdminRoles to fetch.
     */
    orderBy?: SuperAdminRoleOrderByWithRelationInput | SuperAdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdminRoles.
     */
    cursor?: SuperAdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdminRoles.
     */
    skip?: number
    distinct?: SuperAdminRoleScalarFieldEnum | SuperAdminRoleScalarFieldEnum[]
  }

  /**
   * SuperAdminRole create
   */
  export type SuperAdminRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdminRole.
     */
    data: XOR<SuperAdminRoleCreateInput, SuperAdminRoleUncheckedCreateInput>
  }

  /**
   * SuperAdminRole createMany
   */
  export type SuperAdminRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdminRoles.
     */
    data: SuperAdminRoleCreateManyInput | SuperAdminRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdminRole createManyAndReturn
   */
  export type SuperAdminRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SuperAdminRoles.
     */
    data: SuperAdminRoleCreateManyInput | SuperAdminRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdminRole update
   */
  export type SuperAdminRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdminRole.
     */
    data: XOR<SuperAdminRoleUpdateInput, SuperAdminRoleUncheckedUpdateInput>
    /**
     * Choose, which SuperAdminRole to update.
     */
    where: SuperAdminRoleWhereUniqueInput
  }

  /**
   * SuperAdminRole updateMany
   */
  export type SuperAdminRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdminRoles.
     */
    data: XOR<SuperAdminRoleUpdateManyMutationInput, SuperAdminRoleUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdminRoles to update
     */
    where?: SuperAdminRoleWhereInput
  }

  /**
   * SuperAdminRole upsert
   */
  export type SuperAdminRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdminRole to update in case it exists.
     */
    where: SuperAdminRoleWhereUniqueInput
    /**
     * In case the SuperAdminRole found by the `where` argument doesn't exist, create a new SuperAdminRole with this data.
     */
    create: XOR<SuperAdminRoleCreateInput, SuperAdminRoleUncheckedCreateInput>
    /**
     * In case the SuperAdminRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminRoleUpdateInput, SuperAdminRoleUncheckedUpdateInput>
  }

  /**
   * SuperAdminRole delete
   */
  export type SuperAdminRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
    /**
     * Filter which SuperAdminRole to delete.
     */
    where: SuperAdminRoleWhereUniqueInput
  }

  /**
   * SuperAdminRole deleteMany
   */
  export type SuperAdminRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdminRoles to delete
     */
    where?: SuperAdminRoleWhereInput
  }

  /**
   * SuperAdminRole.users
   */
  export type SuperAdminRole$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * SuperAdminRole without action
   */
  export type SuperAdminRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminRole
     */
    select?: SuperAdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminRoleInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    action: number
    entity: number
    entityId: number
    oldData: number
    newData: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    action?: true
    entity?: true
    entityId?: true
    oldData?: true
    newData?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    tenantId: string | null
    action: string
    entity: string
    entityId: string | null
    oldData: JsonValue | null
    newData: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      tenantId: string | null
      action: string
      entity: string
      entityId: string | null
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model LandingContent
   */

  export type AggregateLandingContent = {
    _count: LandingContentCountAggregateOutputType | null
    _min: LandingContentMinAggregateOutputType | null
    _max: LandingContentMaxAggregateOutputType | null
  }

  export type LandingContentMinAggregateOutputType = {
    id: string | null
    section: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type LandingContentMaxAggregateOutputType = {
    id: string | null
    section: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type LandingContentCountAggregateOutputType = {
    id: number
    section: number
    content: number
    isActive: number
    updatedAt: number
    _all: number
  }


  export type LandingContentMinAggregateInputType = {
    id?: true
    section?: true
    isActive?: true
    updatedAt?: true
  }

  export type LandingContentMaxAggregateInputType = {
    id?: true
    section?: true
    isActive?: true
    updatedAt?: true
  }

  export type LandingContentCountAggregateInputType = {
    id?: true
    section?: true
    content?: true
    isActive?: true
    updatedAt?: true
    _all?: true
  }

  export type LandingContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingContent to aggregate.
     */
    where?: LandingContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingContents to fetch.
     */
    orderBy?: LandingContentOrderByWithRelationInput | LandingContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandingContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LandingContents
    **/
    _count?: true | LandingContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandingContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandingContentMaxAggregateInputType
  }

  export type GetLandingContentAggregateType<T extends LandingContentAggregateArgs> = {
        [P in keyof T & keyof AggregateLandingContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandingContent[P]>
      : GetScalarType<T[P], AggregateLandingContent[P]>
  }




  export type LandingContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandingContentWhereInput
    orderBy?: LandingContentOrderByWithAggregationInput | LandingContentOrderByWithAggregationInput[]
    by: LandingContentScalarFieldEnum[] | LandingContentScalarFieldEnum
    having?: LandingContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandingContentCountAggregateInputType | true
    _min?: LandingContentMinAggregateInputType
    _max?: LandingContentMaxAggregateInputType
  }

  export type LandingContentGroupByOutputType = {
    id: string
    section: string
    content: JsonValue
    isActive: boolean
    updatedAt: Date
    _count: LandingContentCountAggregateOutputType | null
    _min: LandingContentMinAggregateOutputType | null
    _max: LandingContentMaxAggregateOutputType | null
  }

  type GetLandingContentGroupByPayload<T extends LandingContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandingContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandingContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandingContentGroupByOutputType[P]>
            : GetScalarType<T[P], LandingContentGroupByOutputType[P]>
        }
      >
    >


  export type LandingContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    section?: boolean
    content?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingContent"]>

  export type LandingContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    section?: boolean
    content?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingContent"]>

  export type LandingContentSelectScalar = {
    id?: boolean
    section?: boolean
    content?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }


  export type $LandingContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LandingContent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      section: string
      content: Prisma.JsonValue
      isActive: boolean
      updatedAt: Date
    }, ExtArgs["result"]["landingContent"]>
    composites: {}
  }

  type LandingContentGetPayload<S extends boolean | null | undefined | LandingContentDefaultArgs> = $Result.GetResult<Prisma.$LandingContentPayload, S>

  type LandingContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LandingContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LandingContentCountAggregateInputType | true
    }

  export interface LandingContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LandingContent'], meta: { name: 'LandingContent' } }
    /**
     * Find zero or one LandingContent that matches the filter.
     * @param {LandingContentFindUniqueArgs} args - Arguments to find a LandingContent
     * @example
     * // Get one LandingContent
     * const landingContent = await prisma.landingContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandingContentFindUniqueArgs>(args: SelectSubset<T, LandingContentFindUniqueArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LandingContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LandingContentFindUniqueOrThrowArgs} args - Arguments to find a LandingContent
     * @example
     * // Get one LandingContent
     * const landingContent = await prisma.landingContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandingContentFindUniqueOrThrowArgs>(args: SelectSubset<T, LandingContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LandingContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingContentFindFirstArgs} args - Arguments to find a LandingContent
     * @example
     * // Get one LandingContent
     * const landingContent = await prisma.landingContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandingContentFindFirstArgs>(args?: SelectSubset<T, LandingContentFindFirstArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LandingContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingContentFindFirstOrThrowArgs} args - Arguments to find a LandingContent
     * @example
     * // Get one LandingContent
     * const landingContent = await prisma.landingContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandingContentFindFirstOrThrowArgs>(args?: SelectSubset<T, LandingContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LandingContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LandingContents
     * const landingContents = await prisma.landingContent.findMany()
     * 
     * // Get first 10 LandingContents
     * const landingContents = await prisma.landingContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landingContentWithIdOnly = await prisma.landingContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LandingContentFindManyArgs>(args?: SelectSubset<T, LandingContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LandingContent.
     * @param {LandingContentCreateArgs} args - Arguments to create a LandingContent.
     * @example
     * // Create one LandingContent
     * const LandingContent = await prisma.landingContent.create({
     *   data: {
     *     // ... data to create a LandingContent
     *   }
     * })
     * 
     */
    create<T extends LandingContentCreateArgs>(args: SelectSubset<T, LandingContentCreateArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LandingContents.
     * @param {LandingContentCreateManyArgs} args - Arguments to create many LandingContents.
     * @example
     * // Create many LandingContents
     * const landingContent = await prisma.landingContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandingContentCreateManyArgs>(args?: SelectSubset<T, LandingContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LandingContents and returns the data saved in the database.
     * @param {LandingContentCreateManyAndReturnArgs} args - Arguments to create many LandingContents.
     * @example
     * // Create many LandingContents
     * const landingContent = await prisma.landingContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LandingContents and only return the `id`
     * const landingContentWithIdOnly = await prisma.landingContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LandingContentCreateManyAndReturnArgs>(args?: SelectSubset<T, LandingContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LandingContent.
     * @param {LandingContentDeleteArgs} args - Arguments to delete one LandingContent.
     * @example
     * // Delete one LandingContent
     * const LandingContent = await prisma.landingContent.delete({
     *   where: {
     *     // ... filter to delete one LandingContent
     *   }
     * })
     * 
     */
    delete<T extends LandingContentDeleteArgs>(args: SelectSubset<T, LandingContentDeleteArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LandingContent.
     * @param {LandingContentUpdateArgs} args - Arguments to update one LandingContent.
     * @example
     * // Update one LandingContent
     * const landingContent = await prisma.landingContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandingContentUpdateArgs>(args: SelectSubset<T, LandingContentUpdateArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LandingContents.
     * @param {LandingContentDeleteManyArgs} args - Arguments to filter LandingContents to delete.
     * @example
     * // Delete a few LandingContents
     * const { count } = await prisma.landingContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandingContentDeleteManyArgs>(args?: SelectSubset<T, LandingContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandingContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LandingContents
     * const landingContent = await prisma.landingContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandingContentUpdateManyArgs>(args: SelectSubset<T, LandingContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LandingContent.
     * @param {LandingContentUpsertArgs} args - Arguments to update or create a LandingContent.
     * @example
     * // Update or create a LandingContent
     * const landingContent = await prisma.landingContent.upsert({
     *   create: {
     *     // ... data to create a LandingContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LandingContent we want to update
     *   }
     * })
     */
    upsert<T extends LandingContentUpsertArgs>(args: SelectSubset<T, LandingContentUpsertArgs<ExtArgs>>): Prisma__LandingContentClient<$Result.GetResult<Prisma.$LandingContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LandingContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingContentCountArgs} args - Arguments to filter LandingContents to count.
     * @example
     * // Count the number of LandingContents
     * const count = await prisma.landingContent.count({
     *   where: {
     *     // ... the filter for the LandingContents we want to count
     *   }
     * })
    **/
    count<T extends LandingContentCountArgs>(
      args?: Subset<T, LandingContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandingContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LandingContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandingContentAggregateArgs>(args: Subset<T, LandingContentAggregateArgs>): Prisma.PrismaPromise<GetLandingContentAggregateType<T>>

    /**
     * Group by LandingContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandingContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandingContentGroupByArgs['orderBy'] }
        : { orderBy?: LandingContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandingContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandingContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LandingContent model
   */
  readonly fields: LandingContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LandingContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandingContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LandingContent model
   */ 
  interface LandingContentFieldRefs {
    readonly id: FieldRef<"LandingContent", 'String'>
    readonly section: FieldRef<"LandingContent", 'String'>
    readonly content: FieldRef<"LandingContent", 'Json'>
    readonly isActive: FieldRef<"LandingContent", 'Boolean'>
    readonly updatedAt: FieldRef<"LandingContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LandingContent findUnique
   */
  export type LandingContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * Filter, which LandingContent to fetch.
     */
    where: LandingContentWhereUniqueInput
  }

  /**
   * LandingContent findUniqueOrThrow
   */
  export type LandingContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * Filter, which LandingContent to fetch.
     */
    where: LandingContentWhereUniqueInput
  }

  /**
   * LandingContent findFirst
   */
  export type LandingContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * Filter, which LandingContent to fetch.
     */
    where?: LandingContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingContents to fetch.
     */
    orderBy?: LandingContentOrderByWithRelationInput | LandingContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingContents.
     */
    cursor?: LandingContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingContents.
     */
    distinct?: LandingContentScalarFieldEnum | LandingContentScalarFieldEnum[]
  }

  /**
   * LandingContent findFirstOrThrow
   */
  export type LandingContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * Filter, which LandingContent to fetch.
     */
    where?: LandingContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingContents to fetch.
     */
    orderBy?: LandingContentOrderByWithRelationInput | LandingContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingContents.
     */
    cursor?: LandingContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingContents.
     */
    distinct?: LandingContentScalarFieldEnum | LandingContentScalarFieldEnum[]
  }

  /**
   * LandingContent findMany
   */
  export type LandingContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * Filter, which LandingContents to fetch.
     */
    where?: LandingContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingContents to fetch.
     */
    orderBy?: LandingContentOrderByWithRelationInput | LandingContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LandingContents.
     */
    cursor?: LandingContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingContents.
     */
    skip?: number
    distinct?: LandingContentScalarFieldEnum | LandingContentScalarFieldEnum[]
  }

  /**
   * LandingContent create
   */
  export type LandingContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * The data needed to create a LandingContent.
     */
    data: XOR<LandingContentCreateInput, LandingContentUncheckedCreateInput>
  }

  /**
   * LandingContent createMany
   */
  export type LandingContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LandingContents.
     */
    data: LandingContentCreateManyInput | LandingContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LandingContent createManyAndReturn
   */
  export type LandingContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LandingContents.
     */
    data: LandingContentCreateManyInput | LandingContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LandingContent update
   */
  export type LandingContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * The data needed to update a LandingContent.
     */
    data: XOR<LandingContentUpdateInput, LandingContentUncheckedUpdateInput>
    /**
     * Choose, which LandingContent to update.
     */
    where: LandingContentWhereUniqueInput
  }

  /**
   * LandingContent updateMany
   */
  export type LandingContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LandingContents.
     */
    data: XOR<LandingContentUpdateManyMutationInput, LandingContentUncheckedUpdateManyInput>
    /**
     * Filter which LandingContents to update
     */
    where?: LandingContentWhereInput
  }

  /**
   * LandingContent upsert
   */
  export type LandingContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * The filter to search for the LandingContent to update in case it exists.
     */
    where: LandingContentWhereUniqueInput
    /**
     * In case the LandingContent found by the `where` argument doesn't exist, create a new LandingContent with this data.
     */
    create: XOR<LandingContentCreateInput, LandingContentUncheckedCreateInput>
    /**
     * In case the LandingContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandingContentUpdateInput, LandingContentUncheckedUpdateInput>
  }

  /**
   * LandingContent delete
   */
  export type LandingContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
    /**
     * Filter which LandingContent to delete.
     */
    where: LandingContentWhereUniqueInput
  }

  /**
   * LandingContent deleteMany
   */
  export type LandingContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingContents to delete
     */
    where?: LandingContentWhereInput
  }

  /**
   * LandingContent without action
   */
  export type LandingContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingContent
     */
    select?: LandingContentSelect<ExtArgs> | null
  }


  /**
   * Model PaymentProvider
   */

  export type AggregatePaymentProvider = {
    _count: PaymentProviderCountAggregateOutputType | null
    _min: PaymentProviderMinAggregateOutputType | null
    _max: PaymentProviderMaxAggregateOutputType | null
  }

  export type PaymentProviderMinAggregateOutputType = {
    id: string | null
    provider: string | null
    displayName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentProviderMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    displayName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentProviderCountAggregateOutputType = {
    id: number
    provider: number
    displayName: number
    credentials: number
    isActive: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentProviderMinAggregateInputType = {
    id?: true
    provider?: true
    displayName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentProviderMaxAggregateInputType = {
    id?: true
    provider?: true
    displayName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentProviderCountAggregateInputType = {
    id?: true
    provider?: true
    displayName?: true
    credentials?: true
    isActive?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentProvider to aggregate.
     */
    where?: PaymentProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviders to fetch.
     */
    orderBy?: PaymentProviderOrderByWithRelationInput | PaymentProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentProviders
    **/
    _count?: true | PaymentProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentProviderMaxAggregateInputType
  }

  export type GetPaymentProviderAggregateType<T extends PaymentProviderAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentProvider[P]>
      : GetScalarType<T[P], AggregatePaymentProvider[P]>
  }




  export type PaymentProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentProviderWhereInput
    orderBy?: PaymentProviderOrderByWithAggregationInput | PaymentProviderOrderByWithAggregationInput[]
    by: PaymentProviderScalarFieldEnum[] | PaymentProviderScalarFieldEnum
    having?: PaymentProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentProviderCountAggregateInputType | true
    _min?: PaymentProviderMinAggregateInputType
    _max?: PaymentProviderMaxAggregateInputType
  }

  export type PaymentProviderGroupByOutputType = {
    id: string
    provider: string
    displayName: string
    credentials: JsonValue
    isActive: boolean
    config: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentProviderCountAggregateOutputType | null
    _min: PaymentProviderMinAggregateOutputType | null
    _max: PaymentProviderMaxAggregateOutputType | null
  }

  type GetPaymentProviderGroupByPayload<T extends PaymentProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentProviderGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentProviderGroupByOutputType[P]>
        }
      >
    >


  export type PaymentProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    displayName?: boolean
    credentials?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentProvider"]>

  export type PaymentProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    displayName?: boolean
    credentials?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentProvider"]>

  export type PaymentProviderSelectScalar = {
    id?: boolean
    provider?: boolean
    displayName?: boolean
    credentials?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PaymentProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentProvider"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      displayName: string
      credentials: Prisma.JsonValue
      isActive: boolean
      config: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentProvider"]>
    composites: {}
  }

  type PaymentProviderGetPayload<S extends boolean | null | undefined | PaymentProviderDefaultArgs> = $Result.GetResult<Prisma.$PaymentProviderPayload, S>

  type PaymentProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentProviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentProviderCountAggregateInputType | true
    }

  export interface PaymentProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentProvider'], meta: { name: 'PaymentProvider' } }
    /**
     * Find zero or one PaymentProvider that matches the filter.
     * @param {PaymentProviderFindUniqueArgs} args - Arguments to find a PaymentProvider
     * @example
     * // Get one PaymentProvider
     * const paymentProvider = await prisma.paymentProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentProviderFindUniqueArgs>(args: SelectSubset<T, PaymentProviderFindUniqueArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentProvider that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentProviderFindUniqueOrThrowArgs} args - Arguments to find a PaymentProvider
     * @example
     * // Get one PaymentProvider
     * const paymentProvider = await prisma.paymentProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderFindFirstArgs} args - Arguments to find a PaymentProvider
     * @example
     * // Get one PaymentProvider
     * const paymentProvider = await prisma.paymentProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentProviderFindFirstArgs>(args?: SelectSubset<T, PaymentProviderFindFirstArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderFindFirstOrThrowArgs} args - Arguments to find a PaymentProvider
     * @example
     * // Get one PaymentProvider
     * const paymentProvider = await prisma.paymentProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentProviders
     * const paymentProviders = await prisma.paymentProvider.findMany()
     * 
     * // Get first 10 PaymentProviders
     * const paymentProviders = await prisma.paymentProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentProviderWithIdOnly = await prisma.paymentProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentProviderFindManyArgs>(args?: SelectSubset<T, PaymentProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentProvider.
     * @param {PaymentProviderCreateArgs} args - Arguments to create a PaymentProvider.
     * @example
     * // Create one PaymentProvider
     * const PaymentProvider = await prisma.paymentProvider.create({
     *   data: {
     *     // ... data to create a PaymentProvider
     *   }
     * })
     * 
     */
    create<T extends PaymentProviderCreateArgs>(args: SelectSubset<T, PaymentProviderCreateArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentProviders.
     * @param {PaymentProviderCreateManyArgs} args - Arguments to create many PaymentProviders.
     * @example
     * // Create many PaymentProviders
     * const paymentProvider = await prisma.paymentProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentProviderCreateManyArgs>(args?: SelectSubset<T, PaymentProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentProviders and returns the data saved in the database.
     * @param {PaymentProviderCreateManyAndReturnArgs} args - Arguments to create many PaymentProviders.
     * @example
     * // Create many PaymentProviders
     * const paymentProvider = await prisma.paymentProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentProviders and only return the `id`
     * const paymentProviderWithIdOnly = await prisma.paymentProvider.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentProvider.
     * @param {PaymentProviderDeleteArgs} args - Arguments to delete one PaymentProvider.
     * @example
     * // Delete one PaymentProvider
     * const PaymentProvider = await prisma.paymentProvider.delete({
     *   where: {
     *     // ... filter to delete one PaymentProvider
     *   }
     * })
     * 
     */
    delete<T extends PaymentProviderDeleteArgs>(args: SelectSubset<T, PaymentProviderDeleteArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentProvider.
     * @param {PaymentProviderUpdateArgs} args - Arguments to update one PaymentProvider.
     * @example
     * // Update one PaymentProvider
     * const paymentProvider = await prisma.paymentProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentProviderUpdateArgs>(args: SelectSubset<T, PaymentProviderUpdateArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentProviders.
     * @param {PaymentProviderDeleteManyArgs} args - Arguments to filter PaymentProviders to delete.
     * @example
     * // Delete a few PaymentProviders
     * const { count } = await prisma.paymentProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentProviderDeleteManyArgs>(args?: SelectSubset<T, PaymentProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentProviders
     * const paymentProvider = await prisma.paymentProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentProviderUpdateManyArgs>(args: SelectSubset<T, PaymentProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentProvider.
     * @param {PaymentProviderUpsertArgs} args - Arguments to update or create a PaymentProvider.
     * @example
     * // Update or create a PaymentProvider
     * const paymentProvider = await prisma.paymentProvider.upsert({
     *   create: {
     *     // ... data to create a PaymentProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentProvider we want to update
     *   }
     * })
     */
    upsert<T extends PaymentProviderUpsertArgs>(args: SelectSubset<T, PaymentProviderUpsertArgs<ExtArgs>>): Prisma__PaymentProviderClient<$Result.GetResult<Prisma.$PaymentProviderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderCountArgs} args - Arguments to filter PaymentProviders to count.
     * @example
     * // Count the number of PaymentProviders
     * const count = await prisma.paymentProvider.count({
     *   where: {
     *     // ... the filter for the PaymentProviders we want to count
     *   }
     * })
    **/
    count<T extends PaymentProviderCountArgs>(
      args?: Subset<T, PaymentProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentProviderAggregateArgs>(args: Subset<T, PaymentProviderAggregateArgs>): Prisma.PrismaPromise<GetPaymentProviderAggregateType<T>>

    /**
     * Group by PaymentProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentProviderGroupByArgs['orderBy'] }
        : { orderBy?: PaymentProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentProvider model
   */
  readonly fields: PaymentProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentProvider model
   */ 
  interface PaymentProviderFieldRefs {
    readonly id: FieldRef<"PaymentProvider", 'String'>
    readonly provider: FieldRef<"PaymentProvider", 'String'>
    readonly displayName: FieldRef<"PaymentProvider", 'String'>
    readonly credentials: FieldRef<"PaymentProvider", 'Json'>
    readonly isActive: FieldRef<"PaymentProvider", 'Boolean'>
    readonly config: FieldRef<"PaymentProvider", 'Json'>
    readonly createdAt: FieldRef<"PaymentProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentProvider findUnique
   */
  export type PaymentProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * Filter, which PaymentProvider to fetch.
     */
    where: PaymentProviderWhereUniqueInput
  }

  /**
   * PaymentProvider findUniqueOrThrow
   */
  export type PaymentProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * Filter, which PaymentProvider to fetch.
     */
    where: PaymentProviderWhereUniqueInput
  }

  /**
   * PaymentProvider findFirst
   */
  export type PaymentProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * Filter, which PaymentProvider to fetch.
     */
    where?: PaymentProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviders to fetch.
     */
    orderBy?: PaymentProviderOrderByWithRelationInput | PaymentProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentProviders.
     */
    cursor?: PaymentProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentProviders.
     */
    distinct?: PaymentProviderScalarFieldEnum | PaymentProviderScalarFieldEnum[]
  }

  /**
   * PaymentProvider findFirstOrThrow
   */
  export type PaymentProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * Filter, which PaymentProvider to fetch.
     */
    where?: PaymentProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviders to fetch.
     */
    orderBy?: PaymentProviderOrderByWithRelationInput | PaymentProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentProviders.
     */
    cursor?: PaymentProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentProviders.
     */
    distinct?: PaymentProviderScalarFieldEnum | PaymentProviderScalarFieldEnum[]
  }

  /**
   * PaymentProvider findMany
   */
  export type PaymentProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * Filter, which PaymentProviders to fetch.
     */
    where?: PaymentProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviders to fetch.
     */
    orderBy?: PaymentProviderOrderByWithRelationInput | PaymentProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentProviders.
     */
    cursor?: PaymentProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviders.
     */
    skip?: number
    distinct?: PaymentProviderScalarFieldEnum | PaymentProviderScalarFieldEnum[]
  }

  /**
   * PaymentProvider create
   */
  export type PaymentProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentProvider.
     */
    data: XOR<PaymentProviderCreateInput, PaymentProviderUncheckedCreateInput>
  }

  /**
   * PaymentProvider createMany
   */
  export type PaymentProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentProviders.
     */
    data: PaymentProviderCreateManyInput | PaymentProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentProvider createManyAndReturn
   */
  export type PaymentProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentProviders.
     */
    data: PaymentProviderCreateManyInput | PaymentProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentProvider update
   */
  export type PaymentProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentProvider.
     */
    data: XOR<PaymentProviderUpdateInput, PaymentProviderUncheckedUpdateInput>
    /**
     * Choose, which PaymentProvider to update.
     */
    where: PaymentProviderWhereUniqueInput
  }

  /**
   * PaymentProvider updateMany
   */
  export type PaymentProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentProviders.
     */
    data: XOR<PaymentProviderUpdateManyMutationInput, PaymentProviderUncheckedUpdateManyInput>
    /**
     * Filter which PaymentProviders to update
     */
    where?: PaymentProviderWhereInput
  }

  /**
   * PaymentProvider upsert
   */
  export type PaymentProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentProvider to update in case it exists.
     */
    where: PaymentProviderWhereUniqueInput
    /**
     * In case the PaymentProvider found by the `where` argument doesn't exist, create a new PaymentProvider with this data.
     */
    create: XOR<PaymentProviderCreateInput, PaymentProviderUncheckedCreateInput>
    /**
     * In case the PaymentProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentProviderUpdateInput, PaymentProviderUncheckedUpdateInput>
  }

  /**
   * PaymentProvider delete
   */
  export type PaymentProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
    /**
     * Filter which PaymentProvider to delete.
     */
    where: PaymentProviderWhereUniqueInput
  }

  /**
   * PaymentProvider deleteMany
   */
  export type PaymentProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentProviders to delete
     */
    where?: PaymentProviderWhereInput
  }

  /**
   * PaymentProvider without action
   */
  export type PaymentProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProvider
     */
    select?: PaymentProviderSelect<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    bankName: string | null
    accountName: string | null
    iban: string | null
    currency: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    bankName: string | null
    accountName: string | null
    iban: string | null
    currency: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    bankName: number
    accountName: number
    iban: number
    currency: number
    isActive: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    sortOrder?: true
  }

  export type BankAccountSumAggregateInputType = {
    sortOrder?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    bankName?: true
    accountName?: true
    iban?: true
    currency?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    bankName?: true
    accountName?: true
    iban?: true
    currency?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    bankName?: true
    accountName?: true
    iban?: true
    currency?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    bankName: string
    accountName: string
    iban: string
    currency: string
    isActive: boolean
    sortOrder: number
    createdAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountName?: boolean
    iban?: boolean
    currency?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountName?: boolean
    iban?: boolean
    currency?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    bankName?: boolean
    accountName?: boolean
    iban?: boolean
    currency?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }


  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankName: string
      accountName: string
      iban: string
      currency: string
      isActive: boolean
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */ 
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly bankName: FieldRef<"BankAccount", 'String'>
    readonly accountName: FieldRef<"BankAccount", 'String'>
    readonly iban: FieldRef<"BankAccount", 'String'>
    readonly currency: FieldRef<"BankAccount", 'String'>
    readonly isActive: FieldRef<"BankAccount", 'Boolean'>
    readonly sortOrder: FieldRef<"BankAccount", 'Int'>
    readonly createdAt: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    name: number
    config: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    name?: true
    config?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    tenantId: string | null
    type: string
    name: string
    config: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | Integration$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | Integration$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    name?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Integration$tenantArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Integration$tenantArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      type: string
      name: string
      config: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends Integration$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Integration$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */ 
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly tenantId: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'String'>
    readonly name: FieldRef<"Integration", 'String'>
    readonly config: FieldRef<"Integration", 'Json'>
    readonly isActive: FieldRef<"Integration", 'Boolean'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
  }

  /**
   * Integration.tenant
   */
  export type Integration$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    code: string | null
    name: string | null
    subject: string | null
    content: string | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: string | null
    code: string | null
    name: string | null
    subject: string | null
    content: string | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    code: number
    name: number
    subject: number
    content: number
    isSystem: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    code?: true
    name?: true
    subject?: true
    content?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    code?: true
    name?: true
    subject?: true
    content?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    code?: true
    name?: true
    subject?: true
    content?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: string
    tenantId: string | null
    type: string
    code: string
    name: string
    subject: string | null
    content: string
    isSystem: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    code?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | Template$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    code?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | Template$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    code?: boolean
    name?: boolean
    subject?: boolean
    content?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Template$tenantArgs<ExtArgs>
  }
  export type TemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Template$tenantArgs<ExtArgs>
  }

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      type: string
      code: string
      name: string
      subject: string | null
      content: string
      isSystem: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Templates and returns the data saved in the database.
     * @param {TemplateCreateManyAndReturnArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends Template$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Template$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */ 
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'String'>
    readonly tenantId: FieldRef<"Template", 'String'>
    readonly type: FieldRef<"Template", 'String'>
    readonly code: FieldRef<"Template", 'String'>
    readonly name: FieldRef<"Template", 'String'>
    readonly subject: FieldRef<"Template", 'String'>
    readonly content: FieldRef<"Template", 'String'>
    readonly isSystem: FieldRef<"Template", 'Boolean'>
    readonly isActive: FieldRef<"Template", 'Boolean'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
    readonly updatedAt: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template createManyAndReturn
   */
  export type TemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
  }

  /**
   * Template.tenant
   */
  export type Template$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    subject: string | null
    message: string | null
    category: string | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    subject: string | null
    message: string | null
    category: string | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    subject: number
    message: number
    category: number
    priority: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    subject?: true
    message?: true
    category?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    subject?: true
    message?: true
    category?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    subject?: true
    message?: true
    category?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    subject: string
    message: string
    category: string
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    subject?: boolean
    message?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    replies?: boolean | SupportTicket$repliesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    subject?: boolean
    message?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    subject?: boolean
    message?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    replies?: boolean | SupportTicket$repliesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      replies: Prisma.$TicketReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      subject: string
      message: string
      category: string
      priority: $Enums.TicketPriority
      status: $Enums.TicketStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    replies<T extends SupportTicket$repliesArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly tenantId: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly message: FieldRef<"SupportTicket", 'String'>
    readonly category: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'TicketPriority'>
    readonly status: FieldRef<"SupportTicket", 'TicketStatus'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket.replies
   */
  export type SupportTicket$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    where?: TicketReplyWhereInput
    orderBy?: TicketReplyOrderByWithRelationInput | TicketReplyOrderByWithRelationInput[]
    cursor?: TicketReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketReplyScalarFieldEnum | TicketReplyScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketReply
   */

  export type AggregateTicketReply = {
    _count: TicketReplyCountAggregateOutputType | null
    _min: TicketReplyMinAggregateOutputType | null
    _max: TicketReplyMaxAggregateOutputType | null
  }

  export type TicketReplyMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    message: string | null
    isAdminReply: boolean | null
    createdAt: Date | null
  }

  export type TicketReplyMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    message: string | null
    isAdminReply: boolean | null
    createdAt: Date | null
  }

  export type TicketReplyCountAggregateOutputType = {
    id: number
    ticketId: number
    userId: number
    message: number
    isAdminReply: number
    createdAt: number
    _all: number
  }


  export type TicketReplyMinAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    isAdminReply?: true
    createdAt?: true
  }

  export type TicketReplyMaxAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    isAdminReply?: true
    createdAt?: true
  }

  export type TicketReplyCountAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    isAdminReply?: true
    createdAt?: true
    _all?: true
  }

  export type TicketReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketReply to aggregate.
     */
    where?: TicketReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketReplies to fetch.
     */
    orderBy?: TicketReplyOrderByWithRelationInput | TicketReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketReplies
    **/
    _count?: true | TicketReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketReplyMaxAggregateInputType
  }

  export type GetTicketReplyAggregateType<T extends TicketReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketReply[P]>
      : GetScalarType<T[P], AggregateTicketReply[P]>
  }




  export type TicketReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketReplyWhereInput
    orderBy?: TicketReplyOrderByWithAggregationInput | TicketReplyOrderByWithAggregationInput[]
    by: TicketReplyScalarFieldEnum[] | TicketReplyScalarFieldEnum
    having?: TicketReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketReplyCountAggregateInputType | true
    _min?: TicketReplyMinAggregateInputType
    _max?: TicketReplyMaxAggregateInputType
  }

  export type TicketReplyGroupByOutputType = {
    id: string
    ticketId: string
    userId: string
    message: string
    isAdminReply: boolean
    createdAt: Date
    _count: TicketReplyCountAggregateOutputType | null
    _min: TicketReplyMinAggregateOutputType | null
    _max: TicketReplyMaxAggregateOutputType | null
  }

  type GetTicketReplyGroupByPayload<T extends TicketReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketReplyGroupByOutputType[P]>
            : GetScalarType<T[P], TicketReplyGroupByOutputType[P]>
        }
      >
    >


  export type TicketReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    isAdminReply?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketReply"]>

  export type TicketReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    isAdminReply?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketReply"]>

  export type TicketReplySelectScalar = {
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    isAdminReply?: boolean
    createdAt?: boolean
  }

  export type TicketReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }
  export type TicketReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }

  export type $TicketReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketReply"
    objects: {
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      userId: string
      message: string
      isAdminReply: boolean
      createdAt: Date
    }, ExtArgs["result"]["ticketReply"]>
    composites: {}
  }

  type TicketReplyGetPayload<S extends boolean | null | undefined | TicketReplyDefaultArgs> = $Result.GetResult<Prisma.$TicketReplyPayload, S>

  type TicketReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketReplyCountAggregateInputType | true
    }

  export interface TicketReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketReply'], meta: { name: 'TicketReply' } }
    /**
     * Find zero or one TicketReply that matches the filter.
     * @param {TicketReplyFindUniqueArgs} args - Arguments to find a TicketReply
     * @example
     * // Get one TicketReply
     * const ticketReply = await prisma.ticketReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketReplyFindUniqueArgs>(args: SelectSubset<T, TicketReplyFindUniqueArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketReply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketReplyFindUniqueOrThrowArgs} args - Arguments to find a TicketReply
     * @example
     * // Get one TicketReply
     * const ticketReply = await prisma.ticketReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketReplyFindFirstArgs} args - Arguments to find a TicketReply
     * @example
     * // Get one TicketReply
     * const ticketReply = await prisma.ticketReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketReplyFindFirstArgs>(args?: SelectSubset<T, TicketReplyFindFirstArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketReplyFindFirstOrThrowArgs} args - Arguments to find a TicketReply
     * @example
     * // Get one TicketReply
     * const ticketReply = await prisma.ticketReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketReplies
     * const ticketReplies = await prisma.ticketReply.findMany()
     * 
     * // Get first 10 TicketReplies
     * const ticketReplies = await prisma.ticketReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketReplyWithIdOnly = await prisma.ticketReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketReplyFindManyArgs>(args?: SelectSubset<T, TicketReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketReply.
     * @param {TicketReplyCreateArgs} args - Arguments to create a TicketReply.
     * @example
     * // Create one TicketReply
     * const TicketReply = await prisma.ticketReply.create({
     *   data: {
     *     // ... data to create a TicketReply
     *   }
     * })
     * 
     */
    create<T extends TicketReplyCreateArgs>(args: SelectSubset<T, TicketReplyCreateArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketReplies.
     * @param {TicketReplyCreateManyArgs} args - Arguments to create many TicketReplies.
     * @example
     * // Create many TicketReplies
     * const ticketReply = await prisma.ticketReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketReplyCreateManyArgs>(args?: SelectSubset<T, TicketReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketReplies and returns the data saved in the database.
     * @param {TicketReplyCreateManyAndReturnArgs} args - Arguments to create many TicketReplies.
     * @example
     * // Create many TicketReplies
     * const ticketReply = await prisma.ticketReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketReplies and only return the `id`
     * const ticketReplyWithIdOnly = await prisma.ticketReply.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketReply.
     * @param {TicketReplyDeleteArgs} args - Arguments to delete one TicketReply.
     * @example
     * // Delete one TicketReply
     * const TicketReply = await prisma.ticketReply.delete({
     *   where: {
     *     // ... filter to delete one TicketReply
     *   }
     * })
     * 
     */
    delete<T extends TicketReplyDeleteArgs>(args: SelectSubset<T, TicketReplyDeleteArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketReply.
     * @param {TicketReplyUpdateArgs} args - Arguments to update one TicketReply.
     * @example
     * // Update one TicketReply
     * const ticketReply = await prisma.ticketReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketReplyUpdateArgs>(args: SelectSubset<T, TicketReplyUpdateArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketReplies.
     * @param {TicketReplyDeleteManyArgs} args - Arguments to filter TicketReplies to delete.
     * @example
     * // Delete a few TicketReplies
     * const { count } = await prisma.ticketReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketReplyDeleteManyArgs>(args?: SelectSubset<T, TicketReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketReplies
     * const ticketReply = await prisma.ticketReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketReplyUpdateManyArgs>(args: SelectSubset<T, TicketReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketReply.
     * @param {TicketReplyUpsertArgs} args - Arguments to update or create a TicketReply.
     * @example
     * // Update or create a TicketReply
     * const ticketReply = await prisma.ticketReply.upsert({
     *   create: {
     *     // ... data to create a TicketReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketReply we want to update
     *   }
     * })
     */
    upsert<T extends TicketReplyUpsertArgs>(args: SelectSubset<T, TicketReplyUpsertArgs<ExtArgs>>): Prisma__TicketReplyClient<$Result.GetResult<Prisma.$TicketReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketReplyCountArgs} args - Arguments to filter TicketReplies to count.
     * @example
     * // Count the number of TicketReplies
     * const count = await prisma.ticketReply.count({
     *   where: {
     *     // ... the filter for the TicketReplies we want to count
     *   }
     * })
    **/
    count<T extends TicketReplyCountArgs>(
      args?: Subset<T, TicketReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketReplyAggregateArgs>(args: Subset<T, TicketReplyAggregateArgs>): Prisma.PrismaPromise<GetTicketReplyAggregateType<T>>

    /**
     * Group by TicketReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketReplyGroupByArgs['orderBy'] }
        : { orderBy?: TicketReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketReply model
   */
  readonly fields: TicketReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketReply model
   */ 
  interface TicketReplyFieldRefs {
    readonly id: FieldRef<"TicketReply", 'String'>
    readonly ticketId: FieldRef<"TicketReply", 'String'>
    readonly userId: FieldRef<"TicketReply", 'String'>
    readonly message: FieldRef<"TicketReply", 'String'>
    readonly isAdminReply: FieldRef<"TicketReply", 'Boolean'>
    readonly createdAt: FieldRef<"TicketReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketReply findUnique
   */
  export type TicketReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * Filter, which TicketReply to fetch.
     */
    where: TicketReplyWhereUniqueInput
  }

  /**
   * TicketReply findUniqueOrThrow
   */
  export type TicketReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * Filter, which TicketReply to fetch.
     */
    where: TicketReplyWhereUniqueInput
  }

  /**
   * TicketReply findFirst
   */
  export type TicketReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * Filter, which TicketReply to fetch.
     */
    where?: TicketReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketReplies to fetch.
     */
    orderBy?: TicketReplyOrderByWithRelationInput | TicketReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketReplies.
     */
    cursor?: TicketReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketReplies.
     */
    distinct?: TicketReplyScalarFieldEnum | TicketReplyScalarFieldEnum[]
  }

  /**
   * TicketReply findFirstOrThrow
   */
  export type TicketReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * Filter, which TicketReply to fetch.
     */
    where?: TicketReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketReplies to fetch.
     */
    orderBy?: TicketReplyOrderByWithRelationInput | TicketReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketReplies.
     */
    cursor?: TicketReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketReplies.
     */
    distinct?: TicketReplyScalarFieldEnum | TicketReplyScalarFieldEnum[]
  }

  /**
   * TicketReply findMany
   */
  export type TicketReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * Filter, which TicketReplies to fetch.
     */
    where?: TicketReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketReplies to fetch.
     */
    orderBy?: TicketReplyOrderByWithRelationInput | TicketReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketReplies.
     */
    cursor?: TicketReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketReplies.
     */
    skip?: number
    distinct?: TicketReplyScalarFieldEnum | TicketReplyScalarFieldEnum[]
  }

  /**
   * TicketReply create
   */
  export type TicketReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketReply.
     */
    data: XOR<TicketReplyCreateInput, TicketReplyUncheckedCreateInput>
  }

  /**
   * TicketReply createMany
   */
  export type TicketReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketReplies.
     */
    data: TicketReplyCreateManyInput | TicketReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketReply createManyAndReturn
   */
  export type TicketReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketReplies.
     */
    data: TicketReplyCreateManyInput | TicketReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketReply update
   */
  export type TicketReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketReply.
     */
    data: XOR<TicketReplyUpdateInput, TicketReplyUncheckedUpdateInput>
    /**
     * Choose, which TicketReply to update.
     */
    where: TicketReplyWhereUniqueInput
  }

  /**
   * TicketReply updateMany
   */
  export type TicketReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketReplies.
     */
    data: XOR<TicketReplyUpdateManyMutationInput, TicketReplyUncheckedUpdateManyInput>
    /**
     * Filter which TicketReplies to update
     */
    where?: TicketReplyWhereInput
  }

  /**
   * TicketReply upsert
   */
  export type TicketReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketReply to update in case it exists.
     */
    where: TicketReplyWhereUniqueInput
    /**
     * In case the TicketReply found by the `where` argument doesn't exist, create a new TicketReply with this data.
     */
    create: XOR<TicketReplyCreateInput, TicketReplyUncheckedCreateInput>
    /**
     * In case the TicketReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketReplyUpdateInput, TicketReplyUncheckedUpdateInput>
  }

  /**
   * TicketReply delete
   */
  export type TicketReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
    /**
     * Filter which TicketReply to delete.
     */
    where: TicketReplyWhereUniqueInput
  }

  /**
   * TicketReply deleteMany
   */
  export type TicketReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketReplies to delete
     */
    where?: TicketReplyWhereInput
  }

  /**
   * TicketReply without action
   */
  export type TicketReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketReply
     */
    select?: TicketReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketReplyInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SubscriptionPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priceMonthly: 'priceMonthly',
    priceYearly: 'priceYearly',
    maxUsers: 'maxUsers',
    maxProducts: 'maxProducts',
    storageLimit: 'storageLimit',
    features: 'features',
    isPopular: 'isPopular',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    isDemo: 'isDemo',
    demoDuration: 'demoDuration',
    discountPercentage: 'discountPercentage',
    discountEndDate: 'discountEndDate',
    highlightColor: 'highlightColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPackageScalarFieldEnum = (typeof SubscriptionPackageScalarFieldEnum)[keyof typeof SubscriptionPackageScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    name: 'name',
    type: 'type',
    taxNumber: 'taxNumber',
    taxOffice: 'taxOffice',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    subscriptionPlanId: 'subscriptionPlanId',
    status: 'status',
    subscriptionStart: 'subscriptionStart',
    subscriptionEnd: 'subscriptionEnd',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const SaaSPaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    amount: 'amount',
    date: 'date',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaaSPaymentScalarFieldEnum = (typeof SaaSPaymentScalarFieldEnum)[keyof typeof SaaSPaymentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    userNo: 'userNo',
    tenantId: 'tenantId',
    name: 'name',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    permissions: 'permissions',
    bio: 'bio',
    avatar: 'avatar',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isTwoFactorEnabled: 'isTwoFactorEnabled',
    twoFactorMethod: 'twoFactorMethod',
    phoneNumber: 'phoneNumber',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorExpires: 'twoFactorExpires',
    isSuperAdmin: 'isSuperAdmin',
    superAdminRoleId: 'superAdminRoleId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    accountCode: 'accountCode',
    name: 'name',
    balance: 'balance',
    riskLimit: 'riskLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    code: 'code',
    barcode: 'barcode',
    stockQuantity: 'stockQuantity',
    priceSell: 'priceSell',
    trackStock: 'trackStock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    productId: 'productId',
    type: 'type',
    quantity: 'quantity',
    documentRef: 'documentRef',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const CashRegisterScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    currency: 'currency',
    balance: 'balance',
    createdAt: 'createdAt'
  };

  export type CashRegisterScalarFieldEnum = (typeof CashRegisterScalarFieldEnum)[keyof typeof CashRegisterScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    registerId: 'registerId',
    accountId: 'accountId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    description: 'description',
    relatedId: 'relatedId',
    invoiceId: 'invoiceId',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    accountId: 'accountId',
    type: 'type',
    totalAmount: 'totalAmount',
    status: 'status',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    accountId: 'accountId',
    totalAmount: 'totalAmount',
    status: 'status',
    validUntil: 'validUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    offerId: 'offerId',
    productId: 'productId',
    name: 'name',
    quantity: 'quantity',
    price: 'price',
    total: 'total'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PosSessionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    registerId: 'registerId',
    employeeId: 'employeeId',
    openedAt: 'openedAt',
    closedAt: 'closedAt',
    openingBalance: 'openingBalance',
    closingBalance: 'closingBalance'
  };

  export type PosSessionScalarFieldEnum = (typeof PosSessionScalarFieldEnum)[keyof typeof PosSessionScalarFieldEnum]


  export const ServiceTicketScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    customerId: 'customerId',
    technicianId: 'technicianId',
    deviceInfo: 'deviceInfo',
    problemDesc: 'problemDesc',
    status: 'status',
    estimatedCost: 'estimatedCost',
    finalCost: 'finalCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTicketScalarFieldEnum = (typeof ServiceTicketScalarFieldEnum)[keyof typeof ServiceTicketScalarFieldEnum]


  export const ServicePartScalarFieldEnum: {
    id: 'id',
    serviceTicketId: 'serviceTicketId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price'
  };

  export type ServicePartScalarFieldEnum = (typeof ServicePartScalarFieldEnum)[keyof typeof ServicePartScalarFieldEnum]


  export const ServiceHistoryScalarFieldEnum: {
    id: 'id',
    serviceTicketId: 'serviceTicketId',
    status: 'status',
    note: 'note',
    changedBy: 'changedBy',
    createdAt: 'createdAt'
  };

  export type ServiceHistoryScalarFieldEnum = (typeof ServiceHistoryScalarFieldEnum)[keyof typeof ServiceHistoryScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    position: 'position',
    salary: 'salary',
    hireDate: 'hireDate',
    createdAt: 'createdAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    month: 'month',
    amount: 'amount',
    isPaid: 'isPaid',
    paidAt: 'paidAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    startDate: 'startDate',
    endDate: 'endDate',
    reason: 'reason',
    status: 'status'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    icon: 'icon',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const PackageModuleScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    moduleId: 'moduleId'
  };

  export type PackageModuleScalarFieldEnum = (typeof PackageModuleScalarFieldEnum)[keyof typeof PackageModuleScalarFieldEnum]


  export const SuperAdminRoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuperAdminRoleScalarFieldEnum = (typeof SuperAdminRoleScalarFieldEnum)[keyof typeof SuperAdminRoleScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    oldData: 'oldData',
    newData: 'newData',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const LandingContentScalarFieldEnum: {
    id: 'id',
    section: 'section',
    content: 'content',
    isActive: 'isActive',
    updatedAt: 'updatedAt'
  };

  export type LandingContentScalarFieldEnum = (typeof LandingContentScalarFieldEnum)[keyof typeof LandingContentScalarFieldEnum]


  export const PaymentProviderScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    displayName: 'displayName',
    credentials: 'credentials',
    isActive: 'isActive',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentProviderScalarFieldEnum = (typeof PaymentProviderScalarFieldEnum)[keyof typeof PaymentProviderScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    bankName: 'bankName',
    accountName: 'accountName',
    iban: 'iban',
    currency: 'currency',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    name: 'name',
    config: 'config',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    code: 'code',
    name: 'name',
    subject: 'subject',
    content: 'content',
    isSystem: 'isSystem',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    subject: 'subject',
    message: 'message',
    category: 'category',
    priority: 'priority',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const TicketReplyScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    userId: 'userId',
    message: 'message',
    isAdminReply: 'isAdminReply',
    createdAt: 'createdAt'
  };

  export type TicketReplyScalarFieldEnum = (typeof TicketReplyScalarFieldEnum)[keyof typeof TicketReplyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TenantType'
   */
  export type EnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType'>
    


  /**
   * Reference to a field of type 'TenantType[]'
   */
  export type ListEnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType[]'>
    


  /**
   * Reference to a field of type 'TenantStatus'
   */
  export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


  /**
   * Reference to a field of type 'TenantStatus[]'
   */
  export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'StockMovementType'
   */
  export type EnumStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockMovementType'>
    


  /**
   * Reference to a field of type 'StockMovementType[]'
   */
  export type ListEnumStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockMovementType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'OfferStatus'
   */
  export type EnumOfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferStatus'>
    


  /**
   * Reference to a field of type 'OfferStatus[]'
   */
  export type ListEnumOfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceStatus'
   */
  export type EnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus'>
    


  /**
   * Reference to a field of type 'ServiceStatus[]'
   */
  export type ListEnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SubscriptionPackageWhereInput = {
    AND?: SubscriptionPackageWhereInput | SubscriptionPackageWhereInput[]
    OR?: SubscriptionPackageWhereInput[]
    NOT?: SubscriptionPackageWhereInput | SubscriptionPackageWhereInput[]
    id?: StringFilter<"SubscriptionPackage"> | string
    name?: StringFilter<"SubscriptionPackage"> | string
    description?: StringNullableFilter<"SubscriptionPackage"> | string | null
    priceMonthly?: DecimalFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFilter<"SubscriptionPackage"> | number
    maxProducts?: IntFilter<"SubscriptionPackage"> | number
    storageLimit?: StringFilter<"SubscriptionPackage"> | string
    features?: JsonNullableFilter<"SubscriptionPackage">
    isPopular?: BoolFilter<"SubscriptionPackage"> | boolean
    isActive?: BoolFilter<"SubscriptionPackage"> | boolean
    sortOrder?: IntFilter<"SubscriptionPackage"> | number
    isDemo?: BoolFilter<"SubscriptionPackage"> | boolean
    demoDuration?: IntFilter<"SubscriptionPackage"> | number
    discountPercentage?: DecimalFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    discountEndDate?: DateTimeNullableFilter<"SubscriptionPackage"> | Date | string | null
    highlightColor?: StringNullableFilter<"SubscriptionPackage"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionPackage"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPackage"> | Date | string
    tenants?: TenantListRelationFilter
    modules?: PackageModuleListRelationFilter
  }

  export type SubscriptionPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    storageLimit?: SortOrder
    features?: SortOrderInput | SortOrder
    isPopular?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    isDemo?: SortOrder
    demoDuration?: SortOrder
    discountPercentage?: SortOrder
    discountEndDate?: SortOrderInput | SortOrder
    highlightColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenants?: TenantOrderByRelationAggregateInput
    modules?: PackageModuleOrderByRelationAggregateInput
  }

  export type SubscriptionPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionPackageWhereInput | SubscriptionPackageWhereInput[]
    OR?: SubscriptionPackageWhereInput[]
    NOT?: SubscriptionPackageWhereInput | SubscriptionPackageWhereInput[]
    name?: StringFilter<"SubscriptionPackage"> | string
    description?: StringNullableFilter<"SubscriptionPackage"> | string | null
    priceMonthly?: DecimalFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFilter<"SubscriptionPackage"> | number
    maxProducts?: IntFilter<"SubscriptionPackage"> | number
    storageLimit?: StringFilter<"SubscriptionPackage"> | string
    features?: JsonNullableFilter<"SubscriptionPackage">
    isPopular?: BoolFilter<"SubscriptionPackage"> | boolean
    isActive?: BoolFilter<"SubscriptionPackage"> | boolean
    sortOrder?: IntFilter<"SubscriptionPackage"> | number
    isDemo?: BoolFilter<"SubscriptionPackage"> | boolean
    demoDuration?: IntFilter<"SubscriptionPackage"> | number
    discountPercentage?: DecimalFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    discountEndDate?: DateTimeNullableFilter<"SubscriptionPackage"> | Date | string | null
    highlightColor?: StringNullableFilter<"SubscriptionPackage"> | string | null
    createdAt?: DateTimeFilter<"SubscriptionPackage"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPackage"> | Date | string
    tenants?: TenantListRelationFilter
    modules?: PackageModuleListRelationFilter
  }, "id">

  export type SubscriptionPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    storageLimit?: SortOrder
    features?: SortOrderInput | SortOrder
    isPopular?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    isDemo?: SortOrder
    demoDuration?: SortOrder
    discountPercentage?: SortOrder
    discountEndDate?: SortOrderInput | SortOrder
    highlightColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPackageCountOrderByAggregateInput
    _avg?: SubscriptionPackageAvgOrderByAggregateInput
    _max?: SubscriptionPackageMaxOrderByAggregateInput
    _min?: SubscriptionPackageMinOrderByAggregateInput
    _sum?: SubscriptionPackageSumOrderByAggregateInput
  }

  export type SubscriptionPackageScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPackageScalarWhereWithAggregatesInput | SubscriptionPackageScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPackageScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPackageScalarWhereWithAggregatesInput | SubscriptionPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionPackage"> | string
    name?: StringWithAggregatesFilter<"SubscriptionPackage"> | string
    description?: StringNullableWithAggregatesFilter<"SubscriptionPackage"> | string | null
    priceMonthly?: DecimalWithAggregatesFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalWithAggregatesFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    maxUsers?: IntWithAggregatesFilter<"SubscriptionPackage"> | number
    maxProducts?: IntWithAggregatesFilter<"SubscriptionPackage"> | number
    storageLimit?: StringWithAggregatesFilter<"SubscriptionPackage"> | string
    features?: JsonNullableWithAggregatesFilter<"SubscriptionPackage">
    isPopular?: BoolWithAggregatesFilter<"SubscriptionPackage"> | boolean
    isActive?: BoolWithAggregatesFilter<"SubscriptionPackage"> | boolean
    sortOrder?: IntWithAggregatesFilter<"SubscriptionPackage"> | number
    isDemo?: BoolWithAggregatesFilter<"SubscriptionPackage"> | boolean
    demoDuration?: IntWithAggregatesFilter<"SubscriptionPackage"> | number
    discountPercentage?: DecimalWithAggregatesFilter<"SubscriptionPackage"> | Decimal | DecimalJsLike | number | string
    discountEndDate?: DateTimeNullableWithAggregatesFilter<"SubscriptionPackage"> | Date | string | null
    highlightColor?: StringNullableWithAggregatesFilter<"SubscriptionPackage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPackage"> | Date | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    tag?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    taxNumber?: StringNullableFilter<"Tenant"> | string | null
    taxOffice?: StringNullableFilter<"Tenant"> | string | null
    contactEmail?: StringNullableFilter<"Tenant"> | string | null
    contactPhone?: StringNullableFilter<"Tenant"> | string | null
    address?: JsonNullableFilter<"Tenant">
    subscriptionPlanId?: StringNullableFilter<"Tenant"> | string | null
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    subscriptionStart?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    config?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    subscriptionPackage?: XOR<SubscriptionPackageNullableRelationFilter, SubscriptionPackageWhereInput> | null
    users?: UserListRelationFilter
    accounts?: AccountListRelationFilter
    products?: ProductListRelationFilter
    invoices?: InvoiceListRelationFilter
    offers?: OfferListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    transactions?: TransactionListRelationFilter
    serviceTickets?: ServiceTicketListRelationFilter
    cashRegisters?: CashRegisterListRelationFilter
    employees?: EmployeeListRelationFilter
    payments?: SaaSPaymentListRelationFilter
    integrations?: IntegrationListRelationFilter
    templates?: TemplateListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    taxNumber?: SortOrderInput | SortOrder
    taxOffice?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subscriptionPlanId?: SortOrderInput | SortOrder
    status?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptionPackage?: SubscriptionPackageOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    serviceTickets?: ServiceTicketOrderByRelationAggregateInput
    cashRegisters?: CashRegisterOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    payments?: SaaSPaymentOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    templates?: TemplateOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    taxNumber?: StringNullableFilter<"Tenant"> | string | null
    taxOffice?: StringNullableFilter<"Tenant"> | string | null
    contactEmail?: StringNullableFilter<"Tenant"> | string | null
    contactPhone?: StringNullableFilter<"Tenant"> | string | null
    address?: JsonNullableFilter<"Tenant">
    subscriptionPlanId?: StringNullableFilter<"Tenant"> | string | null
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    subscriptionStart?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    config?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    subscriptionPackage?: XOR<SubscriptionPackageNullableRelationFilter, SubscriptionPackageWhereInput> | null
    users?: UserListRelationFilter
    accounts?: AccountListRelationFilter
    products?: ProductListRelationFilter
    invoices?: InvoiceListRelationFilter
    offers?: OfferListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    transactions?: TransactionListRelationFilter
    serviceTickets?: ServiceTicketListRelationFilter
    cashRegisters?: CashRegisterListRelationFilter
    employees?: EmployeeListRelationFilter
    payments?: SaaSPaymentListRelationFilter
    integrations?: IntegrationListRelationFilter
    templates?: TemplateListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }, "id" | "tag">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    taxNumber?: SortOrderInput | SortOrder
    taxOffice?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subscriptionPlanId?: SortOrderInput | SortOrder
    status?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    tag?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    type?: EnumTenantTypeWithAggregatesFilter<"Tenant"> | $Enums.TenantType
    taxNumber?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    taxOffice?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    address?: JsonNullableWithAggregatesFilter<"Tenant">
    subscriptionPlanId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    status?: EnumTenantStatusWithAggregatesFilter<"Tenant"> | $Enums.TenantStatus
    subscriptionStart?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    subscriptionEnd?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    config?: JsonNullableWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type SaaSPaymentWhereInput = {
    AND?: SaaSPaymentWhereInput | SaaSPaymentWhereInput[]
    OR?: SaaSPaymentWhereInput[]
    NOT?: SaaSPaymentWhereInput | SaaSPaymentWhereInput[]
    id?: StringFilter<"SaaSPayment"> | string
    tenantId?: StringFilter<"SaaSPayment"> | string
    amount?: DecimalFilter<"SaaSPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"SaaSPayment"> | Date | string
    description?: StringNullableFilter<"SaaSPayment"> | string | null
    status?: StringFilter<"SaaSPayment"> | string
    createdAt?: DateTimeFilter<"SaaSPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SaaSPayment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type SaaSPaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type SaaSPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaaSPaymentWhereInput | SaaSPaymentWhereInput[]
    OR?: SaaSPaymentWhereInput[]
    NOT?: SaaSPaymentWhereInput | SaaSPaymentWhereInput[]
    tenantId?: StringFilter<"SaaSPayment"> | string
    amount?: DecimalFilter<"SaaSPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"SaaSPayment"> | Date | string
    description?: StringNullableFilter<"SaaSPayment"> | string | null
    status?: StringFilter<"SaaSPayment"> | string
    createdAt?: DateTimeFilter<"SaaSPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SaaSPayment"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type SaaSPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaaSPaymentCountOrderByAggregateInput
    _avg?: SaaSPaymentAvgOrderByAggregateInput
    _max?: SaaSPaymentMaxOrderByAggregateInput
    _min?: SaaSPaymentMinOrderByAggregateInput
    _sum?: SaaSPaymentSumOrderByAggregateInput
  }

  export type SaaSPaymentScalarWhereWithAggregatesInput = {
    AND?: SaaSPaymentScalarWhereWithAggregatesInput | SaaSPaymentScalarWhereWithAggregatesInput[]
    OR?: SaaSPaymentScalarWhereWithAggregatesInput[]
    NOT?: SaaSPaymentScalarWhereWithAggregatesInput | SaaSPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaaSPayment"> | string
    tenantId?: StringWithAggregatesFilter<"SaaSPayment"> | string
    amount?: DecimalWithAggregatesFilter<"SaaSPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"SaaSPayment"> | Date | string
    description?: StringNullableWithAggregatesFilter<"SaaSPayment"> | string | null
    status?: StringWithAggregatesFilter<"SaaSPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SaaSPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaaSPayment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    userNo?: IntFilter<"User"> | number
    tenantId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    permissions?: JsonNullableFilter<"User">
    bio?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isTwoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isSuperAdmin?: BoolFilter<"User"> | boolean
    superAdminRoleId?: StringNullableFilter<"User"> | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    superAdminRole?: XOR<SuperAdminRoleNullableRelationFilter, SuperAdminRoleWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    userNo?: SortOrder
    tenantId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorExpires?: SortOrderInput | SortOrder
    isSuperAdmin?: SortOrder
    superAdminRoleId?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    superAdminRole?: SuperAdminRoleOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userNo?: number
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    permissions?: JsonNullableFilter<"User">
    bio?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isTwoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isSuperAdmin?: BoolFilter<"User"> | boolean
    superAdminRoleId?: StringNullableFilter<"User"> | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    superAdminRole?: XOR<SuperAdminRoleNullableRelationFilter, SuperAdminRoleWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "userNo" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    userNo?: SortOrder
    tenantId?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    permissions?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorExpires?: SortOrderInput | SortOrder
    isSuperAdmin?: SortOrder
    superAdminRoleId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    userNo?: IntWithAggregatesFilter<"User"> | number
    tenantId?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    permissions?: JsonNullableWithAggregatesFilter<"User">
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isTwoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorMethod?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isSuperAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    superAdminRoleId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    tenantId?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    accountCode?: StringNullableFilter<"Account"> | string | null
    name?: StringFilter<"Account"> | string
    balance?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    riskLimit?: DecimalNullableFilter<"Account"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    invoices?: InvoiceListRelationFilter
    offers?: OfferListRelationFilter
    transactions?: TransactionListRelationFilter
    serviceTickets?: ServiceTicketListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    accountCode?: SortOrderInput | SortOrder
    name?: SortOrder
    balance?: SortOrder
    riskLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    serviceTickets?: ServiceTicketOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    tenantId?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    accountCode?: StringNullableFilter<"Account"> | string | null
    name?: StringFilter<"Account"> | string
    balance?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    riskLimit?: DecimalNullableFilter<"Account"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    invoices?: InvoiceListRelationFilter
    offers?: OfferListRelationFilter
    transactions?: TransactionListRelationFilter
    serviceTickets?: ServiceTicketListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    accountCode?: SortOrderInput | SortOrder
    name?: SortOrder
    balance?: SortOrder
    riskLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    tenantId?: StringWithAggregatesFilter<"Account"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    accountCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    name?: StringWithAggregatesFilter<"Account"> | string
    balance?: DecimalWithAggregatesFilter<"Account"> | Decimal | DecimalJsLike | number | string
    riskLimit?: DecimalNullableWithAggregatesFilter<"Account"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    tenantId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    barcode?: StringNullableFilter<"Product"> | string | null
    stockQuantity?: IntFilter<"Product"> | number
    priceSell?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    stockMovements?: StockMovementListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    serviceParts?: ServicePartListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    priceSell?: SortOrder
    trackStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    serviceParts?: ServicePartOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    tenantId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    barcode?: StringNullableFilter<"Product"> | string | null
    stockQuantity?: IntFilter<"Product"> | number
    priceSell?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    stockMovements?: StockMovementListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    serviceParts?: ServicePartListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    stockQuantity?: SortOrder
    priceSell?: SortOrder
    trackStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    tenantId?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringNullableWithAggregatesFilter<"Product"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stockQuantity?: IntWithAggregatesFilter<"Product"> | number
    priceSell?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    trackStock?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    tenantId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    type?: EnumStockMovementTypeFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockMovement"> | number
    documentRef?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    documentRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    tenantId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    type?: EnumStockMovementTypeFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockMovement"> | number
    documentRef?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    documentRef?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockMovement"> | string
    tenantId?: StringWithAggregatesFilter<"StockMovement"> | string
    productId?: StringWithAggregatesFilter<"StockMovement"> | string
    type?: EnumStockMovementTypeWithAggregatesFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntWithAggregatesFilter<"StockMovement"> | number
    documentRef?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type CashRegisterWhereInput = {
    AND?: CashRegisterWhereInput | CashRegisterWhereInput[]
    OR?: CashRegisterWhereInput[]
    NOT?: CashRegisterWhereInput | CashRegisterWhereInput[]
    id?: StringFilter<"CashRegister"> | string
    tenantId?: StringFilter<"CashRegister"> | string
    name?: StringFilter<"CashRegister"> | string
    currency?: StringFilter<"CashRegister"> | string
    balance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CashRegister"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
    posSessions?: PosSessionListRelationFilter
  }

  export type CashRegisterOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    posSessions?: PosSessionOrderByRelationAggregateInput
  }

  export type CashRegisterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashRegisterWhereInput | CashRegisterWhereInput[]
    OR?: CashRegisterWhereInput[]
    NOT?: CashRegisterWhereInput | CashRegisterWhereInput[]
    tenantId?: StringFilter<"CashRegister"> | string
    name?: StringFilter<"CashRegister"> | string
    currency?: StringFilter<"CashRegister"> | string
    balance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CashRegister"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
    posSessions?: PosSessionListRelationFilter
  }, "id">

  export type CashRegisterOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    _count?: CashRegisterCountOrderByAggregateInput
    _avg?: CashRegisterAvgOrderByAggregateInput
    _max?: CashRegisterMaxOrderByAggregateInput
    _min?: CashRegisterMinOrderByAggregateInput
    _sum?: CashRegisterSumOrderByAggregateInput
  }

  export type CashRegisterScalarWhereWithAggregatesInput = {
    AND?: CashRegisterScalarWhereWithAggregatesInput | CashRegisterScalarWhereWithAggregatesInput[]
    OR?: CashRegisterScalarWhereWithAggregatesInput[]
    NOT?: CashRegisterScalarWhereWithAggregatesInput | CashRegisterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashRegister"> | string
    tenantId?: StringWithAggregatesFilter<"CashRegister"> | string
    name?: StringWithAggregatesFilter<"CashRegister"> | string
    currency?: StringWithAggregatesFilter<"CashRegister"> | string
    balance?: DecimalWithAggregatesFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"CashRegister"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    registerId?: StringFilter<"Transaction"> | string
    accountId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    exchangeRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Transaction"> | string | null
    relatedId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    register?: XOR<CashRegisterRelationFilter, CashRegisterWhereInput>
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    register?: CashRegisterOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    tenantId?: StringFilter<"Transaction"> | string
    registerId?: StringFilter<"Transaction"> | string
    accountId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    exchangeRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Transaction"> | string | null
    relatedId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    register?: XOR<CashRegisterRelationFilter, CashRegisterWhereInput>
    account?: XOR<AccountNullableRelationFilter, AccountWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    tenantId?: StringWithAggregatesFilter<"Transaction"> | string
    registerId?: StringWithAggregatesFilter<"Transaction"> | string
    accountId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    exchangeRate?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    relatedId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    accountId?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    items?: InvoiceItemListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    tenantId?: StringFilter<"Invoice"> | string
    accountId?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    items?: InvoiceItemListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    accountId?: StringWithAggregatesFilter<"Invoice"> | string
    type?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: StringFilter<"Offer"> | string
    tenantId?: StringFilter<"Offer"> | string
    accountId?: StringFilter<"Offer"> | string
    totalAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    validUntil?: DateTimeNullableFilter<"Offer"> | Date | string | null
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    items?: InvoiceItemListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    tenantId?: StringFilter<"Offer"> | string
    accountId?: StringFilter<"Offer"> | string
    totalAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    validUntil?: DateTimeNullableFilter<"Offer"> | Date | string | null
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    items?: InvoiceItemListRelationFilter
  }, "id">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offer"> | string
    tenantId?: StringWithAggregatesFilter<"Offer"> | string
    accountId?: StringWithAggregatesFilter<"Offer"> | string
    totalAmount?: DecimalWithAggregatesFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusWithAggregatesFilter<"Offer"> | $Enums.OfferStatus
    validUntil?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringNullableFilter<"InvoiceItem"> | string | null
    offerId?: StringNullableFilter<"InvoiceItem"> | string | null
    productId?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    price?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    offer?: XOR<OfferNullableRelationFilter, OfferWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringNullableFilter<"InvoiceItem"> | string | null
    offerId?: StringNullableFilter<"InvoiceItem"> | string | null
    productId?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    price?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    offer?: XOR<OfferNullableRelationFilter, OfferWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    offerId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    offerId?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    productId?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    name?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    price?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type PosSessionWhereInput = {
    AND?: PosSessionWhereInput | PosSessionWhereInput[]
    OR?: PosSessionWhereInput[]
    NOT?: PosSessionWhereInput | PosSessionWhereInput[]
    id?: StringFilter<"PosSession"> | string
    tenantId?: StringFilter<"PosSession"> | string
    registerId?: StringFilter<"PosSession"> | string
    employeeId?: StringNullableFilter<"PosSession"> | string | null
    openedAt?: DateTimeFilter<"PosSession"> | Date | string
    closedAt?: DateTimeNullableFilter<"PosSession"> | Date | string | null
    openingBalance?: DecimalFilter<"PosSession"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalNullableFilter<"PosSession"> | Decimal | DecimalJsLike | number | string | null
    register?: XOR<CashRegisterRelationFilter, CashRegisterWhereInput>
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }

  export type PosSessionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrderInput | SortOrder
    register?: CashRegisterOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PosSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosSessionWhereInput | PosSessionWhereInput[]
    OR?: PosSessionWhereInput[]
    NOT?: PosSessionWhereInput | PosSessionWhereInput[]
    tenantId?: StringFilter<"PosSession"> | string
    registerId?: StringFilter<"PosSession"> | string
    employeeId?: StringNullableFilter<"PosSession"> | string | null
    openedAt?: DateTimeFilter<"PosSession"> | Date | string
    closedAt?: DateTimeNullableFilter<"PosSession"> | Date | string | null
    openingBalance?: DecimalFilter<"PosSession"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalNullableFilter<"PosSession"> | Decimal | DecimalJsLike | number | string | null
    register?: XOR<CashRegisterRelationFilter, CashRegisterWhereInput>
    employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }, "id">

  export type PosSessionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrderInput | SortOrder
    _count?: PosSessionCountOrderByAggregateInput
    _avg?: PosSessionAvgOrderByAggregateInput
    _max?: PosSessionMaxOrderByAggregateInput
    _min?: PosSessionMinOrderByAggregateInput
    _sum?: PosSessionSumOrderByAggregateInput
  }

  export type PosSessionScalarWhereWithAggregatesInput = {
    AND?: PosSessionScalarWhereWithAggregatesInput | PosSessionScalarWhereWithAggregatesInput[]
    OR?: PosSessionScalarWhereWithAggregatesInput[]
    NOT?: PosSessionScalarWhereWithAggregatesInput | PosSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PosSession"> | string
    tenantId?: StringWithAggregatesFilter<"PosSession"> | string
    registerId?: StringWithAggregatesFilter<"PosSession"> | string
    employeeId?: StringNullableWithAggregatesFilter<"PosSession"> | string | null
    openedAt?: DateTimeWithAggregatesFilter<"PosSession"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"PosSession"> | Date | string | null
    openingBalance?: DecimalWithAggregatesFilter<"PosSession"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalNullableWithAggregatesFilter<"PosSession"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceTicketWhereInput = {
    AND?: ServiceTicketWhereInput | ServiceTicketWhereInput[]
    OR?: ServiceTicketWhereInput[]
    NOT?: ServiceTicketWhereInput | ServiceTicketWhereInput[]
    id?: StringFilter<"ServiceTicket"> | string
    tenantId?: StringFilter<"ServiceTicket"> | string
    customerId?: StringFilter<"ServiceTicket"> | string
    technicianId?: StringNullableFilter<"ServiceTicket"> | string | null
    deviceInfo?: JsonNullableFilter<"ServiceTicket">
    problemDesc?: StringNullableFilter<"ServiceTicket"> | string | null
    status?: EnumServiceStatusFilter<"ServiceTicket"> | $Enums.ServiceStatus
    estimatedCost?: DecimalNullableFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    finalCost?: DecimalNullableFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ServiceTicket"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTicket"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    customer?: XOR<AccountRelationFilter, AccountWhereInput>
    technician?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    parts?: ServicePartListRelationFilter
    history?: ServiceHistoryListRelationFilter
  }

  export type ServiceTicketOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    technicianId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    problemDesc?: SortOrderInput | SortOrder
    status?: SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    finalCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    customer?: AccountOrderByWithRelationInput
    technician?: EmployeeOrderByWithRelationInput
    parts?: ServicePartOrderByRelationAggregateInput
    history?: ServiceHistoryOrderByRelationAggregateInput
  }

  export type ServiceTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceTicketWhereInput | ServiceTicketWhereInput[]
    OR?: ServiceTicketWhereInput[]
    NOT?: ServiceTicketWhereInput | ServiceTicketWhereInput[]
    tenantId?: StringFilter<"ServiceTicket"> | string
    customerId?: StringFilter<"ServiceTicket"> | string
    technicianId?: StringNullableFilter<"ServiceTicket"> | string | null
    deviceInfo?: JsonNullableFilter<"ServiceTicket">
    problemDesc?: StringNullableFilter<"ServiceTicket"> | string | null
    status?: EnumServiceStatusFilter<"ServiceTicket"> | $Enums.ServiceStatus
    estimatedCost?: DecimalNullableFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    finalCost?: DecimalNullableFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ServiceTicket"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTicket"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    customer?: XOR<AccountRelationFilter, AccountWhereInput>
    technician?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    parts?: ServicePartListRelationFilter
    history?: ServiceHistoryListRelationFilter
  }, "id">

  export type ServiceTicketOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    technicianId?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    problemDesc?: SortOrderInput | SortOrder
    status?: SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    finalCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTicketCountOrderByAggregateInput
    _avg?: ServiceTicketAvgOrderByAggregateInput
    _max?: ServiceTicketMaxOrderByAggregateInput
    _min?: ServiceTicketMinOrderByAggregateInput
    _sum?: ServiceTicketSumOrderByAggregateInput
  }

  export type ServiceTicketScalarWhereWithAggregatesInput = {
    AND?: ServiceTicketScalarWhereWithAggregatesInput | ServiceTicketScalarWhereWithAggregatesInput[]
    OR?: ServiceTicketScalarWhereWithAggregatesInput[]
    NOT?: ServiceTicketScalarWhereWithAggregatesInput | ServiceTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceTicket"> | string
    tenantId?: StringWithAggregatesFilter<"ServiceTicket"> | string
    customerId?: StringWithAggregatesFilter<"ServiceTicket"> | string
    technicianId?: StringNullableWithAggregatesFilter<"ServiceTicket"> | string | null
    deviceInfo?: JsonNullableWithAggregatesFilter<"ServiceTicket">
    problemDesc?: StringNullableWithAggregatesFilter<"ServiceTicket"> | string | null
    status?: EnumServiceStatusWithAggregatesFilter<"ServiceTicket"> | $Enums.ServiceStatus
    estimatedCost?: DecimalNullableWithAggregatesFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    finalCost?: DecimalNullableWithAggregatesFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceTicket"> | Date | string
  }

  export type ServicePartWhereInput = {
    AND?: ServicePartWhereInput | ServicePartWhereInput[]
    OR?: ServicePartWhereInput[]
    NOT?: ServicePartWhereInput | ServicePartWhereInput[]
    id?: StringFilter<"ServicePart"> | string
    serviceTicketId?: StringFilter<"ServicePart"> | string
    productId?: StringFilter<"ServicePart"> | string
    quantity?: IntFilter<"ServicePart"> | number
    price?: DecimalFilter<"ServicePart"> | Decimal | DecimalJsLike | number | string
    serviceTicket?: XOR<ServiceTicketRelationFilter, ServiceTicketWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ServicePartOrderByWithRelationInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    serviceTicket?: ServiceTicketOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ServicePartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServicePartWhereInput | ServicePartWhereInput[]
    OR?: ServicePartWhereInput[]
    NOT?: ServicePartWhereInput | ServicePartWhereInput[]
    serviceTicketId?: StringFilter<"ServicePart"> | string
    productId?: StringFilter<"ServicePart"> | string
    quantity?: IntFilter<"ServicePart"> | number
    price?: DecimalFilter<"ServicePart"> | Decimal | DecimalJsLike | number | string
    serviceTicket?: XOR<ServiceTicketRelationFilter, ServiceTicketWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type ServicePartOrderByWithAggregationInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    _count?: ServicePartCountOrderByAggregateInput
    _avg?: ServicePartAvgOrderByAggregateInput
    _max?: ServicePartMaxOrderByAggregateInput
    _min?: ServicePartMinOrderByAggregateInput
    _sum?: ServicePartSumOrderByAggregateInput
  }

  export type ServicePartScalarWhereWithAggregatesInput = {
    AND?: ServicePartScalarWhereWithAggregatesInput | ServicePartScalarWhereWithAggregatesInput[]
    OR?: ServicePartScalarWhereWithAggregatesInput[]
    NOT?: ServicePartScalarWhereWithAggregatesInput | ServicePartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicePart"> | string
    serviceTicketId?: StringWithAggregatesFilter<"ServicePart"> | string
    productId?: StringWithAggregatesFilter<"ServicePart"> | string
    quantity?: IntWithAggregatesFilter<"ServicePart"> | number
    price?: DecimalWithAggregatesFilter<"ServicePart"> | Decimal | DecimalJsLike | number | string
  }

  export type ServiceHistoryWhereInput = {
    AND?: ServiceHistoryWhereInput | ServiceHistoryWhereInput[]
    OR?: ServiceHistoryWhereInput[]
    NOT?: ServiceHistoryWhereInput | ServiceHistoryWhereInput[]
    id?: StringFilter<"ServiceHistory"> | string
    serviceTicketId?: StringFilter<"ServiceHistory"> | string
    status?: EnumServiceStatusFilter<"ServiceHistory"> | $Enums.ServiceStatus
    note?: StringNullableFilter<"ServiceHistory"> | string | null
    changedBy?: StringNullableFilter<"ServiceHistory"> | string | null
    createdAt?: DateTimeFilter<"ServiceHistory"> | Date | string
    serviceTicket?: XOR<ServiceTicketRelationFilter, ServiceTicketWhereInput>
  }

  export type ServiceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    serviceTicket?: ServiceTicketOrderByWithRelationInput
  }

  export type ServiceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceHistoryWhereInput | ServiceHistoryWhereInput[]
    OR?: ServiceHistoryWhereInput[]
    NOT?: ServiceHistoryWhereInput | ServiceHistoryWhereInput[]
    serviceTicketId?: StringFilter<"ServiceHistory"> | string
    status?: EnumServiceStatusFilter<"ServiceHistory"> | $Enums.ServiceStatus
    note?: StringNullableFilter<"ServiceHistory"> | string | null
    changedBy?: StringNullableFilter<"ServiceHistory"> | string | null
    createdAt?: DateTimeFilter<"ServiceHistory"> | Date | string
    serviceTicket?: XOR<ServiceTicketRelationFilter, ServiceTicketWhereInput>
  }, "id">

  export type ServiceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceHistoryCountOrderByAggregateInput
    _max?: ServiceHistoryMaxOrderByAggregateInput
    _min?: ServiceHistoryMinOrderByAggregateInput
  }

  export type ServiceHistoryScalarWhereWithAggregatesInput = {
    AND?: ServiceHistoryScalarWhereWithAggregatesInput | ServiceHistoryScalarWhereWithAggregatesInput[]
    OR?: ServiceHistoryScalarWhereWithAggregatesInput[]
    NOT?: ServiceHistoryScalarWhereWithAggregatesInput | ServiceHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceHistory"> | string
    serviceTicketId?: StringWithAggregatesFilter<"ServiceHistory"> | string
    status?: EnumServiceStatusWithAggregatesFilter<"ServiceHistory"> | $Enums.ServiceStatus
    note?: StringNullableWithAggregatesFilter<"ServiceHistory"> | string | null
    changedBy?: StringNullableWithAggregatesFilter<"ServiceHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceHistory"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    tenantId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    tickets?: ServiceTicketListRelationFilter
    posSessions?: PosSessionListRelationFilter
    payrolls?: PayrollListRelationFilter
    leaves?: LeaveRequestListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    tickets?: ServiceTicketOrderByRelationAggregateInput
    posSessions?: PosSessionOrderByRelationAggregateInput
    payrolls?: PayrollOrderByRelationAggregateInput
    leaves?: LeaveRequestOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    tenantId?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    tickets?: ServiceTicketListRelationFilter
    posSessions?: PosSessionListRelationFilter
    payrolls?: PayrollListRelationFilter
    leaves?: LeaveRequestListRelationFilter
  }, "id" | "userId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    tenantId?: StringWithAggregatesFilter<"Employee"> | string
    userId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    position?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    salary?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    employeeId?: StringFilter<"Payroll"> | string
    month?: StringFilter<"Payroll"> | string
    amount?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"Payroll"> | boolean
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    employeeId?: StringFilter<"Payroll"> | string
    month?: StringFilter<"Payroll"> | string
    amount?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"Payroll"> | boolean
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    employeeId?: StringWithAggregatesFilter<"Payroll"> | string
    month?: StringWithAggregatesFilter<"Payroll"> | string
    amount?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolWithAggregatesFilter<"Payroll"> | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    employeeId?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusWithAggregatesFilter<"LeaveRequest"> | $Enums.LeaveStatus
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: JsonFilter<"SystemConfig">
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: JsonFilter<"SystemConfig">
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: JsonWithAggregatesFilter<"SystemConfig">
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    code?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    icon?: StringNullableFilter<"Module"> | string | null
    isActive?: BoolFilter<"Module"> | boolean
    sortOrder?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    packages?: PackageModuleListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    packages?: PackageModuleOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    icon?: StringNullableFilter<"Module"> | string | null
    isActive?: BoolFilter<"Module"> | boolean
    sortOrder?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    packages?: PackageModuleListRelationFilter
  }, "id" | "code">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    code?: StringWithAggregatesFilter<"Module"> | string
    name?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Module"> | string | null
    isActive?: BoolWithAggregatesFilter<"Module"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Module"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type PackageModuleWhereInput = {
    AND?: PackageModuleWhereInput | PackageModuleWhereInput[]
    OR?: PackageModuleWhereInput[]
    NOT?: PackageModuleWhereInput | PackageModuleWhereInput[]
    id?: StringFilter<"PackageModule"> | string
    packageId?: StringFilter<"PackageModule"> | string
    moduleId?: StringFilter<"PackageModule"> | string
    package?: XOR<SubscriptionPackageRelationFilter, SubscriptionPackageWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type PackageModuleOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    moduleId?: SortOrder
    package?: SubscriptionPackageOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type PackageModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    packageId_moduleId?: PackageModulePackageIdModuleIdCompoundUniqueInput
    AND?: PackageModuleWhereInput | PackageModuleWhereInput[]
    OR?: PackageModuleWhereInput[]
    NOT?: PackageModuleWhereInput | PackageModuleWhereInput[]
    packageId?: StringFilter<"PackageModule"> | string
    moduleId?: StringFilter<"PackageModule"> | string
    package?: XOR<SubscriptionPackageRelationFilter, SubscriptionPackageWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id" | "packageId_moduleId">

  export type PackageModuleOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    moduleId?: SortOrder
    _count?: PackageModuleCountOrderByAggregateInput
    _max?: PackageModuleMaxOrderByAggregateInput
    _min?: PackageModuleMinOrderByAggregateInput
  }

  export type PackageModuleScalarWhereWithAggregatesInput = {
    AND?: PackageModuleScalarWhereWithAggregatesInput | PackageModuleScalarWhereWithAggregatesInput[]
    OR?: PackageModuleScalarWhereWithAggregatesInput[]
    NOT?: PackageModuleScalarWhereWithAggregatesInput | PackageModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackageModule"> | string
    packageId?: StringWithAggregatesFilter<"PackageModule"> | string
    moduleId?: StringWithAggregatesFilter<"PackageModule"> | string
  }

  export type SuperAdminRoleWhereInput = {
    AND?: SuperAdminRoleWhereInput | SuperAdminRoleWhereInput[]
    OR?: SuperAdminRoleWhereInput[]
    NOT?: SuperAdminRoleWhereInput | SuperAdminRoleWhereInput[]
    id?: StringFilter<"SuperAdminRole"> | string
    name?: StringFilter<"SuperAdminRole"> | string
    description?: StringNullableFilter<"SuperAdminRole"> | string | null
    permissions?: JsonFilter<"SuperAdminRole">
    createdAt?: DateTimeFilter<"SuperAdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdminRole"> | Date | string
    users?: UserListRelationFilter
  }

  export type SuperAdminRoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type SuperAdminRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SuperAdminRoleWhereInput | SuperAdminRoleWhereInput[]
    OR?: SuperAdminRoleWhereInput[]
    NOT?: SuperAdminRoleWhereInput | SuperAdminRoleWhereInput[]
    description?: StringNullableFilter<"SuperAdminRole"> | string | null
    permissions?: JsonFilter<"SuperAdminRole">
    createdAt?: DateTimeFilter<"SuperAdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdminRole"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type SuperAdminRoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuperAdminRoleCountOrderByAggregateInput
    _max?: SuperAdminRoleMaxOrderByAggregateInput
    _min?: SuperAdminRoleMinOrderByAggregateInput
  }

  export type SuperAdminRoleScalarWhereWithAggregatesInput = {
    AND?: SuperAdminRoleScalarWhereWithAggregatesInput | SuperAdminRoleScalarWhereWithAggregatesInput[]
    OR?: SuperAdminRoleScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminRoleScalarWhereWithAggregatesInput | SuperAdminRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SuperAdminRole"> | string
    name?: StringWithAggregatesFilter<"SuperAdminRole"> | string
    description?: StringNullableWithAggregatesFilter<"SuperAdminRole"> | string | null
    permissions?: JsonWithAggregatesFilter<"SuperAdminRole">
    createdAt?: DateTimeWithAggregatesFilter<"SuperAdminRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuperAdminRole"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type LandingContentWhereInput = {
    AND?: LandingContentWhereInput | LandingContentWhereInput[]
    OR?: LandingContentWhereInput[]
    NOT?: LandingContentWhereInput | LandingContentWhereInput[]
    id?: StringFilter<"LandingContent"> | string
    section?: StringFilter<"LandingContent"> | string
    content?: JsonFilter<"LandingContent">
    isActive?: BoolFilter<"LandingContent"> | boolean
    updatedAt?: DateTimeFilter<"LandingContent"> | Date | string
  }

  export type LandingContentOrderByWithRelationInput = {
    id?: SortOrder
    section?: SortOrder
    content?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    section?: string
    AND?: LandingContentWhereInput | LandingContentWhereInput[]
    OR?: LandingContentWhereInput[]
    NOT?: LandingContentWhereInput | LandingContentWhereInput[]
    content?: JsonFilter<"LandingContent">
    isActive?: BoolFilter<"LandingContent"> | boolean
    updatedAt?: DateTimeFilter<"LandingContent"> | Date | string
  }, "id" | "section">

  export type LandingContentOrderByWithAggregationInput = {
    id?: SortOrder
    section?: SortOrder
    content?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    _count?: LandingContentCountOrderByAggregateInput
    _max?: LandingContentMaxOrderByAggregateInput
    _min?: LandingContentMinOrderByAggregateInput
  }

  export type LandingContentScalarWhereWithAggregatesInput = {
    AND?: LandingContentScalarWhereWithAggregatesInput | LandingContentScalarWhereWithAggregatesInput[]
    OR?: LandingContentScalarWhereWithAggregatesInput[]
    NOT?: LandingContentScalarWhereWithAggregatesInput | LandingContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LandingContent"> | string
    section?: StringWithAggregatesFilter<"LandingContent"> | string
    content?: JsonWithAggregatesFilter<"LandingContent">
    isActive?: BoolWithAggregatesFilter<"LandingContent"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"LandingContent"> | Date | string
  }

  export type PaymentProviderWhereInput = {
    AND?: PaymentProviderWhereInput | PaymentProviderWhereInput[]
    OR?: PaymentProviderWhereInput[]
    NOT?: PaymentProviderWhereInput | PaymentProviderWhereInput[]
    id?: StringFilter<"PaymentProvider"> | string
    provider?: StringFilter<"PaymentProvider"> | string
    displayName?: StringFilter<"PaymentProvider"> | string
    credentials?: JsonFilter<"PaymentProvider">
    isActive?: BoolFilter<"PaymentProvider"> | boolean
    config?: JsonNullableFilter<"PaymentProvider">
    createdAt?: DateTimeFilter<"PaymentProvider"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentProvider"> | Date | string
  }

  export type PaymentProviderOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    credentials?: SortOrder
    isActive?: SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider?: string
    AND?: PaymentProviderWhereInput | PaymentProviderWhereInput[]
    OR?: PaymentProviderWhereInput[]
    NOT?: PaymentProviderWhereInput | PaymentProviderWhereInput[]
    displayName?: StringFilter<"PaymentProvider"> | string
    credentials?: JsonFilter<"PaymentProvider">
    isActive?: BoolFilter<"PaymentProvider"> | boolean
    config?: JsonNullableFilter<"PaymentProvider">
    createdAt?: DateTimeFilter<"PaymentProvider"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentProvider"> | Date | string
  }, "id" | "provider">

  export type PaymentProviderOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    credentials?: SortOrder
    isActive?: SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentProviderCountOrderByAggregateInput
    _max?: PaymentProviderMaxOrderByAggregateInput
    _min?: PaymentProviderMinOrderByAggregateInput
  }

  export type PaymentProviderScalarWhereWithAggregatesInput = {
    AND?: PaymentProviderScalarWhereWithAggregatesInput | PaymentProviderScalarWhereWithAggregatesInput[]
    OR?: PaymentProviderScalarWhereWithAggregatesInput[]
    NOT?: PaymentProviderScalarWhereWithAggregatesInput | PaymentProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentProvider"> | string
    provider?: StringWithAggregatesFilter<"PaymentProvider"> | string
    displayName?: StringWithAggregatesFilter<"PaymentProvider"> | string
    credentials?: JsonWithAggregatesFilter<"PaymentProvider">
    isActive?: BoolWithAggregatesFilter<"PaymentProvider"> | boolean
    config?: JsonNullableWithAggregatesFilter<"PaymentProvider">
    createdAt?: DateTimeWithAggregatesFilter<"PaymentProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentProvider"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    bankName?: StringFilter<"BankAccount"> | string
    accountName?: StringFilter<"BankAccount"> | string
    iban?: StringFilter<"BankAccount"> | string
    currency?: StringFilter<"BankAccount"> | string
    isActive?: BoolFilter<"BankAccount"> | boolean
    sortOrder?: IntFilter<"BankAccount"> | number
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    iban?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    iban?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    bankName?: StringFilter<"BankAccount"> | string
    accountName?: StringFilter<"BankAccount"> | string
    currency?: StringFilter<"BankAccount"> | string
    isActive?: BoolFilter<"BankAccount"> | boolean
    sortOrder?: IntFilter<"BankAccount"> | number
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
  }, "id" | "iban">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    iban?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    bankName?: StringWithAggregatesFilter<"BankAccount"> | string
    accountName?: StringWithAggregatesFilter<"BankAccount"> | string
    iban?: StringWithAggregatesFilter<"BankAccount"> | string
    currency?: StringWithAggregatesFilter<"BankAccount"> | string
    isActive?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    sortOrder?: IntWithAggregatesFilter<"BankAccount"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    tenantId?: StringNullableFilter<"Integration"> | string | null
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    tenantId?: StringNullableFilter<"Integration"> | string | null
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    tenantId?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    type?: StringWithAggregatesFilter<"Integration"> | string
    name?: StringWithAggregatesFilter<"Integration"> | string
    config?: JsonWithAggregatesFilter<"Integration">
    isActive?: BoolWithAggregatesFilter<"Integration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: StringFilter<"Template"> | string
    tenantId?: StringNullableFilter<"Template"> | string | null
    type?: StringFilter<"Template"> | string
    code?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    subject?: StringNullableFilter<"Template"> | string | null
    content?: StringFilter<"Template"> | string
    isSystem?: BoolFilter<"Template"> | boolean
    isActive?: BoolFilter<"Template"> | boolean
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_type_code?: TemplateTenantIdTypeCodeCompoundUniqueInput
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    tenantId?: StringNullableFilter<"Template"> | string | null
    type?: StringFilter<"Template"> | string
    code?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    subject?: StringNullableFilter<"Template"> | string | null
    content?: StringFilter<"Template"> | string
    isSystem?: BoolFilter<"Template"> | boolean
    isActive?: BoolFilter<"Template"> | boolean
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id" | "tenantId_type_code">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Template"> | string
    tenantId?: StringNullableWithAggregatesFilter<"Template"> | string | null
    type?: StringWithAggregatesFilter<"Template"> | string
    code?: StringWithAggregatesFilter<"Template"> | string
    name?: StringWithAggregatesFilter<"Template"> | string
    subject?: StringNullableWithAggregatesFilter<"Template"> | string | null
    content?: StringWithAggregatesFilter<"Template"> | string
    isSystem?: BoolWithAggregatesFilter<"Template"> | boolean
    isActive?: BoolWithAggregatesFilter<"Template"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    tenantId?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    replies?: TicketReplyListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    replies?: TicketReplyOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    tenantId?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    replies?: TicketReplyListRelationFilter
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    tenantId?: StringWithAggregatesFilter<"SupportTicket"> | string
    userId?: StringWithAggregatesFilter<"SupportTicket"> | string
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    message?: StringWithAggregatesFilter<"SupportTicket"> | string
    category?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityWithAggregatesFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusWithAggregatesFilter<"SupportTicket"> | $Enums.TicketStatus
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type TicketReplyWhereInput = {
    AND?: TicketReplyWhereInput | TicketReplyWhereInput[]
    OR?: TicketReplyWhereInput[]
    NOT?: TicketReplyWhereInput | TicketReplyWhereInput[]
    id?: StringFilter<"TicketReply"> | string
    ticketId?: StringFilter<"TicketReply"> | string
    userId?: StringFilter<"TicketReply"> | string
    message?: StringFilter<"TicketReply"> | string
    isAdminReply?: BoolFilter<"TicketReply"> | boolean
    createdAt?: DateTimeFilter<"TicketReply"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
  }

  export type TicketReplyOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isAdminReply?: SortOrder
    createdAt?: SortOrder
    ticket?: SupportTicketOrderByWithRelationInput
  }

  export type TicketReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketReplyWhereInput | TicketReplyWhereInput[]
    OR?: TicketReplyWhereInput[]
    NOT?: TicketReplyWhereInput | TicketReplyWhereInput[]
    ticketId?: StringFilter<"TicketReply"> | string
    userId?: StringFilter<"TicketReply"> | string
    message?: StringFilter<"TicketReply"> | string
    isAdminReply?: BoolFilter<"TicketReply"> | boolean
    createdAt?: DateTimeFilter<"TicketReply"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
  }, "id">

  export type TicketReplyOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isAdminReply?: SortOrder
    createdAt?: SortOrder
    _count?: TicketReplyCountOrderByAggregateInput
    _max?: TicketReplyMaxOrderByAggregateInput
    _min?: TicketReplyMinOrderByAggregateInput
  }

  export type TicketReplyScalarWhereWithAggregatesInput = {
    AND?: TicketReplyScalarWhereWithAggregatesInput | TicketReplyScalarWhereWithAggregatesInput[]
    OR?: TicketReplyScalarWhereWithAggregatesInput[]
    NOT?: TicketReplyScalarWhereWithAggregatesInput | TicketReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketReply"> | string
    ticketId?: StringWithAggregatesFilter<"TicketReply"> | string
    userId?: StringWithAggregatesFilter<"TicketReply"> | string
    message?: StringWithAggregatesFilter<"TicketReply"> | string
    isAdminReply?: BoolWithAggregatesFilter<"TicketReply"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TicketReply"> | Date | string
  }

  export type SubscriptionPackageCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    maxUsers?: number
    maxProducts?: number
    storageLimit?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: number
    isDemo?: boolean
    demoDuration?: number
    discountPercentage?: Decimal | DecimalJsLike | number | string
    discountEndDate?: Date | string | null
    highlightColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenants?: TenantCreateNestedManyWithoutSubscriptionPackageInput
    modules?: PackageModuleCreateNestedManyWithoutPackageInput
  }

  export type SubscriptionPackageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    maxUsers?: number
    maxProducts?: number
    storageLimit?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: number
    isDemo?: boolean
    demoDuration?: number
    discountPercentage?: Decimal | DecimalJsLike | number | string
    discountEndDate?: Date | string | null
    highlightColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenants?: TenantUncheckedCreateNestedManyWithoutSubscriptionPackageInput
    modules?: PackageModuleUncheckedCreateNestedManyWithoutPackageInput
  }

  export type SubscriptionPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: TenantUpdateManyWithoutSubscriptionPackageNestedInput
    modules?: PackageModuleUpdateManyWithoutPackageNestedInput
  }

  export type SubscriptionPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: TenantUncheckedUpdateManyWithoutSubscriptionPackageNestedInput
    modules?: PackageModuleUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type SubscriptionPackageCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    maxUsers?: number
    maxProducts?: number
    storageLimit?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: number
    isDemo?: boolean
    demoDuration?: number
    discountPercentage?: Decimal | DecimalJsLike | number | string
    discountEndDate?: Date | string | null
    highlightColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaaSPaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type SaaSPaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaaSPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type SaaSPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaaSPaymentCreateManyInput = {
    id?: string
    tenantId: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaaSPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaaSPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    userNo?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    tenant: TenantCreateNestedOneWithoutUsersInput
    superAdminRole?: SuperAdminRoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userNo?: number
    tenantId: string
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    superAdminRoleId?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    superAdminRole?: SuperAdminRoleUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userNo?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    superAdminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    userNo?: number
    tenantId: string
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    superAdminRoleId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userNo?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    superAdminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAccountsInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    offers?: OfferCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutCustomerInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    offers?: OfferUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAccountsNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    offers?: OfferUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutCustomerNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    tenantId: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateInput = {
    id?: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockMovementsInput
    product: ProductCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: string
    tenantId: string
    productId: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    id?: string
    tenantId: string
    productId: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRegisterCreateInput = {
    id?: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
    transactions?: TransactionCreateNestedManyWithoutRegisterInput
    posSessions?: PosSessionCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRegisterInput
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
    transactions?: TransactionUpdateManyWithoutRegisterNestedInput
    posSessions?: PosSessionUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRegisterNestedInput
    posSessions?: PosSessionUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CashRegisterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRegisterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    register: CashRegisterCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    tenantId: string
    registerId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    register?: CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    tenantId: string
    registerId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    account: AccountCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    accountId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    account?: AccountUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    tenantId: string
    accountId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferCreateInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOffersInput
    account: AccountCreateNestedOneWithoutOffersInput
    items?: InvoiceItemCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    tenantId: string
    accountId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOffersNestedInput
    account?: AccountUpdateOneRequiredWithoutOffersNestedInput
    items?: InvoiceItemUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: string
    tenantId: string
    accountId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    invoice?: InvoiceCreateNestedOneWithoutItemsInput
    offer?: OfferCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId?: string | null
    offerId?: string | null
    productId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneWithoutItemsNestedInput
    offer?: OfferUpdateOneWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId?: string | null
    offerId?: string | null
    productId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PosSessionCreateInput = {
    id?: string
    tenantId: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
    register: CashRegisterCreateNestedOneWithoutPosSessionsInput
    employee?: EmployeeCreateNestedOneWithoutPosSessionsInput
  }

  export type PosSessionUncheckedCreateInput = {
    id?: string
    tenantId: string
    registerId: string
    employeeId?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    register?: CashRegisterUpdateOneRequiredWithoutPosSessionsNestedInput
    employee?: EmployeeUpdateOneWithoutPosSessionsNestedInput
  }

  export type PosSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionCreateManyInput = {
    id?: string
    tenantId: string
    registerId: string
    employeeId?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceTicketCreateInput = {
    id?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutServiceTicketsInput
    customer: AccountCreateNestedOneWithoutServiceTicketsInput
    technician?: EmployeeCreateNestedOneWithoutTicketsInput
    parts?: ServicePartCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketUncheckedCreateInput = {
    id?: string
    tenantId: string
    customerId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: ServicePartUncheckedCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryUncheckedCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutServiceTicketsNestedInput
    customer?: AccountUpdateOneRequiredWithoutServiceTicketsNestedInput
    technician?: EmployeeUpdateOneWithoutTicketsNestedInput
    parts?: ServicePartUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: ServicePartUncheckedUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUncheckedUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketCreateManyInput = {
    id?: string
    tenantId: string
    customerId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePartCreateInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    serviceTicket: ServiceTicketCreateNestedOneWithoutPartsInput
    product: ProductCreateNestedOneWithoutServicePartsInput
  }

  export type ServicePartUncheckedCreateInput = {
    id?: string
    serviceTicketId: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type ServicePartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceTicket?: ServiceTicketUpdateOneRequiredWithoutPartsNestedInput
    product?: ProductUpdateOneRequiredWithoutServicePartsNestedInput
  }

  export type ServicePartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceTicketId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicePartCreateManyInput = {
    id?: string
    serviceTicketId: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type ServicePartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicePartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceTicketId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServiceHistoryCreateInput = {
    id?: string
    status: $Enums.ServiceStatus
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
    serviceTicket: ServiceTicketCreateNestedOneWithoutHistoryInput
  }

  export type ServiceHistoryUncheckedCreateInput = {
    id?: string
    serviceTicketId: string
    status: $Enums.ServiceStatus
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceTicket?: ServiceTicketUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ServiceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceTicketId?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceHistoryCreateManyInput = {
    id?: string
    serviceTicketId: string
    status: $Enums.ServiceStatus
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceTicketId?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    tickets?: ServiceTicketCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tickets?: ServiceTicketUncheckedCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    tickets?: ServiceTicketUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: ServiceTicketUncheckedUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    month: string
    amount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidAt?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    employeeId: string
    month: string
    amount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidAt?: Date | string | null
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollCreateManyInput = {
    id?: string
    employeeId: string
    month: string
    amount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidAt?: Date | string | null
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
    employee: EmployeeCreateNestedOneWithoutLeavesInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
  }

  export type LeaveRequestCreateManyInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    packages?: PackageModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    packages?: PackageModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packages?: PackageModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packages?: PackageModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageModuleCreateInput = {
    id?: string
    package: SubscriptionPackageCreateNestedOneWithoutModulesInput
    module: ModuleCreateNestedOneWithoutPackagesInput
  }

  export type PackageModuleUncheckedCreateInput = {
    id?: string
    packageId: string
    moduleId: string
  }

  export type PackageModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    package?: SubscriptionPackageUpdateOneRequiredWithoutModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type PackageModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageModuleCreateManyInput = {
    id?: string
    packageId: string
    moduleId: string
  }

  export type PackageModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PackageModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type SuperAdminRoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutSuperAdminRoleInput
  }

  export type SuperAdminRoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutSuperAdminRoleInput
  }

  export type SuperAdminRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutSuperAdminRoleNestedInput
  }

  export type SuperAdminRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutSuperAdminRoleNestedInput
  }

  export type SuperAdminRoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    tenantId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    tenantId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingContentCreateInput = {
    id?: string
    section: string
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type LandingContentUncheckedCreateInput = {
    id?: string
    section: string
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type LandingContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingContentCreateManyInput = {
    id?: string
    section: string
    content: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type LandingContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderCreateInput = {
    id?: string
    provider: string
    displayName: string
    credentials: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderUncheckedCreateInput = {
    id?: string
    provider: string
    displayName: string
    credentials: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderCreateManyInput = {
    id?: string
    provider: string
    displayName: string
    credentials: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    id?: string
    bankName: string
    accountName: string
    iban: string
    currency?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    bankName: string
    accountName: string
    iban: string
    currency?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateManyInput = {
    id?: string
    bankName: string
    accountName: string
    iban: string
    currency?: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    tenantId?: string | null
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    id?: string
    type: string
    code: string
    name: string
    subject?: string | null
    content: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    type: string
    code: string
    name: string
    subject?: string | null
    content: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateManyInput = {
    id?: string
    tenantId?: string | null
    type: string
    code: string
    name: string
    subject?: string | null
    content: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSupportTicketsInput
    replies?: TicketReplyCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: TicketReplyUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSupportTicketsNestedInput
    replies?: TicketReplyUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: TicketReplyUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketReplyCreateInput = {
    id?: string
    userId: string
    message: string
    isAdminReply?: boolean
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutRepliesInput
  }

  export type TicketReplyUncheckedCreateInput = {
    id?: string
    ticketId: string
    userId: string
    message: string
    isAdminReply?: boolean
    createdAt?: Date | string
  }

  export type TicketReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isAdminReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type TicketReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isAdminReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketReplyCreateManyInput = {
    id?: string
    ticketId: string
    userId: string
    message: string
    isAdminReply?: boolean
    createdAt?: Date | string
  }

  export type TicketReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isAdminReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isAdminReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TenantListRelationFilter = {
    every?: TenantWhereInput
    some?: TenantWhereInput
    none?: TenantWhereInput
  }

  export type PackageModuleListRelationFilter = {
    every?: PackageModuleWhereInput
    some?: PackageModuleWhereInput
    none?: PackageModuleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackageModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    storageLimit?: SortOrder
    features?: SortOrder
    isPopular?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    isDemo?: SortOrder
    demoDuration?: SortOrder
    discountPercentage?: SortOrder
    discountEndDate?: SortOrder
    highlightColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPackageAvgOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    sortOrder?: SortOrder
    demoDuration?: SortOrder
    discountPercentage?: SortOrder
  }

  export type SubscriptionPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    storageLimit?: SortOrder
    isPopular?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    isDemo?: SortOrder
    demoDuration?: SortOrder
    discountPercentage?: SortOrder
    discountEndDate?: SortOrder
    highlightColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    storageLimit?: SortOrder
    isPopular?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    isDemo?: SortOrder
    demoDuration?: SortOrder
    discountPercentage?: SortOrder
    discountEndDate?: SortOrder
    highlightColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPackageSumOrderByAggregateInput = {
    priceMonthly?: SortOrder
    priceYearly?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    sortOrder?: SortOrder
    demoDuration?: SortOrder
    discountPercentage?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type EnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type SubscriptionPackageNullableRelationFilter = {
    is?: SubscriptionPackageWhereInput | null
    isNot?: SubscriptionPackageWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type ServiceTicketListRelationFilter = {
    every?: ServiceTicketWhereInput
    some?: ServiceTicketWhereInput
    none?: ServiceTicketWhereInput
  }

  export type CashRegisterListRelationFilter = {
    every?: CashRegisterWhereInput
    some?: CashRegisterWhereInput
    none?: CashRegisterWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type SaaSPaymentListRelationFilter = {
    every?: SaaSPaymentWhereInput
    some?: SaaSPaymentWhereInput
    none?: SaaSPaymentWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type TemplateListRelationFilter = {
    every?: TemplateWhereInput
    some?: TemplateWhereInput
    none?: TemplateWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashRegisterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaaSPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    taxNumber?: SortOrder
    taxOffice?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    subscriptionPlanId?: SortOrder
    status?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    taxNumber?: SortOrder
    taxOffice?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    subscriptionPlanId?: SortOrder
    status?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    name?: SortOrder
    type?: SortOrder
    taxNumber?: SortOrder
    taxOffice?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    subscriptionPlanId?: SortOrder
    status?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type EnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SaaSPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaaSPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SaaSPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaaSPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaaSPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type SuperAdminRoleNullableRelationFilter = {
    is?: SuperAdminRoleWhereInput | null
    isNot?: SuperAdminRoleWhereInput | null
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    userNo?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    phoneNumber?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorExpires?: SortOrder
    isSuperAdmin?: SortOrder
    superAdminRoleId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    userNo?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    userNo?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    phoneNumber?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorExpires?: SortOrder
    isSuperAdmin?: SortOrder
    superAdminRoleId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    userNo?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    bio?: SortOrder
    avatar?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    phoneNumber?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorExpires?: SortOrder
    isSuperAdmin?: SortOrder
    superAdminRoleId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    userNo?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    accountCode?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    riskLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    balance?: SortOrder
    riskLimit?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    accountCode?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    riskLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    accountCode?: SortOrder
    name?: SortOrder
    balance?: SortOrder
    riskLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    balance?: SortOrder
    riskLimit?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type ServicePartListRelationFilter = {
    every?: ServicePartWhereInput
    some?: ServicePartWhereInput
    none?: ServicePartWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicePartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    barcode?: SortOrder
    stockQuantity?: SortOrder
    priceSell?: SortOrder
    trackStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    stockQuantity?: SortOrder
    priceSell?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    barcode?: SortOrder
    stockQuantity?: SortOrder
    priceSell?: SortOrder
    trackStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    barcode?: SortOrder
    stockQuantity?: SortOrder
    priceSell?: SortOrder
    trackStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    stockQuantity?: SortOrder
    priceSell?: SortOrder
  }

  export type EnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    documentRef?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    documentRef?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    documentRef?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type PosSessionListRelationFilter = {
    every?: PosSessionWhereInput
    some?: PosSessionWhereInput
    none?: PosSessionWhereInput
  }

  export type PosSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashRegisterCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type CashRegisterAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type CashRegisterMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type CashRegisterMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type CashRegisterSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type CashRegisterRelationFilter = {
    is?: CashRegisterWhereInput
    isNot?: CashRegisterWhereInput
  }

  export type AccountNullableRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    type?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type OfferNullableRelationFilter = {
    is?: OfferWhereInput | null
    isNot?: OfferWhereInput | null
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    offerId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    offerId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    offerId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type EmployeeNullableRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type PosSessionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    employeeId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
  }

  export type PosSessionAvgOrderByAggregateInput = {
    openingBalance?: SortOrder
    closingBalance?: SortOrder
  }

  export type PosSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    employeeId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
  }

  export type PosSessionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registerId?: SortOrder
    employeeId?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
  }

  export type PosSessionSumOrderByAggregateInput = {
    openingBalance?: SortOrder
    closingBalance?: SortOrder
  }

  export type EnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type ServiceHistoryListRelationFilter = {
    every?: ServiceHistoryWhereInput
    some?: ServiceHistoryWhereInput
    none?: ServiceHistoryWhereInput
  }

  export type ServiceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceTicketCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    technicianId?: SortOrder
    deviceInfo?: SortOrder
    problemDesc?: SortOrder
    status?: SortOrder
    estimatedCost?: SortOrder
    finalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTicketAvgOrderByAggregateInput = {
    estimatedCost?: SortOrder
    finalCost?: SortOrder
  }

  export type ServiceTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    technicianId?: SortOrder
    problemDesc?: SortOrder
    status?: SortOrder
    estimatedCost?: SortOrder
    finalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTicketMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    technicianId?: SortOrder
    problemDesc?: SortOrder
    status?: SortOrder
    estimatedCost?: SortOrder
    finalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTicketSumOrderByAggregateInput = {
    estimatedCost?: SortOrder
    finalCost?: SortOrder
  }

  export type EnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type ServiceTicketRelationFilter = {
    is?: ServiceTicketWhereInput
    isNot?: ServiceTicketWhereInput
  }

  export type ServicePartCountOrderByAggregateInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ServicePartAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ServicePartMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ServicePartMinOrderByAggregateInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ServicePartSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ServiceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    serviceTicketId?: SortOrder
    status?: SortOrder
    note?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    salary?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    salary?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    position?: SortOrder
    salary?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type SubscriptionPackageRelationFilter = {
    is?: SubscriptionPackageWhereInput
    isNot?: SubscriptionPackageWhereInput
  }

  export type ModuleRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type PackageModulePackageIdModuleIdCompoundUniqueInput = {
    packageId: string
    moduleId: string
  }

  export type PackageModuleCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    moduleId?: SortOrder
  }

  export type PackageModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    moduleId?: SortOrder
  }

  export type PackageModuleMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    moduleId?: SortOrder
  }

  export type SuperAdminRoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminRoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LandingContentCountOrderByAggregateInput = {
    id?: SortOrder
    section?: SortOrder
    content?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingContentMaxOrderByAggregateInput = {
    id?: SortOrder
    section?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingContentMinOrderByAggregateInput = {
    id?: SortOrder
    section?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentProviderCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    credentials?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentProviderMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    displayName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    iban?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    iban?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    iban?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateTenantIdTypeCodeCompoundUniqueInput = {
    tenantId: string
    type: string
    code: string
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type TicketReplyListRelationFilter = {
    every?: TicketReplyWhereInput
    some?: TicketReplyWhereInput
    none?: TicketReplyWhereInput
  }

  export type TicketReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type SupportTicketRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type TicketReplyCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isAdminReply?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isAdminReply?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketReplyMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isAdminReply?: SortOrder
    createdAt?: SortOrder
  }

  export type TenantCreateNestedManyWithoutSubscriptionPackageInput = {
    create?: XOR<TenantCreateWithoutSubscriptionPackageInput, TenantUncheckedCreateWithoutSubscriptionPackageInput> | TenantCreateWithoutSubscriptionPackageInput[] | TenantUncheckedCreateWithoutSubscriptionPackageInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionPackageInput | TenantCreateOrConnectWithoutSubscriptionPackageInput[]
    createMany?: TenantCreateManySubscriptionPackageInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type PackageModuleCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageModuleCreateWithoutPackageInput, PackageModuleUncheckedCreateWithoutPackageInput> | PackageModuleCreateWithoutPackageInput[] | PackageModuleUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutPackageInput | PackageModuleCreateOrConnectWithoutPackageInput[]
    createMany?: PackageModuleCreateManyPackageInputEnvelope
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
  }

  export type TenantUncheckedCreateNestedManyWithoutSubscriptionPackageInput = {
    create?: XOR<TenantCreateWithoutSubscriptionPackageInput, TenantUncheckedCreateWithoutSubscriptionPackageInput> | TenantCreateWithoutSubscriptionPackageInput[] | TenantUncheckedCreateWithoutSubscriptionPackageInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionPackageInput | TenantCreateOrConnectWithoutSubscriptionPackageInput[]
    createMany?: TenantCreateManySubscriptionPackageInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type PackageModuleUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<PackageModuleCreateWithoutPackageInput, PackageModuleUncheckedCreateWithoutPackageInput> | PackageModuleCreateWithoutPackageInput[] | PackageModuleUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutPackageInput | PackageModuleCreateOrConnectWithoutPackageInput[]
    createMany?: PackageModuleCreateManyPackageInputEnvelope
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TenantUpdateManyWithoutSubscriptionPackageNestedInput = {
    create?: XOR<TenantCreateWithoutSubscriptionPackageInput, TenantUncheckedCreateWithoutSubscriptionPackageInput> | TenantCreateWithoutSubscriptionPackageInput[] | TenantUncheckedCreateWithoutSubscriptionPackageInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionPackageInput | TenantCreateOrConnectWithoutSubscriptionPackageInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutSubscriptionPackageInput | TenantUpsertWithWhereUniqueWithoutSubscriptionPackageInput[]
    createMany?: TenantCreateManySubscriptionPackageInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutSubscriptionPackageInput | TenantUpdateWithWhereUniqueWithoutSubscriptionPackageInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutSubscriptionPackageInput | TenantUpdateManyWithWhereWithoutSubscriptionPackageInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type PackageModuleUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageModuleCreateWithoutPackageInput, PackageModuleUncheckedCreateWithoutPackageInput> | PackageModuleCreateWithoutPackageInput[] | PackageModuleUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutPackageInput | PackageModuleCreateOrConnectWithoutPackageInput[]
    upsert?: PackageModuleUpsertWithWhereUniqueWithoutPackageInput | PackageModuleUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageModuleCreateManyPackageInputEnvelope
    set?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    disconnect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    delete?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    update?: PackageModuleUpdateWithWhereUniqueWithoutPackageInput | PackageModuleUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageModuleUpdateManyWithWhereWithoutPackageInput | PackageModuleUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageModuleScalarWhereInput | PackageModuleScalarWhereInput[]
  }

  export type TenantUncheckedUpdateManyWithoutSubscriptionPackageNestedInput = {
    create?: XOR<TenantCreateWithoutSubscriptionPackageInput, TenantUncheckedCreateWithoutSubscriptionPackageInput> | TenantCreateWithoutSubscriptionPackageInput[] | TenantUncheckedCreateWithoutSubscriptionPackageInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionPackageInput | TenantCreateOrConnectWithoutSubscriptionPackageInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutSubscriptionPackageInput | TenantUpsertWithWhereUniqueWithoutSubscriptionPackageInput[]
    createMany?: TenantCreateManySubscriptionPackageInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutSubscriptionPackageInput | TenantUpdateWithWhereUniqueWithoutSubscriptionPackageInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutSubscriptionPackageInput | TenantUpdateManyWithWhereWithoutSubscriptionPackageInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type PackageModuleUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<PackageModuleCreateWithoutPackageInput, PackageModuleUncheckedCreateWithoutPackageInput> | PackageModuleCreateWithoutPackageInput[] | PackageModuleUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutPackageInput | PackageModuleCreateOrConnectWithoutPackageInput[]
    upsert?: PackageModuleUpsertWithWhereUniqueWithoutPackageInput | PackageModuleUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: PackageModuleCreateManyPackageInputEnvelope
    set?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    disconnect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    delete?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    update?: PackageModuleUpdateWithWhereUniqueWithoutPackageInput | PackageModuleUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: PackageModuleUpdateManyWithWhereWithoutPackageInput | PackageModuleUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: PackageModuleScalarWhereInput | PackageModuleScalarWhereInput[]
  }

  export type SubscriptionPackageCreateNestedOneWithoutTenantsInput = {
    create?: XOR<SubscriptionPackageCreateWithoutTenantsInput, SubscriptionPackageUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: SubscriptionPackageCreateOrConnectWithoutTenantsInput
    connect?: SubscriptionPackageWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutTenantInput = {
    create?: XOR<AccountCreateWithoutTenantInput, AccountUncheckedCreateWithoutTenantInput> | AccountCreateWithoutTenantInput[] | AccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutTenantInput | AccountCreateOrConnectWithoutTenantInput[]
    createMany?: AccountCreateManyTenantInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutTenantInput = {
    create?: XOR<OfferCreateWithoutTenantInput, OfferUncheckedCreateWithoutTenantInput> | OfferCreateWithoutTenantInput[] | OfferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutTenantInput | OfferCreateOrConnectWithoutTenantInput[]
    createMany?: OfferCreateManyTenantInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockMovementCreateWithoutTenantInput, StockMovementUncheckedCreateWithoutTenantInput> | StockMovementCreateWithoutTenantInput[] | StockMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutTenantInput | StockMovementCreateOrConnectWithoutTenantInput[]
    createMany?: StockMovementCreateManyTenantInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ServiceTicketCreateNestedManyWithoutTenantInput = {
    create?: XOR<ServiceTicketCreateWithoutTenantInput, ServiceTicketUncheckedCreateWithoutTenantInput> | ServiceTicketCreateWithoutTenantInput[] | ServiceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTenantInput | ServiceTicketCreateOrConnectWithoutTenantInput[]
    createMany?: ServiceTicketCreateManyTenantInputEnvelope
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
  }

  export type CashRegisterCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type SaaSPaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<SaaSPaymentCreateWithoutTenantInput, SaaSPaymentUncheckedCreateWithoutTenantInput> | SaaSPaymentCreateWithoutTenantInput[] | SaaSPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaaSPaymentCreateOrConnectWithoutTenantInput | SaaSPaymentCreateOrConnectWithoutTenantInput[]
    createMany?: SaaSPaymentCreateManyTenantInputEnvelope
    connect?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutTenantInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type TemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<TemplateCreateWithoutTenantInput, TemplateUncheckedCreateWithoutTenantInput> | TemplateCreateWithoutTenantInput[] | TemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutTenantInput | TemplateCreateOrConnectWithoutTenantInput[]
    createMany?: TemplateCreateManyTenantInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AccountCreateWithoutTenantInput, AccountUncheckedCreateWithoutTenantInput> | AccountCreateWithoutTenantInput[] | AccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutTenantInput | AccountCreateOrConnectWithoutTenantInput[]
    createMany?: AccountCreateManyTenantInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OfferCreateWithoutTenantInput, OfferUncheckedCreateWithoutTenantInput> | OfferCreateWithoutTenantInput[] | OfferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutTenantInput | OfferCreateOrConnectWithoutTenantInput[]
    createMany?: OfferCreateManyTenantInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockMovementCreateWithoutTenantInput, StockMovementUncheckedCreateWithoutTenantInput> | StockMovementCreateWithoutTenantInput[] | StockMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutTenantInput | StockMovementCreateOrConnectWithoutTenantInput[]
    createMany?: StockMovementCreateManyTenantInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ServiceTicketUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ServiceTicketCreateWithoutTenantInput, ServiceTicketUncheckedCreateWithoutTenantInput> | ServiceTicketCreateWithoutTenantInput[] | ServiceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTenantInput | ServiceTicketCreateOrConnectWithoutTenantInput[]
    createMany?: ServiceTicketCreateManyTenantInputEnvelope
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
  }

  export type CashRegisterUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SaaSPaymentCreateWithoutTenantInput, SaaSPaymentUncheckedCreateWithoutTenantInput> | SaaSPaymentCreateWithoutTenantInput[] | SaaSPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaaSPaymentCreateOrConnectWithoutTenantInput | SaaSPaymentCreateOrConnectWithoutTenantInput[]
    createMany?: SaaSPaymentCreateManyTenantInputEnvelope
    connect?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type TemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TemplateCreateWithoutTenantInput, TemplateUncheckedCreateWithoutTenantInput> | TemplateCreateWithoutTenantInput[] | TemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutTenantInput | TemplateCreateOrConnectWithoutTenantInput[]
    createMany?: TemplateCreateManyTenantInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type EnumTenantTypeFieldUpdateOperationsInput = {
    set?: $Enums.TenantType
  }

  export type EnumTenantStatusFieldUpdateOperationsInput = {
    set?: $Enums.TenantStatus
  }

  export type SubscriptionPackageUpdateOneWithoutTenantsNestedInput = {
    create?: XOR<SubscriptionPackageCreateWithoutTenantsInput, SubscriptionPackageUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: SubscriptionPackageCreateOrConnectWithoutTenantsInput
    upsert?: SubscriptionPackageUpsertWithoutTenantsInput
    disconnect?: SubscriptionPackageWhereInput | boolean
    delete?: SubscriptionPackageWhereInput | boolean
    connect?: SubscriptionPackageWhereUniqueInput
    update?: XOR<XOR<SubscriptionPackageUpdateToOneWithWhereWithoutTenantsInput, SubscriptionPackageUpdateWithoutTenantsInput>, SubscriptionPackageUncheckedUpdateWithoutTenantsInput>
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AccountCreateWithoutTenantInput, AccountUncheckedCreateWithoutTenantInput> | AccountCreateWithoutTenantInput[] | AccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutTenantInput | AccountCreateOrConnectWithoutTenantInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutTenantInput | AccountUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AccountCreateManyTenantInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutTenantInput | AccountUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutTenantInput | AccountUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OfferCreateWithoutTenantInput, OfferUncheckedCreateWithoutTenantInput> | OfferCreateWithoutTenantInput[] | OfferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutTenantInput | OfferCreateOrConnectWithoutTenantInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutTenantInput | OfferUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OfferCreateManyTenantInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutTenantInput | OfferUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutTenantInput | OfferUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockMovementCreateWithoutTenantInput, StockMovementUncheckedCreateWithoutTenantInput> | StockMovementCreateWithoutTenantInput[] | StockMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutTenantInput | StockMovementCreateOrConnectWithoutTenantInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutTenantInput | StockMovementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockMovementCreateManyTenantInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutTenantInput | StockMovementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutTenantInput | StockMovementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ServiceTicketUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutTenantInput, ServiceTicketUncheckedCreateWithoutTenantInput> | ServiceTicketCreateWithoutTenantInput[] | ServiceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTenantInput | ServiceTicketCreateOrConnectWithoutTenantInput[]
    upsert?: ServiceTicketUpsertWithWhereUniqueWithoutTenantInput | ServiceTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ServiceTicketCreateManyTenantInputEnvelope
    set?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    disconnect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    delete?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    update?: ServiceTicketUpdateWithWhereUniqueWithoutTenantInput | ServiceTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ServiceTicketUpdateManyWithWhereWithoutTenantInput | ServiceTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
  }

  export type CashRegisterUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutTenantInput | CashRegisterUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutTenantInput | CashRegisterUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutTenantInput | CashRegisterUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type SaaSPaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SaaSPaymentCreateWithoutTenantInput, SaaSPaymentUncheckedCreateWithoutTenantInput> | SaaSPaymentCreateWithoutTenantInput[] | SaaSPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaaSPaymentCreateOrConnectWithoutTenantInput | SaaSPaymentCreateOrConnectWithoutTenantInput[]
    upsert?: SaaSPaymentUpsertWithWhereUniqueWithoutTenantInput | SaaSPaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SaaSPaymentCreateManyTenantInputEnvelope
    set?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    disconnect?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    delete?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    connect?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    update?: SaaSPaymentUpdateWithWhereUniqueWithoutTenantInput | SaaSPaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SaaSPaymentUpdateManyWithWhereWithoutTenantInput | SaaSPaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SaaSPaymentScalarWhereInput | SaaSPaymentScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutTenantInput | IntegrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutTenantInput | IntegrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutTenantInput | IntegrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type TemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TemplateCreateWithoutTenantInput, TemplateUncheckedCreateWithoutTenantInput> | TemplateCreateWithoutTenantInput[] | TemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutTenantInput | TemplateCreateOrConnectWithoutTenantInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutTenantInput | TemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TemplateCreateManyTenantInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutTenantInput | TemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutTenantInput | TemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutTenantInput | SupportTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutTenantInput | SupportTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutTenantInput | SupportTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AccountCreateWithoutTenantInput, AccountUncheckedCreateWithoutTenantInput> | AccountCreateWithoutTenantInput[] | AccountUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutTenantInput | AccountCreateOrConnectWithoutTenantInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutTenantInput | AccountUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AccountCreateManyTenantInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutTenantInput | AccountUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutTenantInput | AccountUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OfferCreateWithoutTenantInput, OfferUncheckedCreateWithoutTenantInput> | OfferCreateWithoutTenantInput[] | OfferUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutTenantInput | OfferCreateOrConnectWithoutTenantInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutTenantInput | OfferUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OfferCreateManyTenantInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutTenantInput | OfferUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutTenantInput | OfferUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockMovementCreateWithoutTenantInput, StockMovementUncheckedCreateWithoutTenantInput> | StockMovementCreateWithoutTenantInput[] | StockMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutTenantInput | StockMovementCreateOrConnectWithoutTenantInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutTenantInput | StockMovementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockMovementCreateManyTenantInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutTenantInput | StockMovementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutTenantInput | StockMovementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutTenantInput, ServiceTicketUncheckedCreateWithoutTenantInput> | ServiceTicketCreateWithoutTenantInput[] | ServiceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTenantInput | ServiceTicketCreateOrConnectWithoutTenantInput[]
    upsert?: ServiceTicketUpsertWithWhereUniqueWithoutTenantInput | ServiceTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ServiceTicketCreateManyTenantInputEnvelope
    set?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    disconnect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    delete?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    update?: ServiceTicketUpdateWithWhereUniqueWithoutTenantInput | ServiceTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ServiceTicketUpdateManyWithWhereWithoutTenantInput | ServiceTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
  }

  export type CashRegisterUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutTenantInput | CashRegisterUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutTenantInput | CashRegisterUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutTenantInput | CashRegisterUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SaaSPaymentCreateWithoutTenantInput, SaaSPaymentUncheckedCreateWithoutTenantInput> | SaaSPaymentCreateWithoutTenantInput[] | SaaSPaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaaSPaymentCreateOrConnectWithoutTenantInput | SaaSPaymentCreateOrConnectWithoutTenantInput[]
    upsert?: SaaSPaymentUpsertWithWhereUniqueWithoutTenantInput | SaaSPaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SaaSPaymentCreateManyTenantInputEnvelope
    set?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    disconnect?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    delete?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    connect?: SaaSPaymentWhereUniqueInput | SaaSPaymentWhereUniqueInput[]
    update?: SaaSPaymentUpdateWithWhereUniqueWithoutTenantInput | SaaSPaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SaaSPaymentUpdateManyWithWhereWithoutTenantInput | SaaSPaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SaaSPaymentScalarWhereInput | SaaSPaymentScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutTenantInput | IntegrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutTenantInput | IntegrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutTenantInput | IntegrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type TemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TemplateCreateWithoutTenantInput, TemplateUncheckedCreateWithoutTenantInput> | TemplateCreateWithoutTenantInput[] | TemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutTenantInput | TemplateCreateOrConnectWithoutTenantInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutTenantInput | TemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TemplateCreateManyTenantInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutTenantInput | TemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutTenantInput | TemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput> | SupportTicketCreateWithoutTenantInput[] | SupportTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutTenantInput | SupportTicketCreateOrConnectWithoutTenantInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutTenantInput | SupportTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupportTicketCreateManyTenantInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutTenantInput | SupportTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutTenantInput | SupportTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type SuperAdminRoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<SuperAdminRoleCreateWithoutUsersInput, SuperAdminRoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SuperAdminRoleCreateOrConnectWithoutUsersInput
    connect?: SuperAdminRoleWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type SuperAdminRoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<SuperAdminRoleCreateWithoutUsersInput, SuperAdminRoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SuperAdminRoleCreateOrConnectWithoutUsersInput
    upsert?: SuperAdminRoleUpsertWithoutUsersInput
    disconnect?: SuperAdminRoleWhereInput | boolean
    delete?: SuperAdminRoleWhereInput | boolean
    connect?: SuperAdminRoleWhereUniqueInput
    update?: XOR<XOR<SuperAdminRoleUpdateToOneWithWhereWithoutUsersInput, SuperAdminRoleUpdateWithoutUsersInput>, SuperAdminRoleUncheckedUpdateWithoutUsersInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutAccountsInput = {
    create?: XOR<TenantCreateWithoutAccountsInput, TenantUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAccountsInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutAccountInput = {
    create?: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput> | InvoiceCreateWithoutAccountInput[] | InvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountInput | InvoiceCreateOrConnectWithoutAccountInput[]
    createMany?: InvoiceCreateManyAccountInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutAccountInput = {
    create?: XOR<OfferCreateWithoutAccountInput, OfferUncheckedCreateWithoutAccountInput> | OfferCreateWithoutAccountInput[] | OfferUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAccountInput | OfferCreateOrConnectWithoutAccountInput[]
    createMany?: OfferCreateManyAccountInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ServiceTicketCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceTicketCreateWithoutCustomerInput, ServiceTicketUncheckedCreateWithoutCustomerInput> | ServiceTicketCreateWithoutCustomerInput[] | ServiceTicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutCustomerInput | ServiceTicketCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceTicketCreateManyCustomerInputEnvelope
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput> | InvoiceCreateWithoutAccountInput[] | InvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountInput | InvoiceCreateOrConnectWithoutAccountInput[]
    createMany?: InvoiceCreateManyAccountInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<OfferCreateWithoutAccountInput, OfferUncheckedCreateWithoutAccountInput> | OfferCreateWithoutAccountInput[] | OfferUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAccountInput | OfferCreateOrConnectWithoutAccountInput[]
    createMany?: OfferCreateManyAccountInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ServiceTicketUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceTicketCreateWithoutCustomerInput, ServiceTicketUncheckedCreateWithoutCustomerInput> | ServiceTicketCreateWithoutCustomerInput[] | ServiceTicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutCustomerInput | ServiceTicketCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceTicketCreateManyCustomerInputEnvelope
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TenantUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<TenantCreateWithoutAccountsInput, TenantUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAccountsInput
    upsert?: TenantUpsertWithoutAccountsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAccountsInput, TenantUpdateWithoutAccountsInput>, TenantUncheckedUpdateWithoutAccountsInput>
  }

  export type InvoiceUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput> | InvoiceCreateWithoutAccountInput[] | InvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountInput | InvoiceCreateOrConnectWithoutAccountInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAccountInput | InvoiceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InvoiceCreateManyAccountInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAccountInput | InvoiceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAccountInput | InvoiceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutAccountNestedInput = {
    create?: XOR<OfferCreateWithoutAccountInput, OfferUncheckedCreateWithoutAccountInput> | OfferCreateWithoutAccountInput[] | OfferUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAccountInput | OfferCreateOrConnectWithoutAccountInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutAccountInput | OfferUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: OfferCreateManyAccountInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutAccountInput | OfferUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutAccountInput | OfferUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ServiceTicketUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutCustomerInput, ServiceTicketUncheckedCreateWithoutCustomerInput> | ServiceTicketCreateWithoutCustomerInput[] | ServiceTicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutCustomerInput | ServiceTicketCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceTicketUpsertWithWhereUniqueWithoutCustomerInput | ServiceTicketUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceTicketCreateManyCustomerInputEnvelope
    set?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    disconnect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    delete?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    update?: ServiceTicketUpdateWithWhereUniqueWithoutCustomerInput | ServiceTicketUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceTicketUpdateManyWithWhereWithoutCustomerInput | ServiceTicketUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput> | InvoiceCreateWithoutAccountInput[] | InvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountInput | InvoiceCreateOrConnectWithoutAccountInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAccountInput | InvoiceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InvoiceCreateManyAccountInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAccountInput | InvoiceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAccountInput | InvoiceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<OfferCreateWithoutAccountInput, OfferUncheckedCreateWithoutAccountInput> | OfferCreateWithoutAccountInput[] | OfferUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutAccountInput | OfferCreateOrConnectWithoutAccountInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutAccountInput | OfferUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: OfferCreateManyAccountInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutAccountInput | OfferUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutAccountInput | OfferUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ServiceTicketUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutCustomerInput, ServiceTicketUncheckedCreateWithoutCustomerInput> | ServiceTicketCreateWithoutCustomerInput[] | ServiceTicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutCustomerInput | ServiceTicketCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceTicketUpsertWithWhereUniqueWithoutCustomerInput | ServiceTicketUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceTicketCreateManyCustomerInputEnvelope
    set?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    disconnect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    delete?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    update?: ServiceTicketUpdateWithWhereUniqueWithoutCustomerInput | ServiceTicketUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceTicketUpdateManyWithWhereWithoutCustomerInput | ServiceTicketUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutProductsInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    connect?: TenantWhereUniqueInput
  }

  export type StockMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ServicePartCreateNestedManyWithoutProductInput = {
    create?: XOR<ServicePartCreateWithoutProductInput, ServicePartUncheckedCreateWithoutProductInput> | ServicePartCreateWithoutProductInput[] | ServicePartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutProductInput | ServicePartCreateOrConnectWithoutProductInput[]
    createMany?: ServicePartCreateManyProductInputEnvelope
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ServicePartUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ServicePartCreateWithoutProductInput, ServicePartUncheckedCreateWithoutProductInput> | ServicePartCreateWithoutProductInput[] | ServicePartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutProductInput | ServicePartCreateOrConnectWithoutProductInput[]
    createMany?: ServicePartCreateManyProductInputEnvelope
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    upsert?: TenantUpsertWithoutProductsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutProductsInput, TenantUpdateWithoutProductsInput>, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type StockMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ServicePartUpdateManyWithoutProductNestedInput = {
    create?: XOR<ServicePartCreateWithoutProductInput, ServicePartUncheckedCreateWithoutProductInput> | ServicePartCreateWithoutProductInput[] | ServicePartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutProductInput | ServicePartCreateOrConnectWithoutProductInput[]
    upsert?: ServicePartUpsertWithWhereUniqueWithoutProductInput | ServicePartUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ServicePartCreateManyProductInputEnvelope
    set?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    disconnect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    delete?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    update?: ServicePartUpdateWithWhereUniqueWithoutProductInput | ServicePartUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ServicePartUpdateManyWithWhereWithoutProductInput | ServicePartUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ServicePartScalarWhereInput | ServicePartScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ServicePartUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ServicePartCreateWithoutProductInput, ServicePartUncheckedCreateWithoutProductInput> | ServicePartCreateWithoutProductInput[] | ServicePartUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutProductInput | ServicePartCreateOrConnectWithoutProductInput[]
    upsert?: ServicePartUpsertWithWhereUniqueWithoutProductInput | ServicePartUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ServicePartCreateManyProductInputEnvelope
    set?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    disconnect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    delete?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    update?: ServicePartUpdateWithWhereUniqueWithoutProductInput | ServicePartUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ServicePartUpdateManyWithWhereWithoutProductInput | ServicePartUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ServicePartScalarWhereInput | ServicePartScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<TenantCreateWithoutStockMovementsInput, TenantUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockMovementsInput
    connect?: TenantWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovementsInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumStockMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.StockMovementType
  }

  export type TenantUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<TenantCreateWithoutStockMovementsInput, TenantUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockMovementsInput
    upsert?: TenantUpsertWithoutStockMovementsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStockMovementsInput, TenantUpdateWithoutStockMovementsInput>, TenantUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovementsInput
    upsert?: ProductUpsertWithoutStockMovementsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockMovementsInput, ProductUpdateWithoutStockMovementsInput>, ProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type TenantCreateNestedOneWithoutCashRegistersInput = {
    create?: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashRegistersInput
    connect?: TenantWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutRegisterInput = {
    create?: XOR<TransactionCreateWithoutRegisterInput, TransactionUncheckedCreateWithoutRegisterInput> | TransactionCreateWithoutRegisterInput[] | TransactionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRegisterInput | TransactionCreateOrConnectWithoutRegisterInput[]
    createMany?: TransactionCreateManyRegisterInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PosSessionCreateNestedManyWithoutRegisterInput = {
    create?: XOR<PosSessionCreateWithoutRegisterInput, PosSessionUncheckedCreateWithoutRegisterInput> | PosSessionCreateWithoutRegisterInput[] | PosSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutRegisterInput | PosSessionCreateOrConnectWithoutRegisterInput[]
    createMany?: PosSessionCreateManyRegisterInputEnvelope
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutRegisterInput = {
    create?: XOR<TransactionCreateWithoutRegisterInput, TransactionUncheckedCreateWithoutRegisterInput> | TransactionCreateWithoutRegisterInput[] | TransactionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRegisterInput | TransactionCreateOrConnectWithoutRegisterInput[]
    createMany?: TransactionCreateManyRegisterInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PosSessionUncheckedCreateNestedManyWithoutRegisterInput = {
    create?: XOR<PosSessionCreateWithoutRegisterInput, PosSessionUncheckedCreateWithoutRegisterInput> | PosSessionCreateWithoutRegisterInput[] | PosSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutRegisterInput | PosSessionCreateOrConnectWithoutRegisterInput[]
    createMany?: PosSessionCreateManyRegisterInputEnvelope
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutCashRegistersNestedInput = {
    create?: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashRegistersInput
    upsert?: TenantUpsertWithoutCashRegistersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCashRegistersInput, TenantUpdateWithoutCashRegistersInput>, TenantUncheckedUpdateWithoutCashRegistersInput>
  }

  export type TransactionUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<TransactionCreateWithoutRegisterInput, TransactionUncheckedCreateWithoutRegisterInput> | TransactionCreateWithoutRegisterInput[] | TransactionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRegisterInput | TransactionCreateOrConnectWithoutRegisterInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutRegisterInput | TransactionUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: TransactionCreateManyRegisterInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutRegisterInput | TransactionUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutRegisterInput | TransactionUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PosSessionUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<PosSessionCreateWithoutRegisterInput, PosSessionUncheckedCreateWithoutRegisterInput> | PosSessionCreateWithoutRegisterInput[] | PosSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutRegisterInput | PosSessionCreateOrConnectWithoutRegisterInput[]
    upsert?: PosSessionUpsertWithWhereUniqueWithoutRegisterInput | PosSessionUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: PosSessionCreateManyRegisterInputEnvelope
    set?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    disconnect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    delete?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    update?: PosSessionUpdateWithWhereUniqueWithoutRegisterInput | PosSessionUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: PosSessionUpdateManyWithWhereWithoutRegisterInput | PosSessionUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: PosSessionScalarWhereInput | PosSessionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<TransactionCreateWithoutRegisterInput, TransactionUncheckedCreateWithoutRegisterInput> | TransactionCreateWithoutRegisterInput[] | TransactionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRegisterInput | TransactionCreateOrConnectWithoutRegisterInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutRegisterInput | TransactionUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: TransactionCreateManyRegisterInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutRegisterInput | TransactionUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutRegisterInput | TransactionUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PosSessionUncheckedUpdateManyWithoutRegisterNestedInput = {
    create?: XOR<PosSessionCreateWithoutRegisterInput, PosSessionUncheckedCreateWithoutRegisterInput> | PosSessionCreateWithoutRegisterInput[] | PosSessionUncheckedCreateWithoutRegisterInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutRegisterInput | PosSessionCreateOrConnectWithoutRegisterInput[]
    upsert?: PosSessionUpsertWithWhereUniqueWithoutRegisterInput | PosSessionUpsertWithWhereUniqueWithoutRegisterInput[]
    createMany?: PosSessionCreateManyRegisterInputEnvelope
    set?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    disconnect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    delete?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    update?: PosSessionUpdateWithWhereUniqueWithoutRegisterInput | PosSessionUpdateWithWhereUniqueWithoutRegisterInput[]
    updateMany?: PosSessionUpdateManyWithWhereWithoutRegisterInput | PosSessionUpdateManyWithWhereWithoutRegisterInput[]
    deleteMany?: PosSessionScalarWhereInput | PosSessionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
  }

  export type CashRegisterCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTransactionsInput
    connect?: CashRegisterWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type TenantUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    upsert?: TenantUpsertWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTransactionsInput, TenantUpdateWithoutTransactionsInput>, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTransactionsInput
    upsert?: CashRegisterUpsertWithoutTransactionsInput
    connect?: CashRegisterWhereUniqueInput
    update?: XOR<XOR<CashRegisterUpdateToOneWithWhereWithoutTransactionsInput, CashRegisterUpdateWithoutTransactionsInput>, CashRegisterUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    upsert?: AccountUpsertWithoutTransactionsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransactionsInput, AccountUpdateWithoutTransactionsInput>, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    upsert?: InvoiceUpsertWithoutTransactionsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTransactionsInput, InvoiceUpdateWithoutTransactionsInput>, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInvoicesInput
    connect?: AccountWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type AccountUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInvoicesInput
    upsert?: AccountUpsertWithoutInvoicesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutInvoicesInput, AccountUpdateWithoutInvoicesInput>, AccountUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutOffersInput = {
    create?: XOR<TenantCreateWithoutOffersInput, TenantUncheckedCreateWithoutOffersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOffersInput
    connect?: TenantWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutOffersInput = {
    create?: XOR<AccountCreateWithoutOffersInput, AccountUncheckedCreateWithoutOffersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOffersInput
    connect?: AccountWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutOfferInput = {
    create?: XOR<InvoiceItemCreateWithoutOfferInput, InvoiceItemUncheckedCreateWithoutOfferInput> | InvoiceItemCreateWithoutOfferInput[] | InvoiceItemUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutOfferInput | InvoiceItemCreateOrConnectWithoutOfferInput[]
    createMany?: InvoiceItemCreateManyOfferInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<InvoiceItemCreateWithoutOfferInput, InvoiceItemUncheckedCreateWithoutOfferInput> | InvoiceItemCreateWithoutOfferInput[] | InvoiceItemUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutOfferInput | InvoiceItemCreateOrConnectWithoutOfferInput[]
    createMany?: InvoiceItemCreateManyOfferInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EnumOfferStatusFieldUpdateOperationsInput = {
    set?: $Enums.OfferStatus
  }

  export type TenantUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<TenantCreateWithoutOffersInput, TenantUncheckedCreateWithoutOffersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOffersInput
    upsert?: TenantUpsertWithoutOffersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOffersInput, TenantUpdateWithoutOffersInput>, TenantUncheckedUpdateWithoutOffersInput>
  }

  export type AccountUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<AccountCreateWithoutOffersInput, AccountUncheckedCreateWithoutOffersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOffersInput
    upsert?: AccountUpsertWithoutOffersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutOffersInput, AccountUpdateWithoutOffersInput>, AccountUncheckedUpdateWithoutOffersInput>
  }

  export type InvoiceItemUpdateManyWithoutOfferNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutOfferInput, InvoiceItemUncheckedCreateWithoutOfferInput> | InvoiceItemCreateWithoutOfferInput[] | InvoiceItemUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutOfferInput | InvoiceItemCreateOrConnectWithoutOfferInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutOfferInput | InvoiceItemUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: InvoiceItemCreateManyOfferInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutOfferInput | InvoiceItemUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutOfferInput | InvoiceItemUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutOfferInput, InvoiceItemUncheckedCreateWithoutOfferInput> | InvoiceItemCreateWithoutOfferInput[] | InvoiceItemUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutOfferInput | InvoiceItemCreateOrConnectWithoutOfferInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutOfferInput | InvoiceItemUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: InvoiceItemCreateManyOfferInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutOfferInput | InvoiceItemUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutOfferInput | InvoiceItemUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutItemsInput = {
    create?: XOR<OfferCreateWithoutItemsInput, OfferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutItemsInput
    connect?: OfferWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type InvoiceUpdateOneWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type OfferUpdateOneWithoutItemsNestedInput = {
    create?: XOR<OfferCreateWithoutItemsInput, OfferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutItemsInput
    upsert?: OfferUpsertWithoutItemsInput
    disconnect?: OfferWhereInput | boolean
    delete?: OfferWhereInput | boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutItemsInput, OfferUpdateWithoutItemsInput>, OfferUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ProductUpsertWithoutInvoiceItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInvoiceItemsInput, ProductUpdateWithoutInvoiceItemsInput>, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type CashRegisterCreateNestedOneWithoutPosSessionsInput = {
    create?: XOR<CashRegisterCreateWithoutPosSessionsInput, CashRegisterUncheckedCreateWithoutPosSessionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutPosSessionsInput
    connect?: CashRegisterWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPosSessionsInput = {
    create?: XOR<EmployeeCreateWithoutPosSessionsInput, EmployeeUncheckedCreateWithoutPosSessionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPosSessionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type CashRegisterUpdateOneRequiredWithoutPosSessionsNestedInput = {
    create?: XOR<CashRegisterCreateWithoutPosSessionsInput, CashRegisterUncheckedCreateWithoutPosSessionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutPosSessionsInput
    upsert?: CashRegisterUpsertWithoutPosSessionsInput
    connect?: CashRegisterWhereUniqueInput
    update?: XOR<XOR<CashRegisterUpdateToOneWithWhereWithoutPosSessionsInput, CashRegisterUpdateWithoutPosSessionsInput>, CashRegisterUncheckedUpdateWithoutPosSessionsInput>
  }

  export type EmployeeUpdateOneWithoutPosSessionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPosSessionsInput, EmployeeUncheckedCreateWithoutPosSessionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPosSessionsInput
    upsert?: EmployeeUpsertWithoutPosSessionsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPosSessionsInput, EmployeeUpdateWithoutPosSessionsInput>, EmployeeUncheckedUpdateWithoutPosSessionsInput>
  }

  export type TenantCreateNestedOneWithoutServiceTicketsInput = {
    create?: XOR<TenantCreateWithoutServiceTicketsInput, TenantUncheckedCreateWithoutServiceTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutServiceTicketsInput
    connect?: TenantWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutServiceTicketsInput = {
    create?: XOR<AccountCreateWithoutServiceTicketsInput, AccountUncheckedCreateWithoutServiceTicketsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServiceTicketsInput
    connect?: AccountWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutTicketsInput = {
    create?: XOR<EmployeeCreateWithoutTicketsInput, EmployeeUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTicketsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ServicePartCreateNestedManyWithoutServiceTicketInput = {
    create?: XOR<ServicePartCreateWithoutServiceTicketInput, ServicePartUncheckedCreateWithoutServiceTicketInput> | ServicePartCreateWithoutServiceTicketInput[] | ServicePartUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutServiceTicketInput | ServicePartCreateOrConnectWithoutServiceTicketInput[]
    createMany?: ServicePartCreateManyServiceTicketInputEnvelope
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
  }

  export type ServiceHistoryCreateNestedManyWithoutServiceTicketInput = {
    create?: XOR<ServiceHistoryCreateWithoutServiceTicketInput, ServiceHistoryUncheckedCreateWithoutServiceTicketInput> | ServiceHistoryCreateWithoutServiceTicketInput[] | ServiceHistoryUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServiceHistoryCreateOrConnectWithoutServiceTicketInput | ServiceHistoryCreateOrConnectWithoutServiceTicketInput[]
    createMany?: ServiceHistoryCreateManyServiceTicketInputEnvelope
    connect?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
  }

  export type ServicePartUncheckedCreateNestedManyWithoutServiceTicketInput = {
    create?: XOR<ServicePartCreateWithoutServiceTicketInput, ServicePartUncheckedCreateWithoutServiceTicketInput> | ServicePartCreateWithoutServiceTicketInput[] | ServicePartUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutServiceTicketInput | ServicePartCreateOrConnectWithoutServiceTicketInput[]
    createMany?: ServicePartCreateManyServiceTicketInputEnvelope
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
  }

  export type ServiceHistoryUncheckedCreateNestedManyWithoutServiceTicketInput = {
    create?: XOR<ServiceHistoryCreateWithoutServiceTicketInput, ServiceHistoryUncheckedCreateWithoutServiceTicketInput> | ServiceHistoryCreateWithoutServiceTicketInput[] | ServiceHistoryUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServiceHistoryCreateOrConnectWithoutServiceTicketInput | ServiceHistoryCreateOrConnectWithoutServiceTicketInput[]
    createMany?: ServiceHistoryCreateManyServiceTicketInputEnvelope
    connect?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
  }

  export type EnumServiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceStatus
  }

  export type TenantUpdateOneRequiredWithoutServiceTicketsNestedInput = {
    create?: XOR<TenantCreateWithoutServiceTicketsInput, TenantUncheckedCreateWithoutServiceTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutServiceTicketsInput
    upsert?: TenantUpsertWithoutServiceTicketsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutServiceTicketsInput, TenantUpdateWithoutServiceTicketsInput>, TenantUncheckedUpdateWithoutServiceTicketsInput>
  }

  export type AccountUpdateOneRequiredWithoutServiceTicketsNestedInput = {
    create?: XOR<AccountCreateWithoutServiceTicketsInput, AccountUncheckedCreateWithoutServiceTicketsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutServiceTicketsInput
    upsert?: AccountUpsertWithoutServiceTicketsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutServiceTicketsInput, AccountUpdateWithoutServiceTicketsInput>, AccountUncheckedUpdateWithoutServiceTicketsInput>
  }

  export type EmployeeUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<EmployeeCreateWithoutTicketsInput, EmployeeUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTicketsInput
    upsert?: EmployeeUpsertWithoutTicketsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTicketsInput, EmployeeUpdateWithoutTicketsInput>, EmployeeUncheckedUpdateWithoutTicketsInput>
  }

  export type ServicePartUpdateManyWithoutServiceTicketNestedInput = {
    create?: XOR<ServicePartCreateWithoutServiceTicketInput, ServicePartUncheckedCreateWithoutServiceTicketInput> | ServicePartCreateWithoutServiceTicketInput[] | ServicePartUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutServiceTicketInput | ServicePartCreateOrConnectWithoutServiceTicketInput[]
    upsert?: ServicePartUpsertWithWhereUniqueWithoutServiceTicketInput | ServicePartUpsertWithWhereUniqueWithoutServiceTicketInput[]
    createMany?: ServicePartCreateManyServiceTicketInputEnvelope
    set?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    disconnect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    delete?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    update?: ServicePartUpdateWithWhereUniqueWithoutServiceTicketInput | ServicePartUpdateWithWhereUniqueWithoutServiceTicketInput[]
    updateMany?: ServicePartUpdateManyWithWhereWithoutServiceTicketInput | ServicePartUpdateManyWithWhereWithoutServiceTicketInput[]
    deleteMany?: ServicePartScalarWhereInput | ServicePartScalarWhereInput[]
  }

  export type ServiceHistoryUpdateManyWithoutServiceTicketNestedInput = {
    create?: XOR<ServiceHistoryCreateWithoutServiceTicketInput, ServiceHistoryUncheckedCreateWithoutServiceTicketInput> | ServiceHistoryCreateWithoutServiceTicketInput[] | ServiceHistoryUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServiceHistoryCreateOrConnectWithoutServiceTicketInput | ServiceHistoryCreateOrConnectWithoutServiceTicketInput[]
    upsert?: ServiceHistoryUpsertWithWhereUniqueWithoutServiceTicketInput | ServiceHistoryUpsertWithWhereUniqueWithoutServiceTicketInput[]
    createMany?: ServiceHistoryCreateManyServiceTicketInputEnvelope
    set?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    disconnect?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    delete?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    connect?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    update?: ServiceHistoryUpdateWithWhereUniqueWithoutServiceTicketInput | ServiceHistoryUpdateWithWhereUniqueWithoutServiceTicketInput[]
    updateMany?: ServiceHistoryUpdateManyWithWhereWithoutServiceTicketInput | ServiceHistoryUpdateManyWithWhereWithoutServiceTicketInput[]
    deleteMany?: ServiceHistoryScalarWhereInput | ServiceHistoryScalarWhereInput[]
  }

  export type ServicePartUncheckedUpdateManyWithoutServiceTicketNestedInput = {
    create?: XOR<ServicePartCreateWithoutServiceTicketInput, ServicePartUncheckedCreateWithoutServiceTicketInput> | ServicePartCreateWithoutServiceTicketInput[] | ServicePartUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServicePartCreateOrConnectWithoutServiceTicketInput | ServicePartCreateOrConnectWithoutServiceTicketInput[]
    upsert?: ServicePartUpsertWithWhereUniqueWithoutServiceTicketInput | ServicePartUpsertWithWhereUniqueWithoutServiceTicketInput[]
    createMany?: ServicePartCreateManyServiceTicketInputEnvelope
    set?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    disconnect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    delete?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    connect?: ServicePartWhereUniqueInput | ServicePartWhereUniqueInput[]
    update?: ServicePartUpdateWithWhereUniqueWithoutServiceTicketInput | ServicePartUpdateWithWhereUniqueWithoutServiceTicketInput[]
    updateMany?: ServicePartUpdateManyWithWhereWithoutServiceTicketInput | ServicePartUpdateManyWithWhereWithoutServiceTicketInput[]
    deleteMany?: ServicePartScalarWhereInput | ServicePartScalarWhereInput[]
  }

  export type ServiceHistoryUncheckedUpdateManyWithoutServiceTicketNestedInput = {
    create?: XOR<ServiceHistoryCreateWithoutServiceTicketInput, ServiceHistoryUncheckedCreateWithoutServiceTicketInput> | ServiceHistoryCreateWithoutServiceTicketInput[] | ServiceHistoryUncheckedCreateWithoutServiceTicketInput[]
    connectOrCreate?: ServiceHistoryCreateOrConnectWithoutServiceTicketInput | ServiceHistoryCreateOrConnectWithoutServiceTicketInput[]
    upsert?: ServiceHistoryUpsertWithWhereUniqueWithoutServiceTicketInput | ServiceHistoryUpsertWithWhereUniqueWithoutServiceTicketInput[]
    createMany?: ServiceHistoryCreateManyServiceTicketInputEnvelope
    set?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    disconnect?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    delete?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    connect?: ServiceHistoryWhereUniqueInput | ServiceHistoryWhereUniqueInput[]
    update?: ServiceHistoryUpdateWithWhereUniqueWithoutServiceTicketInput | ServiceHistoryUpdateWithWhereUniqueWithoutServiceTicketInput[]
    updateMany?: ServiceHistoryUpdateManyWithWhereWithoutServiceTicketInput | ServiceHistoryUpdateManyWithWhereWithoutServiceTicketInput[]
    deleteMany?: ServiceHistoryScalarWhereInput | ServiceHistoryScalarWhereInput[]
  }

  export type ServiceTicketCreateNestedOneWithoutPartsInput = {
    create?: XOR<ServiceTicketCreateWithoutPartsInput, ServiceTicketUncheckedCreateWithoutPartsInput>
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutPartsInput
    connect?: ServiceTicketWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutServicePartsInput = {
    create?: XOR<ProductCreateWithoutServicePartsInput, ProductUncheckedCreateWithoutServicePartsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutServicePartsInput
    connect?: ProductWhereUniqueInput
  }

  export type ServiceTicketUpdateOneRequiredWithoutPartsNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutPartsInput, ServiceTicketUncheckedCreateWithoutPartsInput>
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutPartsInput
    upsert?: ServiceTicketUpsertWithoutPartsInput
    connect?: ServiceTicketWhereUniqueInput
    update?: XOR<XOR<ServiceTicketUpdateToOneWithWhereWithoutPartsInput, ServiceTicketUpdateWithoutPartsInput>, ServiceTicketUncheckedUpdateWithoutPartsInput>
  }

  export type ProductUpdateOneRequiredWithoutServicePartsNestedInput = {
    create?: XOR<ProductCreateWithoutServicePartsInput, ProductUncheckedCreateWithoutServicePartsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutServicePartsInput
    upsert?: ProductUpsertWithoutServicePartsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutServicePartsInput, ProductUpdateWithoutServicePartsInput>, ProductUncheckedUpdateWithoutServicePartsInput>
  }

  export type ServiceTicketCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ServiceTicketCreateWithoutHistoryInput, ServiceTicketUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutHistoryInput
    connect?: ServiceTicketWhereUniqueInput
  }

  export type ServiceTicketUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutHistoryInput, ServiceTicketUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutHistoryInput
    upsert?: ServiceTicketUpsertWithoutHistoryInput
    connect?: ServiceTicketWhereUniqueInput
    update?: XOR<XOR<ServiceTicketUpdateToOneWithWhereWithoutHistoryInput, ServiceTicketUpdateWithoutHistoryInput>, ServiceTicketUncheckedUpdateWithoutHistoryInput>
  }

  export type TenantCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
  }

  export type ServiceTicketCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<ServiceTicketCreateWithoutTechnicianInput, ServiceTicketUncheckedCreateWithoutTechnicianInput> | ServiceTicketCreateWithoutTechnicianInput[] | ServiceTicketUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTechnicianInput | ServiceTicketCreateOrConnectWithoutTechnicianInput[]
    createMany?: ServiceTicketCreateManyTechnicianInputEnvelope
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
  }

  export type PosSessionCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PosSessionCreateWithoutEmployeeInput, PosSessionUncheckedCreateWithoutEmployeeInput> | PosSessionCreateWithoutEmployeeInput[] | PosSessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutEmployeeInput | PosSessionCreateOrConnectWithoutEmployeeInput[]
    createMany?: PosSessionCreateManyEmployeeInputEnvelope
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type ServiceTicketUncheckedCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<ServiceTicketCreateWithoutTechnicianInput, ServiceTicketUncheckedCreateWithoutTechnicianInput> | ServiceTicketCreateWithoutTechnicianInput[] | ServiceTicketUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTechnicianInput | ServiceTicketCreateOrConnectWithoutTechnicianInput[]
    createMany?: ServiceTicketCreateManyTechnicianInputEnvelope
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
  }

  export type PosSessionUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PosSessionCreateWithoutEmployeeInput, PosSessionUncheckedCreateWithoutEmployeeInput> | PosSessionCreateWithoutEmployeeInput[] | PosSessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutEmployeeInput | PosSessionCreateOrConnectWithoutEmployeeInput[]
    createMany?: PosSessionCreateManyEmployeeInputEnvelope
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    upsert?: TenantUpsertWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmployeesInput, TenantUpdateWithoutEmployeesInput>, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type ServiceTicketUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutTechnicianInput, ServiceTicketUncheckedCreateWithoutTechnicianInput> | ServiceTicketCreateWithoutTechnicianInput[] | ServiceTicketUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTechnicianInput | ServiceTicketCreateOrConnectWithoutTechnicianInput[]
    upsert?: ServiceTicketUpsertWithWhereUniqueWithoutTechnicianInput | ServiceTicketUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: ServiceTicketCreateManyTechnicianInputEnvelope
    set?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    disconnect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    delete?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    update?: ServiceTicketUpdateWithWhereUniqueWithoutTechnicianInput | ServiceTicketUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: ServiceTicketUpdateManyWithWhereWithoutTechnicianInput | ServiceTicketUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
  }

  export type PosSessionUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PosSessionCreateWithoutEmployeeInput, PosSessionUncheckedCreateWithoutEmployeeInput> | PosSessionCreateWithoutEmployeeInput[] | PosSessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutEmployeeInput | PosSessionCreateOrConnectWithoutEmployeeInput[]
    upsert?: PosSessionUpsertWithWhereUniqueWithoutEmployeeInput | PosSessionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PosSessionCreateManyEmployeeInputEnvelope
    set?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    disconnect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    delete?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    update?: PosSessionUpdateWithWhereUniqueWithoutEmployeeInput | PosSessionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PosSessionUpdateManyWithWhereWithoutEmployeeInput | PosSessionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PosSessionScalarWhereInput | PosSessionScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutEmployeeInput | PayrollUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutEmployeeInput | PayrollUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutEmployeeInput | PayrollUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type ServiceTicketUncheckedUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<ServiceTicketCreateWithoutTechnicianInput, ServiceTicketUncheckedCreateWithoutTechnicianInput> | ServiceTicketCreateWithoutTechnicianInput[] | ServiceTicketUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: ServiceTicketCreateOrConnectWithoutTechnicianInput | ServiceTicketCreateOrConnectWithoutTechnicianInput[]
    upsert?: ServiceTicketUpsertWithWhereUniqueWithoutTechnicianInput | ServiceTicketUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: ServiceTicketCreateManyTechnicianInputEnvelope
    set?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    disconnect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    delete?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    connect?: ServiceTicketWhereUniqueInput | ServiceTicketWhereUniqueInput[]
    update?: ServiceTicketUpdateWithWhereUniqueWithoutTechnicianInput | ServiceTicketUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: ServiceTicketUpdateManyWithWhereWithoutTechnicianInput | ServiceTicketUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
  }

  export type PosSessionUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PosSessionCreateWithoutEmployeeInput, PosSessionUncheckedCreateWithoutEmployeeInput> | PosSessionCreateWithoutEmployeeInput[] | PosSessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PosSessionCreateOrConnectWithoutEmployeeInput | PosSessionCreateOrConnectWithoutEmployeeInput[]
    upsert?: PosSessionUpsertWithWhereUniqueWithoutEmployeeInput | PosSessionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PosSessionCreateManyEmployeeInputEnvelope
    set?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    disconnect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    delete?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    connect?: PosSessionWhereUniqueInput | PosSessionWhereUniqueInput[]
    update?: PosSessionUpdateWithWhereUniqueWithoutEmployeeInput | PosSessionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PosSessionUpdateManyWithWhereWithoutEmployeeInput | PosSessionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PosSessionScalarWhereInput | PosSessionScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutEmployeeInput | PayrollUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutEmployeeInput | PayrollUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutEmployeeInput | PayrollUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollsInput
    upsert?: EmployeeUpsertWithoutPayrollsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPayrollsInput, EmployeeUpdateWithoutPayrollsInput>, EmployeeUncheckedUpdateWithoutPayrollsInput>
  }

  export type EmployeeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type EmployeeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    upsert?: EmployeeUpsertWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesInput, EmployeeUpdateWithoutLeavesInput>, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type PackageModuleCreateNestedManyWithoutModuleInput = {
    create?: XOR<PackageModuleCreateWithoutModuleInput, PackageModuleUncheckedCreateWithoutModuleInput> | PackageModuleCreateWithoutModuleInput[] | PackageModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutModuleInput | PackageModuleCreateOrConnectWithoutModuleInput[]
    createMany?: PackageModuleCreateManyModuleInputEnvelope
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
  }

  export type PackageModuleUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<PackageModuleCreateWithoutModuleInput, PackageModuleUncheckedCreateWithoutModuleInput> | PackageModuleCreateWithoutModuleInput[] | PackageModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutModuleInput | PackageModuleCreateOrConnectWithoutModuleInput[]
    createMany?: PackageModuleCreateManyModuleInputEnvelope
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
  }

  export type PackageModuleUpdateManyWithoutModuleNestedInput = {
    create?: XOR<PackageModuleCreateWithoutModuleInput, PackageModuleUncheckedCreateWithoutModuleInput> | PackageModuleCreateWithoutModuleInput[] | PackageModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutModuleInput | PackageModuleCreateOrConnectWithoutModuleInput[]
    upsert?: PackageModuleUpsertWithWhereUniqueWithoutModuleInput | PackageModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: PackageModuleCreateManyModuleInputEnvelope
    set?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    disconnect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    delete?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    update?: PackageModuleUpdateWithWhereUniqueWithoutModuleInput | PackageModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: PackageModuleUpdateManyWithWhereWithoutModuleInput | PackageModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: PackageModuleScalarWhereInput | PackageModuleScalarWhereInput[]
  }

  export type PackageModuleUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<PackageModuleCreateWithoutModuleInput, PackageModuleUncheckedCreateWithoutModuleInput> | PackageModuleCreateWithoutModuleInput[] | PackageModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: PackageModuleCreateOrConnectWithoutModuleInput | PackageModuleCreateOrConnectWithoutModuleInput[]
    upsert?: PackageModuleUpsertWithWhereUniqueWithoutModuleInput | PackageModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: PackageModuleCreateManyModuleInputEnvelope
    set?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    disconnect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    delete?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    connect?: PackageModuleWhereUniqueInput | PackageModuleWhereUniqueInput[]
    update?: PackageModuleUpdateWithWhereUniqueWithoutModuleInput | PackageModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: PackageModuleUpdateManyWithWhereWithoutModuleInput | PackageModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: PackageModuleScalarWhereInput | PackageModuleScalarWhereInput[]
  }

  export type SubscriptionPackageCreateNestedOneWithoutModulesInput = {
    create?: XOR<SubscriptionPackageCreateWithoutModulesInput, SubscriptionPackageUncheckedCreateWithoutModulesInput>
    connectOrCreate?: SubscriptionPackageCreateOrConnectWithoutModulesInput
    connect?: SubscriptionPackageWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutPackagesInput = {
    create?: XOR<ModuleCreateWithoutPackagesInput, ModuleUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPackagesInput
    connect?: ModuleWhereUniqueInput
  }

  export type SubscriptionPackageUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<SubscriptionPackageCreateWithoutModulesInput, SubscriptionPackageUncheckedCreateWithoutModulesInput>
    connectOrCreate?: SubscriptionPackageCreateOrConnectWithoutModulesInput
    upsert?: SubscriptionPackageUpsertWithoutModulesInput
    connect?: SubscriptionPackageWhereUniqueInput
    update?: XOR<XOR<SubscriptionPackageUpdateToOneWithWhereWithoutModulesInput, SubscriptionPackageUpdateWithoutModulesInput>, SubscriptionPackageUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<ModuleCreateWithoutPackagesInput, ModuleUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPackagesInput
    upsert?: ModuleUpsertWithoutPackagesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutPackagesInput, ModuleUpdateWithoutPackagesInput>, ModuleUncheckedUpdateWithoutPackagesInput>
  }

  export type UserCreateNestedManyWithoutSuperAdminRoleInput = {
    create?: XOR<UserCreateWithoutSuperAdminRoleInput, UserUncheckedCreateWithoutSuperAdminRoleInput> | UserCreateWithoutSuperAdminRoleInput[] | UserUncheckedCreateWithoutSuperAdminRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminRoleInput | UserCreateOrConnectWithoutSuperAdminRoleInput[]
    createMany?: UserCreateManySuperAdminRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSuperAdminRoleInput = {
    create?: XOR<UserCreateWithoutSuperAdminRoleInput, UserUncheckedCreateWithoutSuperAdminRoleInput> | UserCreateWithoutSuperAdminRoleInput[] | UserUncheckedCreateWithoutSuperAdminRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminRoleInput | UserCreateOrConnectWithoutSuperAdminRoleInput[]
    createMany?: UserCreateManySuperAdminRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutSuperAdminRoleNestedInput = {
    create?: XOR<UserCreateWithoutSuperAdminRoleInput, UserUncheckedCreateWithoutSuperAdminRoleInput> | UserCreateWithoutSuperAdminRoleInput[] | UserUncheckedCreateWithoutSuperAdminRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminRoleInput | UserCreateOrConnectWithoutSuperAdminRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSuperAdminRoleInput | UserUpsertWithWhereUniqueWithoutSuperAdminRoleInput[]
    createMany?: UserCreateManySuperAdminRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSuperAdminRoleInput | UserUpdateWithWhereUniqueWithoutSuperAdminRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSuperAdminRoleInput | UserUpdateManyWithWhereWithoutSuperAdminRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSuperAdminRoleNestedInput = {
    create?: XOR<UserCreateWithoutSuperAdminRoleInput, UserUncheckedCreateWithoutSuperAdminRoleInput> | UserCreateWithoutSuperAdminRoleInput[] | UserUncheckedCreateWithoutSuperAdminRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSuperAdminRoleInput | UserCreateOrConnectWithoutSuperAdminRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSuperAdminRoleInput | UserUpsertWithWhereUniqueWithoutSuperAdminRoleInput[]
    createMany?: UserCreateManySuperAdminRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSuperAdminRoleInput | UserUpdateWithWhereUniqueWithoutSuperAdminRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSuperAdminRoleInput | UserUpdateManyWithWhereWithoutSuperAdminRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIntegrationsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneWithoutIntegrationsNestedInput = {
    create?: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIntegrationsInput
    upsert?: TenantUpsertWithoutIntegrationsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutIntegrationsInput, TenantUpdateWithoutIntegrationsInput>, TenantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type TenantCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<TenantCreateWithoutTemplatesInput, TenantUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneWithoutTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutTemplatesInput, TenantUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTemplatesInput
    upsert?: TenantUpsertWithoutTemplatesInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTemplatesInput, TenantUpdateWithoutTemplatesInput>, TenantUncheckedUpdateWithoutTemplatesInput>
  }

  export type TenantCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSupportTicketsInput
    connect?: TenantWhereUniqueInput
  }

  export type TicketReplyCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketReplyCreateWithoutTicketInput, TicketReplyUncheckedCreateWithoutTicketInput> | TicketReplyCreateWithoutTicketInput[] | TicketReplyUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketReplyCreateOrConnectWithoutTicketInput | TicketReplyCreateOrConnectWithoutTicketInput[]
    createMany?: TicketReplyCreateManyTicketInputEnvelope
    connect?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
  }

  export type TicketReplyUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketReplyCreateWithoutTicketInput, TicketReplyUncheckedCreateWithoutTicketInput> | TicketReplyCreateWithoutTicketInput[] | TicketReplyUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketReplyCreateOrConnectWithoutTicketInput | TicketReplyCreateOrConnectWithoutTicketInput[]
    createMany?: TicketReplyCreateManyTicketInputEnvelope
    connect?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type TenantUpdateOneRequiredWithoutSupportTicketsNestedInput = {
    create?: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSupportTicketsInput
    upsert?: TenantUpsertWithoutSupportTicketsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSupportTicketsInput, TenantUpdateWithoutSupportTicketsInput>, TenantUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type TicketReplyUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketReplyCreateWithoutTicketInput, TicketReplyUncheckedCreateWithoutTicketInput> | TicketReplyCreateWithoutTicketInput[] | TicketReplyUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketReplyCreateOrConnectWithoutTicketInput | TicketReplyCreateOrConnectWithoutTicketInput[]
    upsert?: TicketReplyUpsertWithWhereUniqueWithoutTicketInput | TicketReplyUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketReplyCreateManyTicketInputEnvelope
    set?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    disconnect?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    delete?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    connect?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    update?: TicketReplyUpdateWithWhereUniqueWithoutTicketInput | TicketReplyUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketReplyUpdateManyWithWhereWithoutTicketInput | TicketReplyUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketReplyScalarWhereInput | TicketReplyScalarWhereInput[]
  }

  export type TicketReplyUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketReplyCreateWithoutTicketInput, TicketReplyUncheckedCreateWithoutTicketInput> | TicketReplyCreateWithoutTicketInput[] | TicketReplyUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketReplyCreateOrConnectWithoutTicketInput | TicketReplyCreateOrConnectWithoutTicketInput[]
    upsert?: TicketReplyUpsertWithWhereUniqueWithoutTicketInput | TicketReplyUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketReplyCreateManyTicketInputEnvelope
    set?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    disconnect?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    delete?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    connect?: TicketReplyWhereUniqueInput | TicketReplyWhereUniqueInput[]
    update?: TicketReplyUpdateWithWhereUniqueWithoutTicketInput | TicketReplyUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketReplyUpdateManyWithWhereWithoutTicketInput | TicketReplyUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketReplyScalarWhereInput | TicketReplyScalarWhereInput[]
  }

  export type SupportTicketCreateNestedOneWithoutRepliesInput = {
    create?: XOR<SupportTicketCreateWithoutRepliesInput, SupportTicketUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRepliesInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type SupportTicketUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<SupportTicketCreateWithoutRepliesInput, SupportTicketUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutRepliesInput
    upsert?: SupportTicketUpsertWithoutRepliesInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutRepliesInput, SupportTicketUpdateWithoutRepliesInput>, SupportTicketUncheckedUpdateWithoutRepliesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type NestedEnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type NestedEnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type TenantCreateWithoutSubscriptionPackageInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSubscriptionPackageInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSubscriptionPackageInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSubscriptionPackageInput, TenantUncheckedCreateWithoutSubscriptionPackageInput>
  }

  export type TenantCreateManySubscriptionPackageInputEnvelope = {
    data: TenantCreateManySubscriptionPackageInput | TenantCreateManySubscriptionPackageInput[]
    skipDuplicates?: boolean
  }

  export type PackageModuleCreateWithoutPackageInput = {
    id?: string
    module: ModuleCreateNestedOneWithoutPackagesInput
  }

  export type PackageModuleUncheckedCreateWithoutPackageInput = {
    id?: string
    moduleId: string
  }

  export type PackageModuleCreateOrConnectWithoutPackageInput = {
    where: PackageModuleWhereUniqueInput
    create: XOR<PackageModuleCreateWithoutPackageInput, PackageModuleUncheckedCreateWithoutPackageInput>
  }

  export type PackageModuleCreateManyPackageInputEnvelope = {
    data: PackageModuleCreateManyPackageInput | PackageModuleCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithWhereUniqueWithoutSubscriptionPackageInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutSubscriptionPackageInput, TenantUncheckedUpdateWithoutSubscriptionPackageInput>
    create: XOR<TenantCreateWithoutSubscriptionPackageInput, TenantUncheckedCreateWithoutSubscriptionPackageInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutSubscriptionPackageInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutSubscriptionPackageInput, TenantUncheckedUpdateWithoutSubscriptionPackageInput>
  }

  export type TenantUpdateManyWithWhereWithoutSubscriptionPackageInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutSubscriptionPackageInput>
  }

  export type TenantScalarWhereInput = {
    AND?: TenantScalarWhereInput | TenantScalarWhereInput[]
    OR?: TenantScalarWhereInput[]
    NOT?: TenantScalarWhereInput | TenantScalarWhereInput[]
    id?: StringFilter<"Tenant"> | string
    tag?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    taxNumber?: StringNullableFilter<"Tenant"> | string | null
    taxOffice?: StringNullableFilter<"Tenant"> | string | null
    contactEmail?: StringNullableFilter<"Tenant"> | string | null
    contactPhone?: StringNullableFilter<"Tenant"> | string | null
    address?: JsonNullableFilter<"Tenant">
    subscriptionPlanId?: StringNullableFilter<"Tenant"> | string | null
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    subscriptionStart?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    config?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
  }

  export type PackageModuleUpsertWithWhereUniqueWithoutPackageInput = {
    where: PackageModuleWhereUniqueInput
    update: XOR<PackageModuleUpdateWithoutPackageInput, PackageModuleUncheckedUpdateWithoutPackageInput>
    create: XOR<PackageModuleCreateWithoutPackageInput, PackageModuleUncheckedCreateWithoutPackageInput>
  }

  export type PackageModuleUpdateWithWhereUniqueWithoutPackageInput = {
    where: PackageModuleWhereUniqueInput
    data: XOR<PackageModuleUpdateWithoutPackageInput, PackageModuleUncheckedUpdateWithoutPackageInput>
  }

  export type PackageModuleUpdateManyWithWhereWithoutPackageInput = {
    where: PackageModuleScalarWhereInput
    data: XOR<PackageModuleUpdateManyMutationInput, PackageModuleUncheckedUpdateManyWithoutPackageInput>
  }

  export type PackageModuleScalarWhereInput = {
    AND?: PackageModuleScalarWhereInput | PackageModuleScalarWhereInput[]
    OR?: PackageModuleScalarWhereInput[]
    NOT?: PackageModuleScalarWhereInput | PackageModuleScalarWhereInput[]
    id?: StringFilter<"PackageModule"> | string
    packageId?: StringFilter<"PackageModule"> | string
    moduleId?: StringFilter<"PackageModule"> | string
  }

  export type SubscriptionPackageCreateWithoutTenantsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    maxUsers?: number
    maxProducts?: number
    storageLimit?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: number
    isDemo?: boolean
    demoDuration?: number
    discountPercentage?: Decimal | DecimalJsLike | number | string
    discountEndDate?: Date | string | null
    highlightColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: PackageModuleCreateNestedManyWithoutPackageInput
  }

  export type SubscriptionPackageUncheckedCreateWithoutTenantsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    maxUsers?: number
    maxProducts?: number
    storageLimit?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: number
    isDemo?: boolean
    demoDuration?: number
    discountPercentage?: Decimal | DecimalJsLike | number | string
    discountEndDate?: Date | string | null
    highlightColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: PackageModuleUncheckedCreateNestedManyWithoutPackageInput
  }

  export type SubscriptionPackageCreateOrConnectWithoutTenantsInput = {
    where: SubscriptionPackageWhereUniqueInput
    create: XOR<SubscriptionPackageCreateWithoutTenantsInput, SubscriptionPackageUncheckedCreateWithoutTenantsInput>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    userNo?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    superAdminRole?: SuperAdminRoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    userNo?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    superAdminRoleId?: string | null
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutTenantInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    offers?: OfferCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutCustomerInput
  }

  export type AccountUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    offers?: OfferUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AccountCreateOrConnectWithoutTenantInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTenantInput, AccountUncheckedCreateWithoutTenantInput>
  }

  export type AccountCreateManyTenantInputEnvelope = {
    data: AccountCreateManyTenantInput | AccountCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutTenantInput = {
    id?: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTenantInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductCreateManyTenantInputEnvelope = {
    data: ProductCreateManyTenantInput | ProductCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    accountId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutTenantInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutOffersInput
    items?: InvoiceItemCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutTenantInput = {
    id?: string
    accountId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutTenantInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutTenantInput, OfferUncheckedCreateWithoutTenantInput>
  }

  export type OfferCreateManyTenantInputEnvelope = {
    data: OfferCreateManyTenantInput | OfferCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutTenantInput = {
    id?: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutTenantInput = {
    id?: string
    productId: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutTenantInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutTenantInput, StockMovementUncheckedCreateWithoutTenantInput>
  }

  export type StockMovementCreateManyTenantInputEnvelope = {
    data: StockMovementCreateManyTenantInput | StockMovementCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutTenantInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    createdAt?: Date | string
    register: CashRegisterCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTenantInput = {
    id?: string
    registerId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionCreateManyTenantInputEnvelope = {
    data: TransactionCreateManyTenantInput | TransactionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTicketCreateWithoutTenantInput = {
    id?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: AccountCreateNestedOneWithoutServiceTicketsInput
    technician?: EmployeeCreateNestedOneWithoutTicketsInput
    parts?: ServicePartCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketUncheckedCreateWithoutTenantInput = {
    id?: string
    customerId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: ServicePartUncheckedCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryUncheckedCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketCreateOrConnectWithoutTenantInput = {
    where: ServiceTicketWhereUniqueInput
    create: XOR<ServiceTicketCreateWithoutTenantInput, ServiceTicketUncheckedCreateWithoutTenantInput>
  }

  export type ServiceTicketCreateManyTenantInputEnvelope = {
    data: ServiceTicketCreateManyTenantInput | ServiceTicketCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CashRegisterCreateWithoutTenantInput = {
    id?: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutRegisterInput
    posSessions?: PosSessionCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRegisterInput
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutTenantInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput>
  }

  export type CashRegisterCreateManyTenantInputEnvelope = {
    data: CashRegisterCreateManyTenantInput | CashRegisterCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tickets?: ServiceTicketCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tickets?: ServiceTicketUncheckedCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeCreateManyTenantInputEnvelope = {
    data: EmployeeCreateManyTenantInput | EmployeeCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SaaSPaymentCreateWithoutTenantInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaaSPaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaaSPaymentCreateOrConnectWithoutTenantInput = {
    where: SaaSPaymentWhereUniqueInput
    create: XOR<SaaSPaymentCreateWithoutTenantInput, SaaSPaymentUncheckedCreateWithoutTenantInput>
  }

  export type SaaSPaymentCreateManyTenantInputEnvelope = {
    data: SaaSPaymentCreateManyTenantInput | SaaSPaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutTenantInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUncheckedCreateWithoutTenantInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput>
  }

  export type IntegrationCreateManyTenantInputEnvelope = {
    data: IntegrationCreateManyTenantInput | IntegrationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutTenantInput = {
    id?: string
    type: string
    code: string
    name: string
    subject?: string | null
    content: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    type: string
    code: string
    name: string
    subject?: string | null
    content: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCreateOrConnectWithoutTenantInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutTenantInput, TemplateUncheckedCreateWithoutTenantInput>
  }

  export type TemplateCreateManyTenantInputEnvelope = {
    data: TemplateCreateManyTenantInput | TemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutTenantInput = {
    id?: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: TicketReplyCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: TicketReplyUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutTenantInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput>
  }

  export type SupportTicketCreateManyTenantInputEnvelope = {
    data: SupportTicketCreateManyTenantInput | SupportTicketCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionPackageUpsertWithoutTenantsInput = {
    update: XOR<SubscriptionPackageUpdateWithoutTenantsInput, SubscriptionPackageUncheckedUpdateWithoutTenantsInput>
    create: XOR<SubscriptionPackageCreateWithoutTenantsInput, SubscriptionPackageUncheckedCreateWithoutTenantsInput>
    where?: SubscriptionPackageWhereInput
  }

  export type SubscriptionPackageUpdateToOneWithWhereWithoutTenantsInput = {
    where?: SubscriptionPackageWhereInput
    data: XOR<SubscriptionPackageUpdateWithoutTenantsInput, SubscriptionPackageUncheckedUpdateWithoutTenantsInput>
  }

  export type SubscriptionPackageUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: PackageModuleUpdateManyWithoutPackageNestedInput
  }

  export type SubscriptionPackageUncheckedUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: PackageModuleUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    userNo?: IntFilter<"User"> | number
    tenantId?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    permissions?: JsonNullableFilter<"User">
    bio?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isTwoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isSuperAdmin?: BoolFilter<"User"> | boolean
    superAdminRoleId?: StringNullableFilter<"User"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutTenantInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutTenantInput, AccountUncheckedUpdateWithoutTenantInput>
    create: XOR<AccountCreateWithoutTenantInput, AccountUncheckedCreateWithoutTenantInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutTenantInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutTenantInput, AccountUncheckedUpdateWithoutTenantInput>
  }

  export type AccountUpdateManyWithWhereWithoutTenantInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutTenantInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    tenantId?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    accountCode?: StringNullableFilter<"Account"> | string | null
    name?: StringFilter<"Account"> | string
    balance?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    riskLimit?: DecimalNullableFilter<"Account"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
  }

  export type ProductUpdateManyWithWhereWithoutTenantInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    tenantId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    barcode?: StringNullableFilter<"Product"> | string | null
    stockQuantity?: IntFilter<"Product"> | number
    priceSell?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    accountId?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type OfferUpsertWithWhereUniqueWithoutTenantInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutTenantInput, OfferUncheckedUpdateWithoutTenantInput>
    create: XOR<OfferCreateWithoutTenantInput, OfferUncheckedCreateWithoutTenantInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutTenantInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutTenantInput, OfferUncheckedUpdateWithoutTenantInput>
  }

  export type OfferUpdateManyWithWhereWithoutTenantInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutTenantInput>
  }

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[]
    OR?: OfferScalarWhereInput[]
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[]
    id?: StringFilter<"Offer"> | string
    tenantId?: StringFilter<"Offer"> | string
    accountId?: StringFilter<"Offer"> | string
    totalAmount?: DecimalFilter<"Offer"> | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    validUntil?: DateTimeNullableFilter<"Offer"> | Date | string | null
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutTenantInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutTenantInput, StockMovementUncheckedUpdateWithoutTenantInput>
    create: XOR<StockMovementCreateWithoutTenantInput, StockMovementUncheckedCreateWithoutTenantInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutTenantInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutTenantInput, StockMovementUncheckedUpdateWithoutTenantInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutTenantInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutTenantInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    tenantId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    type?: EnumStockMovementTypeFilter<"StockMovement"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockMovement"> | number
    documentRef?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTenantInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTenantInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    registerId?: StringFilter<"Transaction"> | string
    accountId?: StringNullableFilter<"Transaction"> | string | null
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    exchangeRate?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Transaction"> | string | null
    relatedId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type ServiceTicketUpsertWithWhereUniqueWithoutTenantInput = {
    where: ServiceTicketWhereUniqueInput
    update: XOR<ServiceTicketUpdateWithoutTenantInput, ServiceTicketUncheckedUpdateWithoutTenantInput>
    create: XOR<ServiceTicketCreateWithoutTenantInput, ServiceTicketUncheckedCreateWithoutTenantInput>
  }

  export type ServiceTicketUpdateWithWhereUniqueWithoutTenantInput = {
    where: ServiceTicketWhereUniqueInput
    data: XOR<ServiceTicketUpdateWithoutTenantInput, ServiceTicketUncheckedUpdateWithoutTenantInput>
  }

  export type ServiceTicketUpdateManyWithWhereWithoutTenantInput = {
    where: ServiceTicketScalarWhereInput
    data: XOR<ServiceTicketUpdateManyMutationInput, ServiceTicketUncheckedUpdateManyWithoutTenantInput>
  }

  export type ServiceTicketScalarWhereInput = {
    AND?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
    OR?: ServiceTicketScalarWhereInput[]
    NOT?: ServiceTicketScalarWhereInput | ServiceTicketScalarWhereInput[]
    id?: StringFilter<"ServiceTicket"> | string
    tenantId?: StringFilter<"ServiceTicket"> | string
    customerId?: StringFilter<"ServiceTicket"> | string
    technicianId?: StringNullableFilter<"ServiceTicket"> | string | null
    deviceInfo?: JsonNullableFilter<"ServiceTicket">
    problemDesc?: StringNullableFilter<"ServiceTicket"> | string | null
    status?: EnumServiceStatusFilter<"ServiceTicket"> | $Enums.ServiceStatus
    estimatedCost?: DecimalNullableFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    finalCost?: DecimalNullableFilter<"ServiceTicket"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ServiceTicket"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTicket"> | Date | string
  }

  export type CashRegisterUpsertWithWhereUniqueWithoutTenantInput = {
    where: CashRegisterWhereUniqueInput
    update: XOR<CashRegisterUpdateWithoutTenantInput, CashRegisterUncheckedUpdateWithoutTenantInput>
    create: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput>
  }

  export type CashRegisterUpdateWithWhereUniqueWithoutTenantInput = {
    where: CashRegisterWhereUniqueInput
    data: XOR<CashRegisterUpdateWithoutTenantInput, CashRegisterUncheckedUpdateWithoutTenantInput>
  }

  export type CashRegisterUpdateManyWithWhereWithoutTenantInput = {
    where: CashRegisterScalarWhereInput
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyWithoutTenantInput>
  }

  export type CashRegisterScalarWhereInput = {
    AND?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
    OR?: CashRegisterScalarWhereInput[]
    NOT?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
    id?: StringFilter<"CashRegister"> | string
    tenantId?: StringFilter<"CashRegister"> | string
    name?: StringFilter<"CashRegister"> | string
    currency?: StringFilter<"CashRegister"> | string
    balance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CashRegister"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutTenantInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutTenantInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    tenantId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type SaaSPaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: SaaSPaymentWhereUniqueInput
    update: XOR<SaaSPaymentUpdateWithoutTenantInput, SaaSPaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<SaaSPaymentCreateWithoutTenantInput, SaaSPaymentUncheckedCreateWithoutTenantInput>
  }

  export type SaaSPaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: SaaSPaymentWhereUniqueInput
    data: XOR<SaaSPaymentUpdateWithoutTenantInput, SaaSPaymentUncheckedUpdateWithoutTenantInput>
  }

  export type SaaSPaymentUpdateManyWithWhereWithoutTenantInput = {
    where: SaaSPaymentScalarWhereInput
    data: XOR<SaaSPaymentUpdateManyMutationInput, SaaSPaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type SaaSPaymentScalarWhereInput = {
    AND?: SaaSPaymentScalarWhereInput | SaaSPaymentScalarWhereInput[]
    OR?: SaaSPaymentScalarWhereInput[]
    NOT?: SaaSPaymentScalarWhereInput | SaaSPaymentScalarWhereInput[]
    id?: StringFilter<"SaaSPayment"> | string
    tenantId?: StringFilter<"SaaSPayment"> | string
    amount?: DecimalFilter<"SaaSPayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"SaaSPayment"> | Date | string
    description?: StringNullableFilter<"SaaSPayment"> | string | null
    status?: StringFilter<"SaaSPayment"> | string
    createdAt?: DateTimeFilter<"SaaSPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SaaSPayment"> | Date | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutTenantInput, IntegrationUncheckedUpdateWithoutTenantInput>
    create: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutTenantInput, IntegrationUncheckedUpdateWithoutTenantInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutTenantInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutTenantInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    tenantId?: StringNullableFilter<"Integration"> | string | null
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type TemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutTenantInput, TemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<TemplateCreateWithoutTenantInput, TemplateUncheckedCreateWithoutTenantInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutTenantInput, TemplateUncheckedUpdateWithoutTenantInput>
  }

  export type TemplateUpdateManyWithWhereWithoutTenantInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type TemplateScalarWhereInput = {
    AND?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    OR?: TemplateScalarWhereInput[]
    NOT?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    id?: StringFilter<"Template"> | string
    tenantId?: StringNullableFilter<"Template"> | string | null
    type?: StringFilter<"Template"> | string
    code?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    subject?: StringNullableFilter<"Template"> | string | null
    content?: StringFilter<"Template"> | string
    isSystem?: BoolFilter<"Template"> | boolean
    isActive?: BoolFilter<"Template"> | boolean
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutTenantInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutTenantInput, SupportTicketUncheckedUpdateWithoutTenantInput>
    create: XOR<SupportTicketCreateWithoutTenantInput, SupportTicketUncheckedCreateWithoutTenantInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutTenantInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutTenantInput, SupportTicketUncheckedUpdateWithoutTenantInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutTenantInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutTenantInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    tenantId?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type SuperAdminRoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminRoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminRoleCreateOrConnectWithoutUsersInput = {
    where: SuperAdminRoleWhereUniqueInput
    create: XOR<SuperAdminRoleCreateWithoutUsersInput, SuperAdminRoleUncheckedCreateWithoutUsersInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SuperAdminRoleUpsertWithoutUsersInput = {
    update: XOR<SuperAdminRoleUpdateWithoutUsersInput, SuperAdminRoleUncheckedUpdateWithoutUsersInput>
    create: XOR<SuperAdminRoleCreateWithoutUsersInput, SuperAdminRoleUncheckedCreateWithoutUsersInput>
    where?: SuperAdminRoleWhereInput
  }

  export type SuperAdminRoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: SuperAdminRoleWhereInput
    data: XOR<SuperAdminRoleUpdateWithoutUsersInput, SuperAdminRoleUncheckedUpdateWithoutUsersInput>
  }

  export type SuperAdminRoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminRoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type TenantCreateWithoutAccountsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAccountsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAccountsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAccountsInput, TenantUncheckedCreateWithoutAccountsInput>
  }

  export type InvoiceCreateWithoutAccountInput = {
    id?: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutAccountInput = {
    id?: string
    tenantId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutAccountInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput>
  }

  export type InvoiceCreateManyAccountInputEnvelope = {
    data: InvoiceCreateManyAccountInput | InvoiceCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutAccountInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOffersInput
    items?: InvoiceItemCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutAccountInput = {
    id?: string
    tenantId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutAccountInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutAccountInput, OfferUncheckedCreateWithoutAccountInput>
  }

  export type OfferCreateManyAccountInputEnvelope = {
    data: OfferCreateManyAccountInput | OfferCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutAccountInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    register: CashRegisterCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    tenantId: string
    registerId: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTicketCreateWithoutCustomerInput = {
    id?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutServiceTicketsInput
    technician?: EmployeeCreateNestedOneWithoutTicketsInput
    parts?: ServicePartCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: ServicePartUncheckedCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryUncheckedCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketCreateOrConnectWithoutCustomerInput = {
    where: ServiceTicketWhereUniqueInput
    create: XOR<ServiceTicketCreateWithoutCustomerInput, ServiceTicketUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceTicketCreateManyCustomerInputEnvelope = {
    data: ServiceTicketCreateManyCustomerInput | ServiceTicketCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAccountsInput = {
    update: XOR<TenantUpdateWithoutAccountsInput, TenantUncheckedUpdateWithoutAccountsInput>
    create: XOR<TenantCreateWithoutAccountsInput, TenantUncheckedCreateWithoutAccountsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAccountsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAccountsInput, TenantUncheckedUpdateWithoutAccountsInput>
  }

  export type TenantUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutAccountInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutAccountInput, InvoiceUncheckedUpdateWithoutAccountInput>
    create: XOR<InvoiceCreateWithoutAccountInput, InvoiceUncheckedCreateWithoutAccountInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutAccountInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutAccountInput, InvoiceUncheckedUpdateWithoutAccountInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutAccountInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutAccountInput>
  }

  export type OfferUpsertWithWhereUniqueWithoutAccountInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutAccountInput, OfferUncheckedUpdateWithoutAccountInput>
    create: XOR<OfferCreateWithoutAccountInput, OfferUncheckedCreateWithoutAccountInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutAccountInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutAccountInput, OfferUncheckedUpdateWithoutAccountInput>
  }

  export type OfferUpdateManyWithWhereWithoutAccountInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutAccountInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type ServiceTicketUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServiceTicketWhereUniqueInput
    update: XOR<ServiceTicketUpdateWithoutCustomerInput, ServiceTicketUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServiceTicketCreateWithoutCustomerInput, ServiceTicketUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceTicketUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServiceTicketWhereUniqueInput
    data: XOR<ServiceTicketUpdateWithoutCustomerInput, ServiceTicketUncheckedUpdateWithoutCustomerInput>
  }

  export type ServiceTicketUpdateManyWithWhereWithoutCustomerInput = {
    where: ServiceTicketScalarWhereInput
    data: XOR<ServiceTicketUpdateManyMutationInput, ServiceTicketUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TenantCreateWithoutProductsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutProductsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutProductsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
  }

  export type StockMovementCreateWithoutProductInput = {
    id?: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutProductInput = {
    id?: string
    tenantId: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementCreateManyProductInputEnvelope = {
    data: StockMovementCreateManyProductInput | StockMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutProductInput = {
    id?: string
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    invoice?: InvoiceCreateNestedOneWithoutItemsInput
    offer?: OfferCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutProductInput = {
    id?: string
    invoiceId?: string | null
    offerId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemCreateManyProductInputEnvelope = {
    data: InvoiceItemCreateManyProductInput | InvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ServicePartCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    serviceTicket: ServiceTicketCreateNestedOneWithoutPartsInput
  }

  export type ServicePartUncheckedCreateWithoutProductInput = {
    id?: string
    serviceTicketId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type ServicePartCreateOrConnectWithoutProductInput = {
    where: ServicePartWhereUniqueInput
    create: XOR<ServicePartCreateWithoutProductInput, ServicePartUncheckedCreateWithoutProductInput>
  }

  export type ServicePartCreateManyProductInputEnvelope = {
    data: ServicePartCreateManyProductInput | ServicePartCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutProductsInput = {
    update: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutProductsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type TenantUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StockMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutProductInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringNullableFilter<"InvoiceItem"> | string | null
    offerId?: StringNullableFilter<"InvoiceItem"> | string | null
    productId?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    price?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type ServicePartUpsertWithWhereUniqueWithoutProductInput = {
    where: ServicePartWhereUniqueInput
    update: XOR<ServicePartUpdateWithoutProductInput, ServicePartUncheckedUpdateWithoutProductInput>
    create: XOR<ServicePartCreateWithoutProductInput, ServicePartUncheckedCreateWithoutProductInput>
  }

  export type ServicePartUpdateWithWhereUniqueWithoutProductInput = {
    where: ServicePartWhereUniqueInput
    data: XOR<ServicePartUpdateWithoutProductInput, ServicePartUncheckedUpdateWithoutProductInput>
  }

  export type ServicePartUpdateManyWithWhereWithoutProductInput = {
    where: ServicePartScalarWhereInput
    data: XOR<ServicePartUpdateManyMutationInput, ServicePartUncheckedUpdateManyWithoutProductInput>
  }

  export type ServicePartScalarWhereInput = {
    AND?: ServicePartScalarWhereInput | ServicePartScalarWhereInput[]
    OR?: ServicePartScalarWhereInput[]
    NOT?: ServicePartScalarWhereInput | ServicePartScalarWhereInput[]
    id?: StringFilter<"ServicePart"> | string
    serviceTicketId?: StringFilter<"ServicePart"> | string
    productId?: StringFilter<"ServicePart"> | string
    quantity?: IntFilter<"ServicePart"> | number
    price?: DecimalFilter<"ServicePart"> | Decimal | DecimalJsLike | number | string
  }

  export type TenantCreateWithoutStockMovementsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStockMovementsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStockMovementsInput, TenantUncheckedCreateWithoutStockMovementsInput>
  }

  export type ProductCreateWithoutStockMovementsInput = {
    id?: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    tenantId: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockMovementsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
  }

  export type TenantUpsertWithoutStockMovementsInput = {
    update: XOR<TenantUpdateWithoutStockMovementsInput, TenantUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<TenantCreateWithoutStockMovementsInput, TenantUncheckedCreateWithoutStockMovementsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStockMovementsInput, TenantUncheckedUpdateWithoutStockMovementsInput>
  }

  export type TenantUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProductUpsertWithoutStockMovementsInput = {
    update: XOR<ProductUpdateWithoutStockMovementsInput, ProductUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockMovementsInput, ProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TenantCreateWithoutCashRegistersInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCashRegistersInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCashRegistersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
  }

  export type TransactionCreateWithoutRegisterInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutRegisterInput = {
    id?: string
    tenantId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutRegisterInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutRegisterInput, TransactionUncheckedCreateWithoutRegisterInput>
  }

  export type TransactionCreateManyRegisterInputEnvelope = {
    data: TransactionCreateManyRegisterInput | TransactionCreateManyRegisterInput[]
    skipDuplicates?: boolean
  }

  export type PosSessionCreateWithoutRegisterInput = {
    id?: string
    tenantId: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
    employee?: EmployeeCreateNestedOneWithoutPosSessionsInput
  }

  export type PosSessionUncheckedCreateWithoutRegisterInput = {
    id?: string
    tenantId: string
    employeeId?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionCreateOrConnectWithoutRegisterInput = {
    where: PosSessionWhereUniqueInput
    create: XOR<PosSessionCreateWithoutRegisterInput, PosSessionUncheckedCreateWithoutRegisterInput>
  }

  export type PosSessionCreateManyRegisterInputEnvelope = {
    data: PosSessionCreateManyRegisterInput | PosSessionCreateManyRegisterInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCashRegistersInput = {
    update: XOR<TenantUpdateWithoutCashRegistersInput, TenantUncheckedUpdateWithoutCashRegistersInput>
    create: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCashRegistersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCashRegistersInput, TenantUncheckedUpdateWithoutCashRegistersInput>
  }

  export type TenantUpdateWithoutCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutRegisterInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutRegisterInput, TransactionUncheckedUpdateWithoutRegisterInput>
    create: XOR<TransactionCreateWithoutRegisterInput, TransactionUncheckedCreateWithoutRegisterInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutRegisterInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutRegisterInput, TransactionUncheckedUpdateWithoutRegisterInput>
  }

  export type TransactionUpdateManyWithWhereWithoutRegisterInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutRegisterInput>
  }

  export type PosSessionUpsertWithWhereUniqueWithoutRegisterInput = {
    where: PosSessionWhereUniqueInput
    update: XOR<PosSessionUpdateWithoutRegisterInput, PosSessionUncheckedUpdateWithoutRegisterInput>
    create: XOR<PosSessionCreateWithoutRegisterInput, PosSessionUncheckedCreateWithoutRegisterInput>
  }

  export type PosSessionUpdateWithWhereUniqueWithoutRegisterInput = {
    where: PosSessionWhereUniqueInput
    data: XOR<PosSessionUpdateWithoutRegisterInput, PosSessionUncheckedUpdateWithoutRegisterInput>
  }

  export type PosSessionUpdateManyWithWhereWithoutRegisterInput = {
    where: PosSessionScalarWhereInput
    data: XOR<PosSessionUpdateManyMutationInput, PosSessionUncheckedUpdateManyWithoutRegisterInput>
  }

  export type PosSessionScalarWhereInput = {
    AND?: PosSessionScalarWhereInput | PosSessionScalarWhereInput[]
    OR?: PosSessionScalarWhereInput[]
    NOT?: PosSessionScalarWhereInput | PosSessionScalarWhereInput[]
    id?: StringFilter<"PosSession"> | string
    tenantId?: StringFilter<"PosSession"> | string
    registerId?: StringFilter<"PosSession"> | string
    employeeId?: StringNullableFilter<"PosSession"> | string | null
    openedAt?: DateTimeFilter<"PosSession"> | Date | string
    closedAt?: DateTimeNullableFilter<"PosSession"> | Date | string | null
    openingBalance?: DecimalFilter<"PosSession"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalNullableFilter<"PosSession"> | Decimal | DecimalJsLike | number | string | null
  }

  export type TenantCreateWithoutTransactionsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTransactionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
  }

  export type CashRegisterCreateWithoutTransactionsInput = {
    id?: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
    posSessions?: PosSessionCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutTransactionsInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountCreateWithoutTransactionsInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAccountsInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    offers?: OfferCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutCustomerInput
  }

  export type AccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    offers?: OfferUncheckedCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AccountCreateOrConnectWithoutTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
  }

  export type InvoiceCreateWithoutTransactionsInput = {
    id?: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    account: AccountCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    accountId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
  }

  export type TenantUpsertWithoutTransactionsInput = {
    update: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CashRegisterUpsertWithoutTransactionsInput = {
    update: XOR<CashRegisterUpdateWithoutTransactionsInput, CashRegisterUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
    where?: CashRegisterWhereInput
  }

  export type CashRegisterUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CashRegisterWhereInput
    data: XOR<CashRegisterUpdateWithoutTransactionsInput, CashRegisterUncheckedUpdateWithoutTransactionsInput>
  }

  export type CashRegisterUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
    posSessions?: PosSessionUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posSessions?: PosSessionUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type AccountUpsertWithoutTransactionsInput = {
    update: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAccountsNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    offers?: OfferUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutCustomerNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type InvoiceUpsertWithoutTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    account?: AccountUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type AccountCreateWithoutInvoicesInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAccountsInput
    offers?: OfferCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutCustomerInput
  }

  export type AccountUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: OfferUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AccountCreateOrConnectWithoutInvoicesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    offer?: OfferCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    offerId?: string | null
    productId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutInvoiceInput = {
    id?: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    register: CashRegisterCreateNestedOneWithoutTransactionsInput
    account?: AccountCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    registerId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionCreateManyInvoiceInputEnvelope = {
    data: TransactionCreateManyInvoiceInput | TransactionCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AccountUpsertWithoutInvoicesInput = {
    update: XOR<AccountUpdateWithoutInvoicesInput, AccountUncheckedUpdateWithoutInvoicesInput>
    create: XOR<AccountCreateWithoutInvoicesInput, AccountUncheckedCreateWithoutInvoicesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutInvoicesInput, AccountUncheckedUpdateWithoutInvoicesInput>
  }

  export type AccountUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAccountsNestedInput
    offers?: OfferUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutCustomerNestedInput
  }

  export type AccountUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: OfferUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutInvoiceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TenantCreateWithoutOffersInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOffersInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOffersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOffersInput, TenantUncheckedCreateWithoutOffersInput>
  }

  export type AccountCreateWithoutOffersInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAccountsInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutCustomerInput
  }

  export type AccountUncheckedCreateWithoutOffersInput = {
    id?: string
    tenantId: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type AccountCreateOrConnectWithoutOffersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutOffersInput, AccountUncheckedCreateWithoutOffersInput>
  }

  export type InvoiceItemCreateWithoutOfferInput = {
    id?: string
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    invoice?: InvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutOfferInput = {
    id?: string
    invoiceId?: string | null
    productId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutOfferInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutOfferInput, InvoiceItemUncheckedCreateWithoutOfferInput>
  }

  export type InvoiceItemCreateManyOfferInputEnvelope = {
    data: InvoiceItemCreateManyOfferInput | InvoiceItemCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutOffersInput = {
    update: XOR<TenantUpdateWithoutOffersInput, TenantUncheckedUpdateWithoutOffersInput>
    create: XOR<TenantCreateWithoutOffersInput, TenantUncheckedCreateWithoutOffersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOffersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOffersInput, TenantUncheckedUpdateWithoutOffersInput>
  }

  export type TenantUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AccountUpsertWithoutOffersInput = {
    update: XOR<AccountUpdateWithoutOffersInput, AccountUncheckedUpdateWithoutOffersInput>
    create: XOR<AccountCreateWithoutOffersInput, AccountUncheckedCreateWithoutOffersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutOffersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutOffersInput, AccountUncheckedUpdateWithoutOffersInput>
  }

  export type AccountUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAccountsNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutCustomerNestedInput
  }

  export type AccountUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutOfferInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutOfferInput, InvoiceItemUncheckedUpdateWithoutOfferInput>
    create: XOR<InvoiceItemCreateWithoutOfferInput, InvoiceItemUncheckedCreateWithoutOfferInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutOfferInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutOfferInput, InvoiceItemUncheckedUpdateWithoutOfferInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutOfferInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutOfferInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    account: AccountCreateNestedOneWithoutInvoicesInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    accountId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type OfferCreateWithoutItemsInput = {
    id?: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutOffersInput
    account: AccountCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    accountId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferCreateOrConnectWithoutItemsInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutItemsInput, OfferUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutInvoiceItemsInput = {
    id?: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    tenantId: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    serviceParts?: ServicePartUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInvoiceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    account?: AccountUpdateOneRequiredWithoutInvoicesNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type OfferUpsertWithoutItemsInput = {
    update: XOR<OfferUpdateWithoutItemsInput, OfferUncheckedUpdateWithoutItemsInput>
    create: XOR<OfferCreateWithoutItemsInput, OfferUncheckedCreateWithoutItemsInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutItemsInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutItemsInput, OfferUncheckedUpdateWithoutItemsInput>
  }

  export type OfferUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOffersNestedInput
    account?: AccountUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutInvoiceItemsInput = {
    update: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProductUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CashRegisterCreateWithoutPosSessionsInput = {
    id?: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
    transactions?: TransactionCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutPosSessionsInput = {
    id?: string
    tenantId: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutPosSessionsInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutPosSessionsInput, CashRegisterUncheckedCreateWithoutPosSessionsInput>
  }

  export type EmployeeCreateWithoutPosSessionsInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    tickets?: ServiceTicketCreateNestedManyWithoutTechnicianInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPosSessionsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tickets?: ServiceTicketUncheckedCreateNestedManyWithoutTechnicianInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPosSessionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPosSessionsInput, EmployeeUncheckedCreateWithoutPosSessionsInput>
  }

  export type CashRegisterUpsertWithoutPosSessionsInput = {
    update: XOR<CashRegisterUpdateWithoutPosSessionsInput, CashRegisterUncheckedUpdateWithoutPosSessionsInput>
    create: XOR<CashRegisterCreateWithoutPosSessionsInput, CashRegisterUncheckedCreateWithoutPosSessionsInput>
    where?: CashRegisterWhereInput
  }

  export type CashRegisterUpdateToOneWithWhereWithoutPosSessionsInput = {
    where?: CashRegisterWhereInput
    data: XOR<CashRegisterUpdateWithoutPosSessionsInput, CashRegisterUncheckedUpdateWithoutPosSessionsInput>
  }

  export type CashRegisterUpdateWithoutPosSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
    transactions?: TransactionUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutPosSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type EmployeeUpsertWithoutPosSessionsInput = {
    update: XOR<EmployeeUpdateWithoutPosSessionsInput, EmployeeUncheckedUpdateWithoutPosSessionsInput>
    create: XOR<EmployeeCreateWithoutPosSessionsInput, EmployeeUncheckedCreateWithoutPosSessionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPosSessionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPosSessionsInput, EmployeeUncheckedUpdateWithoutPosSessionsInput>
  }

  export type EmployeeUpdateWithoutPosSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    tickets?: ServiceTicketUpdateManyWithoutTechnicianNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPosSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: ServiceTicketUncheckedUpdateManyWithoutTechnicianNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type TenantCreateWithoutServiceTicketsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutServiceTicketsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutServiceTicketsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutServiceTicketsInput, TenantUncheckedCreateWithoutServiceTicketsInput>
  }

  export type AccountCreateWithoutServiceTicketsInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAccountsInput
    invoices?: InvoiceCreateNestedManyWithoutAccountInput
    offers?: OfferCreateNestedManyWithoutAccountInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutServiceTicketsInput = {
    id?: string
    tenantId: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAccountInput
    offers?: OfferUncheckedCreateNestedManyWithoutAccountInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutServiceTicketsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutServiceTicketsInput, AccountUncheckedCreateWithoutServiceTicketsInput>
  }

  export type EmployeeCreateWithoutTicketsInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    posSessions?: PosSessionCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTicketsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTicketsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTicketsInput, EmployeeUncheckedCreateWithoutTicketsInput>
  }

  export type ServicePartCreateWithoutServiceTicketInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    product: ProductCreateNestedOneWithoutServicePartsInput
  }

  export type ServicePartUncheckedCreateWithoutServiceTicketInput = {
    id?: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type ServicePartCreateOrConnectWithoutServiceTicketInput = {
    where: ServicePartWhereUniqueInput
    create: XOR<ServicePartCreateWithoutServiceTicketInput, ServicePartUncheckedCreateWithoutServiceTicketInput>
  }

  export type ServicePartCreateManyServiceTicketInputEnvelope = {
    data: ServicePartCreateManyServiceTicketInput | ServicePartCreateManyServiceTicketInput[]
    skipDuplicates?: boolean
  }

  export type ServiceHistoryCreateWithoutServiceTicketInput = {
    id?: string
    status: $Enums.ServiceStatus
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceHistoryUncheckedCreateWithoutServiceTicketInput = {
    id?: string
    status: $Enums.ServiceStatus
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServiceHistoryCreateOrConnectWithoutServiceTicketInput = {
    where: ServiceHistoryWhereUniqueInput
    create: XOR<ServiceHistoryCreateWithoutServiceTicketInput, ServiceHistoryUncheckedCreateWithoutServiceTicketInput>
  }

  export type ServiceHistoryCreateManyServiceTicketInputEnvelope = {
    data: ServiceHistoryCreateManyServiceTicketInput | ServiceHistoryCreateManyServiceTicketInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutServiceTicketsInput = {
    update: XOR<TenantUpdateWithoutServiceTicketsInput, TenantUncheckedUpdateWithoutServiceTicketsInput>
    create: XOR<TenantCreateWithoutServiceTicketsInput, TenantUncheckedCreateWithoutServiceTicketsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutServiceTicketsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutServiceTicketsInput, TenantUncheckedUpdateWithoutServiceTicketsInput>
  }

  export type TenantUpdateWithoutServiceTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutServiceTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AccountUpsertWithoutServiceTicketsInput = {
    update: XOR<AccountUpdateWithoutServiceTicketsInput, AccountUncheckedUpdateWithoutServiceTicketsInput>
    create: XOR<AccountCreateWithoutServiceTicketsInput, AccountUncheckedCreateWithoutServiceTicketsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutServiceTicketsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutServiceTicketsInput, AccountUncheckedUpdateWithoutServiceTicketsInput>
  }

  export type AccountUpdateWithoutServiceTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAccountsNestedInput
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    offers?: OfferUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutServiceTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EmployeeUpsertWithoutTicketsInput = {
    update: XOR<EmployeeUpdateWithoutTicketsInput, EmployeeUncheckedUpdateWithoutTicketsInput>
    create: XOR<EmployeeCreateWithoutTicketsInput, EmployeeUncheckedCreateWithoutTicketsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTicketsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTicketsInput, EmployeeUncheckedUpdateWithoutTicketsInput>
  }

  export type EmployeeUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    posSessions?: PosSessionUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posSessions?: PosSessionUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ServicePartUpsertWithWhereUniqueWithoutServiceTicketInput = {
    where: ServicePartWhereUniqueInput
    update: XOR<ServicePartUpdateWithoutServiceTicketInput, ServicePartUncheckedUpdateWithoutServiceTicketInput>
    create: XOR<ServicePartCreateWithoutServiceTicketInput, ServicePartUncheckedCreateWithoutServiceTicketInput>
  }

  export type ServicePartUpdateWithWhereUniqueWithoutServiceTicketInput = {
    where: ServicePartWhereUniqueInput
    data: XOR<ServicePartUpdateWithoutServiceTicketInput, ServicePartUncheckedUpdateWithoutServiceTicketInput>
  }

  export type ServicePartUpdateManyWithWhereWithoutServiceTicketInput = {
    where: ServicePartScalarWhereInput
    data: XOR<ServicePartUpdateManyMutationInput, ServicePartUncheckedUpdateManyWithoutServiceTicketInput>
  }

  export type ServiceHistoryUpsertWithWhereUniqueWithoutServiceTicketInput = {
    where: ServiceHistoryWhereUniqueInput
    update: XOR<ServiceHistoryUpdateWithoutServiceTicketInput, ServiceHistoryUncheckedUpdateWithoutServiceTicketInput>
    create: XOR<ServiceHistoryCreateWithoutServiceTicketInput, ServiceHistoryUncheckedCreateWithoutServiceTicketInput>
  }

  export type ServiceHistoryUpdateWithWhereUniqueWithoutServiceTicketInput = {
    where: ServiceHistoryWhereUniqueInput
    data: XOR<ServiceHistoryUpdateWithoutServiceTicketInput, ServiceHistoryUncheckedUpdateWithoutServiceTicketInput>
  }

  export type ServiceHistoryUpdateManyWithWhereWithoutServiceTicketInput = {
    where: ServiceHistoryScalarWhereInput
    data: XOR<ServiceHistoryUpdateManyMutationInput, ServiceHistoryUncheckedUpdateManyWithoutServiceTicketInput>
  }

  export type ServiceHistoryScalarWhereInput = {
    AND?: ServiceHistoryScalarWhereInput | ServiceHistoryScalarWhereInput[]
    OR?: ServiceHistoryScalarWhereInput[]
    NOT?: ServiceHistoryScalarWhereInput | ServiceHistoryScalarWhereInput[]
    id?: StringFilter<"ServiceHistory"> | string
    serviceTicketId?: StringFilter<"ServiceHistory"> | string
    status?: EnumServiceStatusFilter<"ServiceHistory"> | $Enums.ServiceStatus
    note?: StringNullableFilter<"ServiceHistory"> | string | null
    changedBy?: StringNullableFilter<"ServiceHistory"> | string | null
    createdAt?: DateTimeFilter<"ServiceHistory"> | Date | string
  }

  export type ServiceTicketCreateWithoutPartsInput = {
    id?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutServiceTicketsInput
    customer: AccountCreateNestedOneWithoutServiceTicketsInput
    technician?: EmployeeCreateNestedOneWithoutTicketsInput
    history?: ServiceHistoryCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketUncheckedCreateWithoutPartsInput = {
    id?: string
    tenantId: string
    customerId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: ServiceHistoryUncheckedCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketCreateOrConnectWithoutPartsInput = {
    where: ServiceTicketWhereUniqueInput
    create: XOR<ServiceTicketCreateWithoutPartsInput, ServiceTicketUncheckedCreateWithoutPartsInput>
  }

  export type ProductCreateWithoutServicePartsInput = {
    id?: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProductsInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutServicePartsInput = {
    id?: string
    tenantId: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutServicePartsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutServicePartsInput, ProductUncheckedCreateWithoutServicePartsInput>
  }

  export type ServiceTicketUpsertWithoutPartsInput = {
    update: XOR<ServiceTicketUpdateWithoutPartsInput, ServiceTicketUncheckedUpdateWithoutPartsInput>
    create: XOR<ServiceTicketCreateWithoutPartsInput, ServiceTicketUncheckedCreateWithoutPartsInput>
    where?: ServiceTicketWhereInput
  }

  export type ServiceTicketUpdateToOneWithWhereWithoutPartsInput = {
    where?: ServiceTicketWhereInput
    data: XOR<ServiceTicketUpdateWithoutPartsInput, ServiceTicketUncheckedUpdateWithoutPartsInput>
  }

  export type ServiceTicketUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutServiceTicketsNestedInput
    customer?: AccountUpdateOneRequiredWithoutServiceTicketsNestedInput
    technician?: EmployeeUpdateOneWithoutTicketsNestedInput
    history?: ServiceHistoryUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: ServiceHistoryUncheckedUpdateManyWithoutServiceTicketNestedInput
  }

  export type ProductUpsertWithoutServicePartsInput = {
    update: XOR<ProductUpdateWithoutServicePartsInput, ProductUncheckedUpdateWithoutServicePartsInput>
    create: XOR<ProductCreateWithoutServicePartsInput, ProductUncheckedCreateWithoutServicePartsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutServicePartsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutServicePartsInput, ProductUncheckedUpdateWithoutServicePartsInput>
  }

  export type ProductUpdateWithoutServicePartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutServicePartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ServiceTicketCreateWithoutHistoryInput = {
    id?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutServiceTicketsInput
    customer: AccountCreateNestedOneWithoutServiceTicketsInput
    technician?: EmployeeCreateNestedOneWithoutTicketsInput
    parts?: ServicePartCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketUncheckedCreateWithoutHistoryInput = {
    id?: string
    tenantId: string
    customerId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: ServicePartUncheckedCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketCreateOrConnectWithoutHistoryInput = {
    where: ServiceTicketWhereUniqueInput
    create: XOR<ServiceTicketCreateWithoutHistoryInput, ServiceTicketUncheckedCreateWithoutHistoryInput>
  }

  export type ServiceTicketUpsertWithoutHistoryInput = {
    update: XOR<ServiceTicketUpdateWithoutHistoryInput, ServiceTicketUncheckedUpdateWithoutHistoryInput>
    create: XOR<ServiceTicketCreateWithoutHistoryInput, ServiceTicketUncheckedCreateWithoutHistoryInput>
    where?: ServiceTicketWhereInput
  }

  export type ServiceTicketUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ServiceTicketWhereInput
    data: XOR<ServiceTicketUpdateWithoutHistoryInput, ServiceTicketUncheckedUpdateWithoutHistoryInput>
  }

  export type ServiceTicketUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutServiceTicketsNestedInput
    customer?: AccountUpdateOneRequiredWithoutServiceTicketsNestedInput
    technician?: EmployeeUpdateOneWithoutTicketsNestedInput
    parts?: ServicePartUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: ServicePartUncheckedUpdateManyWithoutServiceTicketNestedInput
  }

  export type TenantCreateWithoutEmployeesInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmployeesInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmployeesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
  }

  export type ServiceTicketCreateWithoutTechnicianInput = {
    id?: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutServiceTicketsInput
    customer: AccountCreateNestedOneWithoutServiceTicketsInput
    parts?: ServicePartCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketUncheckedCreateWithoutTechnicianInput = {
    id?: string
    tenantId: string
    customerId: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parts?: ServicePartUncheckedCreateNestedManyWithoutServiceTicketInput
    history?: ServiceHistoryUncheckedCreateNestedManyWithoutServiceTicketInput
  }

  export type ServiceTicketCreateOrConnectWithoutTechnicianInput = {
    where: ServiceTicketWhereUniqueInput
    create: XOR<ServiceTicketCreateWithoutTechnicianInput, ServiceTicketUncheckedCreateWithoutTechnicianInput>
  }

  export type ServiceTicketCreateManyTechnicianInputEnvelope = {
    data: ServiceTicketCreateManyTechnicianInput | ServiceTicketCreateManyTechnicianInput[]
    skipDuplicates?: boolean
  }

  export type PosSessionCreateWithoutEmployeeInput = {
    id?: string
    tenantId: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
    register: CashRegisterCreateNestedOneWithoutPosSessionsInput
  }

  export type PosSessionUncheckedCreateWithoutEmployeeInput = {
    id?: string
    tenantId: string
    registerId: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionCreateOrConnectWithoutEmployeeInput = {
    where: PosSessionWhereUniqueInput
    create: XOR<PosSessionCreateWithoutEmployeeInput, PosSessionUncheckedCreateWithoutEmployeeInput>
  }

  export type PosSessionCreateManyEmployeeInputEnvelope = {
    data: PosSessionCreateManyEmployeeInput | PosSessionCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutEmployeeInput = {
    id?: string
    month: string
    amount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidAt?: Date | string | null
  }

  export type PayrollUncheckedCreateWithoutEmployeeInput = {
    id?: string
    month: string
    amount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidAt?: Date | string | null
  }

  export type PayrollCreateOrConnectWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollCreateManyEmployeeInputEnvelope = {
    data: PayrollCreateManyEmployeeInput | PayrollCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
  }

  export type LeaveRequestUncheckedCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
  }

  export type LeaveRequestCreateOrConnectWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestCreateManyEmployeeInputEnvelope = {
    data: LeaveRequestCreateManyEmployeeInput | LeaveRequestCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutEmployeesInput = {
    update: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type TenantUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ServiceTicketUpsertWithWhereUniqueWithoutTechnicianInput = {
    where: ServiceTicketWhereUniqueInput
    update: XOR<ServiceTicketUpdateWithoutTechnicianInput, ServiceTicketUncheckedUpdateWithoutTechnicianInput>
    create: XOR<ServiceTicketCreateWithoutTechnicianInput, ServiceTicketUncheckedCreateWithoutTechnicianInput>
  }

  export type ServiceTicketUpdateWithWhereUniqueWithoutTechnicianInput = {
    where: ServiceTicketWhereUniqueInput
    data: XOR<ServiceTicketUpdateWithoutTechnicianInput, ServiceTicketUncheckedUpdateWithoutTechnicianInput>
  }

  export type ServiceTicketUpdateManyWithWhereWithoutTechnicianInput = {
    where: ServiceTicketScalarWhereInput
    data: XOR<ServiceTicketUpdateManyMutationInput, ServiceTicketUncheckedUpdateManyWithoutTechnicianInput>
  }

  export type PosSessionUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PosSessionWhereUniqueInput
    update: XOR<PosSessionUpdateWithoutEmployeeInput, PosSessionUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PosSessionCreateWithoutEmployeeInput, PosSessionUncheckedCreateWithoutEmployeeInput>
  }

  export type PosSessionUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PosSessionWhereUniqueInput
    data: XOR<PosSessionUpdateWithoutEmployeeInput, PosSessionUncheckedUpdateWithoutEmployeeInput>
  }

  export type PosSessionUpdateManyWithWhereWithoutEmployeeInput = {
    where: PosSessionScalarWhereInput
    data: XOR<PosSessionUpdateManyMutationInput, PosSessionUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutEmployeeInput, PayrollUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutEmployeeInput, PayrollUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: StringFilter<"Payroll"> | string
    employeeId?: StringFilter<"Payroll"> | string
    month?: StringFilter<"Payroll"> | string
    amount?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFilter<"Payroll"> | boolean
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: EnumLeaveStatusFilter<"LeaveRequest"> | $Enums.LeaveStatus
  }

  export type EmployeeCreateWithoutPayrollsInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    tickets?: ServiceTicketCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPayrollsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tickets?: ServiceTicketUncheckedCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPayrollsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
  }

  export type EmployeeUpsertWithoutPayrollsInput = {
    update: XOR<EmployeeUpdateWithoutPayrollsInput, EmployeeUncheckedUpdateWithoutPayrollsInput>
    create: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPayrollsInput, EmployeeUncheckedUpdateWithoutPayrollsInput>
  }

  export type EmployeeUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    tickets?: ServiceTicketUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: ServiceTicketUncheckedUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutLeavesInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    tickets?: ServiceTicketCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesInput = {
    id?: string
    tenantId: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
    tickets?: ServiceTicketUncheckedCreateNestedManyWithoutTechnicianInput
    posSessions?: PosSessionUncheckedCreateNestedManyWithoutEmployeeInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
  }

  export type EmployeeUpsertWithoutLeavesInput = {
    update: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    tickets?: ServiceTicketUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: ServiceTicketUncheckedUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PackageModuleCreateWithoutModuleInput = {
    id?: string
    package: SubscriptionPackageCreateNestedOneWithoutModulesInput
  }

  export type PackageModuleUncheckedCreateWithoutModuleInput = {
    id?: string
    packageId: string
  }

  export type PackageModuleCreateOrConnectWithoutModuleInput = {
    where: PackageModuleWhereUniqueInput
    create: XOR<PackageModuleCreateWithoutModuleInput, PackageModuleUncheckedCreateWithoutModuleInput>
  }

  export type PackageModuleCreateManyModuleInputEnvelope = {
    data: PackageModuleCreateManyModuleInput | PackageModuleCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type PackageModuleUpsertWithWhereUniqueWithoutModuleInput = {
    where: PackageModuleWhereUniqueInput
    update: XOR<PackageModuleUpdateWithoutModuleInput, PackageModuleUncheckedUpdateWithoutModuleInput>
    create: XOR<PackageModuleCreateWithoutModuleInput, PackageModuleUncheckedCreateWithoutModuleInput>
  }

  export type PackageModuleUpdateWithWhereUniqueWithoutModuleInput = {
    where: PackageModuleWhereUniqueInput
    data: XOR<PackageModuleUpdateWithoutModuleInput, PackageModuleUncheckedUpdateWithoutModuleInput>
  }

  export type PackageModuleUpdateManyWithWhereWithoutModuleInput = {
    where: PackageModuleScalarWhereInput
    data: XOR<PackageModuleUpdateManyMutationInput, PackageModuleUncheckedUpdateManyWithoutModuleInput>
  }

  export type SubscriptionPackageCreateWithoutModulesInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    maxUsers?: number
    maxProducts?: number
    storageLimit?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: number
    isDemo?: boolean
    demoDuration?: number
    discountPercentage?: Decimal | DecimalJsLike | number | string
    discountEndDate?: Date | string | null
    highlightColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenants?: TenantCreateNestedManyWithoutSubscriptionPackageInput
  }

  export type SubscriptionPackageUncheckedCreateWithoutModulesInput = {
    id?: string
    name: string
    description?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceYearly?: Decimal | DecimalJsLike | number | string
    maxUsers?: number
    maxProducts?: number
    storageLimit?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: boolean
    isActive?: boolean
    sortOrder?: number
    isDemo?: boolean
    demoDuration?: number
    discountPercentage?: Decimal | DecimalJsLike | number | string
    discountEndDate?: Date | string | null
    highlightColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenants?: TenantUncheckedCreateNestedManyWithoutSubscriptionPackageInput
  }

  export type SubscriptionPackageCreateOrConnectWithoutModulesInput = {
    where: SubscriptionPackageWhereUniqueInput
    create: XOR<SubscriptionPackageCreateWithoutModulesInput, SubscriptionPackageUncheckedCreateWithoutModulesInput>
  }

  export type ModuleCreateWithoutPackagesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ModuleUncheckedCreateWithoutPackagesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ModuleCreateOrConnectWithoutPackagesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutPackagesInput, ModuleUncheckedCreateWithoutPackagesInput>
  }

  export type SubscriptionPackageUpsertWithoutModulesInput = {
    update: XOR<SubscriptionPackageUpdateWithoutModulesInput, SubscriptionPackageUncheckedUpdateWithoutModulesInput>
    create: XOR<SubscriptionPackageCreateWithoutModulesInput, SubscriptionPackageUncheckedCreateWithoutModulesInput>
    where?: SubscriptionPackageWhereInput
  }

  export type SubscriptionPackageUpdateToOneWithWhereWithoutModulesInput = {
    where?: SubscriptionPackageWhereInput
    data: XOR<SubscriptionPackageUpdateWithoutModulesInput, SubscriptionPackageUncheckedUpdateWithoutModulesInput>
  }

  export type SubscriptionPackageUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: TenantUpdateManyWithoutSubscriptionPackageNestedInput
  }

  export type SubscriptionPackageUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceYearly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: IntFieldUpdateOperationsInput | number
    storageLimit?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    demoDuration?: IntFieldUpdateOperationsInput | number
    discountPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenants?: TenantUncheckedUpdateManyWithoutSubscriptionPackageNestedInput
  }

  export type ModuleUpsertWithoutPackagesInput = {
    update: XOR<ModuleUpdateWithoutPackagesInput, ModuleUncheckedUpdateWithoutPackagesInput>
    create: XOR<ModuleCreateWithoutPackagesInput, ModuleUncheckedCreateWithoutPackagesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutPackagesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutPackagesInput, ModuleUncheckedUpdateWithoutPackagesInput>
  }

  export type ModuleUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSuperAdminRoleInput = {
    id?: string
    userNo?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    tenant: TenantCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSuperAdminRoleInput = {
    id?: string
    userNo?: number
    tenantId: string
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSuperAdminRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuperAdminRoleInput, UserUncheckedCreateWithoutSuperAdminRoleInput>
  }

  export type UserCreateManySuperAdminRoleInputEnvelope = {
    data: UserCreateManySuperAdminRoleInput | UserCreateManySuperAdminRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutSuperAdminRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSuperAdminRoleInput, UserUncheckedUpdateWithoutSuperAdminRoleInput>
    create: XOR<UserCreateWithoutSuperAdminRoleInput, UserUncheckedCreateWithoutSuperAdminRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSuperAdminRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSuperAdminRoleInput, UserUncheckedUpdateWithoutSuperAdminRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutSuperAdminRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSuperAdminRoleInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    userNo?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    tenant: TenantCreateNestedOneWithoutUsersInput
    superAdminRole?: SuperAdminRoleCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    userNo?: number
    tenantId: string
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    superAdminRoleId?: string | null
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    superAdminRole?: SuperAdminRoleUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userNo?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    superAdminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantCreateWithoutIntegrationsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutIntegrationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
  }

  export type TenantUpsertWithoutIntegrationsInput = {
    update: XOR<TenantUpdateWithoutIntegrationsInput, TenantUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutIntegrationsInput, TenantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type TenantUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutTemplatesInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTemplatesInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTemplatesInput, TenantUncheckedCreateWithoutTemplatesInput>
  }

  export type TenantUpsertWithoutTemplatesInput = {
    update: XOR<TenantUpdateWithoutTemplatesInput, TenantUncheckedUpdateWithoutTemplatesInput>
    create: XOR<TenantCreateWithoutTemplatesInput, TenantUncheckedCreateWithoutTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTemplatesInput, TenantUncheckedUpdateWithoutTemplatesInput>
  }

  export type TenantUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSupportTicketsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptionPackage?: SubscriptionPackageCreateNestedOneWithoutTenantsInput
    users?: UserCreateNestedManyWithoutTenantInput
    accounts?: AccountCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    offers?: OfferCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    templates?: TemplateCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: string | null
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    accounts?: AccountUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    offers?: OfferUncheckedCreateNestedManyWithoutTenantInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    serviceTickets?: ServiceTicketUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payments?: SaaSPaymentUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    templates?: TemplateUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSupportTicketsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
  }

  export type TicketReplyCreateWithoutTicketInput = {
    id?: string
    userId: string
    message: string
    isAdminReply?: boolean
    createdAt?: Date | string
  }

  export type TicketReplyUncheckedCreateWithoutTicketInput = {
    id?: string
    userId: string
    message: string
    isAdminReply?: boolean
    createdAt?: Date | string
  }

  export type TicketReplyCreateOrConnectWithoutTicketInput = {
    where: TicketReplyWhereUniqueInput
    create: XOR<TicketReplyCreateWithoutTicketInput, TicketReplyUncheckedCreateWithoutTicketInput>
  }

  export type TicketReplyCreateManyTicketInputEnvelope = {
    data: TicketReplyCreateManyTicketInput | TicketReplyCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSupportTicketsInput = {
    update: XOR<TenantUpdateWithoutSupportTicketsInput, TenantUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<TenantCreateWithoutSupportTicketsInput, TenantUncheckedCreateWithoutSupportTicketsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSupportTicketsInput, TenantUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type TenantUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionPackage?: SubscriptionPackageUpdateOneWithoutTenantsNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    subscriptionPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TicketReplyUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketReplyWhereUniqueInput
    update: XOR<TicketReplyUpdateWithoutTicketInput, TicketReplyUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketReplyCreateWithoutTicketInput, TicketReplyUncheckedCreateWithoutTicketInput>
  }

  export type TicketReplyUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketReplyWhereUniqueInput
    data: XOR<TicketReplyUpdateWithoutTicketInput, TicketReplyUncheckedUpdateWithoutTicketInput>
  }

  export type TicketReplyUpdateManyWithWhereWithoutTicketInput = {
    where: TicketReplyScalarWhereInput
    data: XOR<TicketReplyUpdateManyMutationInput, TicketReplyUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketReplyScalarWhereInput = {
    AND?: TicketReplyScalarWhereInput | TicketReplyScalarWhereInput[]
    OR?: TicketReplyScalarWhereInput[]
    NOT?: TicketReplyScalarWhereInput | TicketReplyScalarWhereInput[]
    id?: StringFilter<"TicketReply"> | string
    ticketId?: StringFilter<"TicketReply"> | string
    userId?: StringFilter<"TicketReply"> | string
    message?: StringFilter<"TicketReply"> | string
    isAdminReply?: BoolFilter<"TicketReply"> | boolean
    createdAt?: DateTimeFilter<"TicketReply"> | Date | string
  }

  export type SupportTicketCreateWithoutRepliesInput = {
    id?: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutRepliesInput = {
    id?: string
    tenantId: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutRepliesInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutRepliesInput, SupportTicketUncheckedCreateWithoutRepliesInput>
  }

  export type SupportTicketUpsertWithoutRepliesInput = {
    update: XOR<SupportTicketUpdateWithoutRepliesInput, SupportTicketUncheckedUpdateWithoutRepliesInput>
    create: XOR<SupportTicketCreateWithoutRepliesInput, SupportTicketUncheckedCreateWithoutRepliesInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutRepliesInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutRepliesInput, SupportTicketUncheckedUpdateWithoutRepliesInput>
  }

  export type SupportTicketUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateManySubscriptionPackageInput = {
    id?: string
    tag?: string
    name: string
    type?: $Enums.TenantType
    taxNumber?: string | null
    taxOffice?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TenantStatus
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageModuleCreateManyPackageInput = {
    id?: string
    moduleId: string
  }

  export type TenantUpdateWithoutSubscriptionPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    accounts?: AccountUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    offers?: OfferUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    templates?: TemplateUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSubscriptionPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    offers?: OfferUncheckedUpdateManyWithoutTenantNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payments?: SaaSPaymentUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutTenantNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutSubscriptionPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    taxOffice?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageModuleUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: ModuleUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type PackageModuleUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageModuleUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    userNo?: number
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
    superAdminRoleId?: string | null
  }

  export type AccountCreateManyTenantInput = {
    id?: string
    type: $Enums.AccountType
    accountCode?: string | null
    name: string
    balance?: Decimal | DecimalJsLike | number | string
    riskLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyTenantInput = {
    id?: string
    name: string
    code?: string | null
    barcode?: string | null
    stockQuantity?: number
    priceSell?: Decimal | DecimalJsLike | number | string
    trackStock?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    accountId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferCreateManyTenantInput = {
    id?: string
    accountId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMovementCreateManyTenantInput = {
    id?: string
    productId: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyTenantInput = {
    id?: string
    registerId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type ServiceTicketCreateManyTenantInput = {
    id?: string
    customerId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashRegisterCreateManyTenantInput = {
    id?: string
    name: string
    currency?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type EmployeeCreateManyTenantInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    position?: string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    createdAt?: Date | string
  }

  export type SaaSPaymentCreateManyTenantInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateManyTenantInput = {
    id?: string
    type: string
    name: string
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCreateManyTenantInput = {
    id?: string
    type: string
    code: string
    name: string
    subject?: string | null
    content: string
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateManyTenantInput = {
    id?: string
    userId: string
    subject: string
    message: string
    category?: string
    priority?: $Enums.TicketPriority
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    superAdminRole?: SuperAdminRoleUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userNo?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    superAdminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userNo?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    superAdminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutAccountNestedInput
    offers?: OfferUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUpdateManyWithoutCustomerNestedInput
  }

  export type AccountUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutAccountNestedInput
    offers?: OfferUncheckedUpdateManyWithoutAccountNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    serviceTickets?: ServiceTicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    accountCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    serviceParts?: ServicePartUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    priceSell?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trackStock?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutOffersNestedInput
    items?: InvoiceItemUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    register?: CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTicketUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: AccountUpdateOneRequiredWithoutServiceTicketsNestedInput
    technician?: EmployeeUpdateOneWithoutTicketsNestedInput
    parts?: ServicePartUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: ServicePartUncheckedUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUncheckedUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRegisterUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutRegisterNestedInput
    posSessions?: PosSessionUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRegisterNestedInput
    posSessions?: PosSessionUncheckedUpdateManyWithoutRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: ServiceTicketUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: ServiceTicketUncheckedUpdateManyWithoutTechnicianNestedInput
    posSessions?: PosSessionUncheckedUpdateManyWithoutEmployeeNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaaSPaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaaSPaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaaSPaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: TicketReplyUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: TicketReplyUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyAccountInput = {
    id?: string
    tenantId: string
    type: $Enums.InvoiceType
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferCreateManyAccountInput = {
    id?: string
    tenantId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.OfferStatus
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyAccountInput = {
    id?: string
    tenantId: string
    registerId: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type ServiceTicketCreateManyCustomerInput = {
    id?: string
    tenantId: string
    technicianId?: string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOffersNestedInput
    items?: InvoiceItemUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    register?: CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTicketUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutServiceTicketsNestedInput
    technician?: EmployeeUpdateOneWithoutTicketsNestedInput
    parts?: ServicePartUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: ServicePartUncheckedUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUncheckedUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyProductInput = {
    id?: string
    tenantId: string
    type: $Enums.StockMovementType
    quantity: number
    documentRef?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemCreateManyProductInput = {
    id?: string
    invoiceId?: string | null
    offerId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type ServicePartCreateManyProductInput = {
    id?: string
    serviceTicketId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type StockMovementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneWithoutItemsNestedInput
    offer?: OfferUpdateOneWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicePartUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceTicket?: ServiceTicketUpdateOneRequiredWithoutPartsNestedInput
  }

  export type ServicePartUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceTicketId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicePartUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceTicketId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TransactionCreateManyRegisterInput = {
    id?: string
    tenantId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
  }

  export type PosSessionCreateManyRegisterInput = {
    id?: string
    tenantId: string
    employeeId?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
  }

  export type TransactionUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosSessionUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employee?: EmployeeUpdateOneWithoutPosSessionsNestedInput
  }

  export type PosSessionUncheckedUpdateWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionUncheckedUpdateManyWithoutRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    offerId?: string | null
    productId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type TransactionCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    registerId: string
    accountId?: string | null
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    description?: string | null
    relatedId?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offer?: OfferUpdateOneWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TransactionUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    register?: CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput
    account?: AccountUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyOfferInput = {
    id?: string
    invoiceId?: string | null
    productId?: string | null
    name: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicePartCreateManyServiceTicketInput = {
    id?: string
    productId: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
  }

  export type ServiceHistoryCreateManyServiceTicketInput = {
    id?: string
    status: $Enums.ServiceStatus
    note?: string | null
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type ServicePartUpdateWithoutServiceTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneRequiredWithoutServicePartsNestedInput
  }

  export type ServicePartUncheckedUpdateWithoutServiceTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicePartUncheckedUpdateManyWithoutServiceTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServiceHistoryUpdateWithoutServiceTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceHistoryUncheckedUpdateWithoutServiceTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceHistoryUncheckedUpdateManyWithoutServiceTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTicketCreateManyTechnicianInput = {
    id?: string
    tenantId: string
    customerId: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: string | null
    status?: $Enums.ServiceStatus
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    finalCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosSessionCreateManyEmployeeInput = {
    id?: string
    tenantId: string
    registerId: string
    openedAt?: Date | string
    closedAt?: Date | string | null
    openingBalance: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string | null
  }

  export type PayrollCreateManyEmployeeInput = {
    id?: string
    month: string
    amount: Decimal | DecimalJsLike | number | string
    isPaid?: boolean
    paidAt?: Date | string | null
  }

  export type LeaveRequestCreateManyEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.LeaveStatus
  }

  export type ServiceTicketUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutServiceTicketsNestedInput
    customer?: AccountUpdateOneRequiredWithoutServiceTicketsNestedInput
    parts?: ServicePartUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parts?: ServicePartUncheckedUpdateManyWithoutServiceTicketNestedInput
    history?: ServiceHistoryUncheckedUpdateManyWithoutServiceTicketNestedInput
  }

  export type ServiceTicketUncheckedUpdateManyWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    problemDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosSessionUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    register?: CashRegisterUpdateOneRequiredWithoutPosSessionsNestedInput
  }

  export type PosSessionUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PosSessionUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registerId?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PayrollUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayrollUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveRequestUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
  }

  export type LeaveRequestUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
  }

  export type PackageModuleCreateManyModuleInput = {
    id?: string
    packageId: string
  }

  export type PackageModuleUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    package?: SubscriptionPackageUpdateOneRequiredWithoutModulesNestedInput
  }

  export type PackageModuleUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageModuleUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManySuperAdminRoleInput = {
    id?: string
    userNo?: number
    tenantId: string
    name?: string | null
    email: string
    passwordHash: string
    role?: $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: string | null
    avatar?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isTwoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    phoneNumber?: string | null
    twoFactorSecret?: string | null
    twoFactorExpires?: Date | string | null
    isSuperAdmin?: boolean
  }

  export type UserUpdateWithoutSuperAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSuperAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userNo?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSuperAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userNo?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: NullableJsonNullValueInput | InputJsonValue
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSuperAdmin?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketReplyCreateManyTicketInput = {
    id?: string
    userId: string
    message: string
    isAdminReply?: boolean
    createdAt?: Date | string
  }

  export type TicketReplyUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isAdminReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketReplyUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isAdminReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketReplyUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isAdminReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SubscriptionPackageCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionPackageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPackageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashRegisterCountOutputTypeDefaultArgs instead
     */
    export type CashRegisterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashRegisterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferCountOutputTypeDefaultArgs instead
     */
    export type OfferCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OfferCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceTicketCountOutputTypeDefaultArgs instead
     */
    export type ServiceTicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceTicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeCountOutputTypeDefaultArgs instead
     */
    export type EmployeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleCountOutputTypeDefaultArgs instead
     */
    export type ModuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SuperAdminRoleCountOutputTypeDefaultArgs instead
     */
    export type SuperAdminRoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SuperAdminRoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketCountOutputTypeDefaultArgs instead
     */
    export type SupportTicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionPackageDefaultArgs instead
     */
    export type SubscriptionPackageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionPackageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaaSPaymentDefaultArgs instead
     */
    export type SaaSPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaaSPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockMovementDefaultArgs instead
     */
    export type StockMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashRegisterDefaultArgs instead
     */
    export type CashRegisterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashRegisterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferDefaultArgs instead
     */
    export type OfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OfferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PosSessionDefaultArgs instead
     */
    export type PosSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PosSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceTicketDefaultArgs instead
     */
    export type ServiceTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicePartDefaultArgs instead
     */
    export type ServicePartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicePartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceHistoryDefaultArgs instead
     */
    export type ServiceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeDefaultArgs instead
     */
    export type EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayrollDefaultArgs instead
     */
    export type PayrollArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayrollDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveRequestDefaultArgs instead
     */
    export type LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigDefaultArgs instead
     */
    export type SystemConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleDefaultArgs instead
     */
    export type ModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackageModuleDefaultArgs instead
     */
    export type PackageModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackageModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SuperAdminRoleDefaultArgs instead
     */
    export type SuperAdminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SuperAdminRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LandingContentDefaultArgs instead
     */
    export type LandingContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LandingContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentProviderDefaultArgs instead
     */
    export type PaymentProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentProviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankAccountDefaultArgs instead
     */
    export type BankAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationDefaultArgs instead
     */
    export type IntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateDefaultArgs instead
     */
    export type TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketDefaultArgs instead
     */
    export type SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketReplyDefaultArgs instead
     */
    export type TicketReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketReplyDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}